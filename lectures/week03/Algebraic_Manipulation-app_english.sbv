0:00:01.530,0:00:09.650
Let me start this week's lecture, or the lecture
videos for this week, with some remarks here

0:00:09.650,0:00:16.880
on the whiteboard, again, both refreshing
some aspects of expression style that were

0:00:16.880,0:00:23.170
discussed last week, but also already discussing
a few aspects or observations I made from

0:00:23.170,0:00:24.650
the first exercise submissions
(of a previous year).

0:00:24.650,0:00:29.650
So, usually, I try to do this, to have a look
at the exercise submissions before the lecture

0:00:29.650,0:00:35.250
and then comment on things that I observed
and seem important or interesting for the

0:00:35.250,0:00:36.250
lecture.

0:00:36.250,0:00:47.239
I don't know whether this will often be possible
this year because [... outdated comments ...]

0:00:47.239,0:00:52.710
So, in this case, one day before the lecture,
but in other cases, maybe I will even record

0:00:52.710,0:00:55.129
videos two days or earlier before the lecture.

0:00:55.129,0:01:00.539
And then I don't want, of course,
to spoil too much from the exercise.

0:01:00.539,0:01:06.680
Okay, anyway, so a few small things I can
discuss now because at least I had a look

0:01:06.680,0:01:10.840
at the first submissions, even though
not all of them are yet in the system.

0:01:10.840,0:01:15.000
So let me discuss a few small things first.

0:01:15.000,0:01:17.340
One thing is syntax.

0:01:17.340,0:01:23.100
That is something that I commented on
already in last week's lecture and examples.

0:01:23.100,0:01:28.539
And the dominant thing, also what Autotool
was pointing out in the first submissions,

0:01:28.539,0:01:37.109
things like student submissions
consisting of, or containing code

0:01:37.109,0:01:38.109
like this.

0:01:38.109,0:01:43.039
So, a call of the 'translated' function with
two arguments for the x and y direction, and

0:01:43.039,0:01:47.860
then some rectangle or whatever.

0:01:47.860,0:01:53.200
And then if you look carefully, then Autotool
in a submission like this would have told you

0:01:53.200,0:01:58.479
that these brackets are unnecessary, and would
even suggest that you should write just five

0:01:58.479,0:01:59.499
and three there.

0:01:59.499,0:02:02.310
We were not yet punishing this.

0:02:02.310,0:02:08.679
So, these suggestions that Autotool gives
you are really just suggestions yet.

0:02:08.679,0:02:14.010
But I still encourage you to read that
feedback and also act on it, because sooner

0:02:14.010,0:02:17.550
or later, we will enforce
more of these suggestions.

0:02:17.550,0:02:24.159
So, they will actually become mandatory things
and then you have to change your code, because

0:02:24.159,0:02:26.550
otherwise it will not be accepted.

0:02:26.550,0:02:28.870
And you don't want this, in
the interest of correctness.

0:02:28.870,0:02:33.620
And so, it's a good habit to, early on, really
read the feedback that Autotool is giving

0:02:33.620,0:02:34.620
you.

0:02:34.620,0:02:41.470
So that you can both improve your code and
actually later not be frustrated because Autotool

0:02:41.470,0:02:47.210
doesn't even accept your submissions because
they violate certain style and other

0:02:47.210,0:02:50.250
guidelines that we enforce.

0:02:50.250,0:02:51.250
Okay.

0:02:51.250,0:02:58.180
And I also know, and I've seen that in some
cases in the first week, the Autotool feedback

0:02:58.180,0:03:03.030
contained some junk or some… in particular,
the first few submissions of students that

0:03:03.030,0:03:08.250
have submitted, had some comments in their
Autotool feedback that didn't really make

0:03:08.250,0:03:12.870
sense; something about some part of the code
only appearing in their submission, that was

0:03:12.870,0:03:18.379
actually a small bug in Autotool, that it printed
something that it wasn't supposed to print

0:03:18.379,0:03:19.379
in these places.

0:03:19.379,0:03:21.959
So, this has been fixed
and shouldn't occur again.

0:03:21.959,0:03:28.370
So, the general remark is you should
read the feedback and act on it.

0:03:28.370,0:03:32.030
And a few students will actually, in the first
week, have gotten some feedback that they couldn't

0:03:32.030,0:03:34.680
really have acted on, because
that didn't make much sense.

0:03:34.680,0:03:38.180
But that should be an exception
and shouldn't occur again, we hope.

0:03:38.180,0:03:39.180
Okay.

0:03:39.180,0:03:44.670
So, this was a general syntax remark,
which applied to quite a few submissions.

0:03:44.670,0:03:51.030
And then I actually want to make a more semantic
and more interesting remark discussing one

0:03:51.030,0:03:55.400
particular submission, not because it was bad
or anything; actually, it's an interesting

0:03:55.400,0:03:56.400
submission.

0:03:56.400,0:04:01.519
And I won't reproduce it completely, but I
want to show some parts of it and use that

0:04:01.519,0:04:06.819
for a discussion of expression style,
which is somehow fits quite nicely.

0:04:06.819,0:04:13.420
Okay, so there was this task of drawing this
tree and without giving a full solution here,

0:04:13.420,0:04:15.719
because that's what the exercises are for.

0:04:15.719,0:04:23.150
And I want to show part of, or a sketch of one
solution that I saw in one of the first submissions

0:04:23.150,0:04:26.759
looked something like this; I will
omit all the type annotations.

0:04:26.759,0:04:34.110
So, there was something like this, the scene
value that was composed out of a few components,

0:04:34.110,0:04:38.830
and among them, that was the leaves, right,
because this tree was supposed to have some

0:04:38.830,0:04:39.830
leaves.

0:04:39.830,0:04:42.960
So, there was some definition, then the
leaves, how were the leaves defined?

0:04:42.960,0:04:46.110
Well, there was a separate definition.

0:04:46.110,0:04:53.090
And again, that consisted of some subexpressions,
and one of them was something like a rotated

0:04:53.090,0:04:54.090
circle.

0:04:54.090,0:04:59.460
So, the name of some other expressions, some
other picture that occurred somewhere in

0:04:59.460,0:05:10.340
the middle of a larger expression, then this
rotated circle was defined as something like:

0:05:10.340,0:05:17.160
We call this function for moving a picture
with some arguments, something like

0:05:17.160,0:05:18.440
this.

0:05:18.440,0:05:19.440
And what was it?

0:05:19.440,0:05:20.810
What was moved?

0:05:20.810,0:05:28.810
Well, some call of the 'rotated' function with
some arguments, something like pi over four.

0:05:28.810,0:05:29.810
And of what?

0:05:29.810,0:05:34.910
Well, of some green form that was supposed
to be part of the leaves, apparently.

0:05:34.910,0:05:36.590
And how was that green form defined?

0:05:36.590,0:05:39.030
Well, again, in a separate definition.

0:05:39.030,0:05:46.770
And that was a “colored” call, of course,
because it's supposed to be a green form.

0:05:46.770,0:05:47.889
And what is “colored”?

0:05:47.889,0:05:56.560
Well, in this case, it was a solid
circle with some radius, 2 or so.

0:05:56.560,0:05:57.560
Okay.

0:05:57.560,0:06:00.860
So, and then there was, of course,
a completion of this whole thing.

0:06:00.860,0:06:04.500
So, that was a working
program. Everything's fine.

0:06:04.500,0:06:06.979
Okay, some observations on this.

0:06:06.979,0:06:11.510
Well, one thing I would observe, and that
applies really to a lot of the submissions,

0:06:11.510,0:06:18.000
is the balance between top-level
definitions and local definitions, right?

0:06:18.000,0:06:22.280
There was a long file, where
many more forms were defined

0:06:22.280,0:06:23.319
in the same way.

0:06:23.319,0:06:27.710
And all of them got a top-level name and
then appeared in this long list of things.

0:06:27.710,0:06:28.759
That's okay.

0:06:28.759,0:06:33.490
But actually, I would argue that probably
most of these definitions could also be just

0:06:33.490,0:06:34.840
used as a local definition.

0:06:34.840,0:06:39.260
So, I would encourage you, if you encounter a
situation like this in the exercise, where you write

0:06:39.260,0:06:44.550
many definitions, that maybe you think
about not having this green form on the top

0:06:44.550,0:06:47.430
level, but for example, adding
it here as a local definition.

0:06:47.430,0:06:50.610
Yes, we have seen this in last week's examples,

0:06:50.610,0:06:57.949
that you can also write a definition
here. It's somehow more logically grouped.

0:06:57.949,0:07:04.919
Okay, that's a general remark that applies
to a lot of the submissions I have seen.

0:07:04.919,0:07:07.600
Again, it doesn't mean that
what you see here is wrong.

0:07:07.600,0:07:14.220
It's just a general remark that you
could make more use of local definitions.

0:07:14.220,0:07:21.000
But actually, there's some other thing
that surprised me here, when I saw this.

0:07:21.000,0:07:24.250
And basically, it's mainly
this name: rotatedCircle.

0:07:24.250,0:07:29.139
I was wondering why would I rotate a circle?
A circle is a round thing that doesn't really

0:07:29.139,0:07:30.240
have orientations.

0:07:30.240,0:07:32.190
Why would I rotate a circle?

0:07:32.190,0:07:36.930
And indeed, if you look at the closest example,
you will probably realize, and you could even

0:07:36.930,0:07:41.820
try it out if you have the solution in front
of you, that you probably don't need this

0:07:41.820,0:07:42.820
rotated call.

0:07:42.820,0:07:45.811
Yes, you could think about it and say, well,
I don't need to rotate the circle, because

0:07:45.811,0:07:49.479
anyway, it doesn't change
its form by just rotation.

0:07:49.479,0:07:51.539
This is one way to look at it.

0:07:51.539,0:07:55.140
But then, of course, there's also the question
of whether you could argue this in general?

0:07:55.140,0:07:56.319
Or could you prove this?

0:07:56.319,0:08:00.780
Or is this something that you could do as
part of refactoring once you see such code.

0:08:00.780,0:08:03.229
For example, it's not my code,
it's someone else's code.

0:08:03.229,0:08:09.139
So, I'm maybe not sure whether just going by
this name, maybe that's not enough indication

0:08:09.139,0:08:12.770
that I should really change it, maybe
this name is simply not appropriate.

0:08:12.770,0:08:17.319
So, what could I do in order to improve this
program or change this program to convince

0:08:17.319,0:08:21.720
myself whether or not I really
need this rotation of a circle?

0:08:21.720,0:08:23.120
Well, let's look at it.

0:08:23.120,0:08:26.560
And let's look at it in this
expression style, and approach.

0:08:26.560,0:08:33.120
So, let's actually build an expression and
think about whether I can manipulate this

0:08:33.120,0:08:34.910
expression just as in mathematics
I manipulate formulas.

0:08:34.910,0:08:41.590
If I see something like x + y × (p + c), or
whatever and it looks too complicated, then I also

0:08:41.590,0:08:47.750
start applying algebraic laws to change this
formula, simplifying maybe into something where

0:08:47.750,0:08:50.970
I see a better solution, or
that's a simpler solution.

0:08:50.970,0:08:57.170
Okay, so let's try to apply the same habit
here and try to simplify this program just

0:08:57.170,0:09:00.550
as you would simplify an arithmetic expression.

0:09:00.550,0:09:06.520
Okay, and well, in order to do this, maybe
I should first really make one expression

0:09:06.520,0:09:07.520
out of this.

0:09:07.520,0:09:11.700
And I can do this because I can simply inline
these definitions, as you know, and as we

0:09:11.700,0:09:16.300
discussed last week, these definitions here
are not somehow assignment statements, they

0:09:16.300,0:09:18.860
are just giving names to subexpressions.

0:09:18.860,0:09:26.440
Yes, so of course, I can also inline or
put those parts of expressions that I want

0:09:26.440,0:09:29.000
to think about into one closed line.

0:09:29.000,0:09:36.060
So, exactly since this rotated
circle was what I was thinking

0:09:36.060,0:09:39.700
about, and thinking about whether
I could somehow change it.

0:09:39.700,0:09:45.590
Let me actually take this expression and write
it down in full without this indirection by

0:09:45.590,0:09:48.010
naming the subexpression.

0:09:48.010,0:09:49.010
What do I get then?

0:09:49.010,0:09:55.190
I get this complex or a bit
more complex expression.

0:09:55.190,0:10:00.980
So, copying what I have above.

0:10:00.980,0:10:05.880
Let me actually write this as a variable name,
like in Haskell instead of this mathematical

0:10:05.880,0:10:06.880
pi.

0:10:06.880,0:10:11.730
And then instead of the green form here, I can
really simply put in a definition of a green

0:10:11.730,0:10:12.730
form.

0:10:12.730,0:10:15.940
That's exactly what it means
to have named a subexpression.

0:10:15.940,0:10:23.340
So, what I can then think about
is “colored”.

0:10:23.340,0:10:33.200

0:10:33.200,0:10:37.690
And then I need an appropriate
number of brackets.

0:10:37.690,0:10:44.390
Okay, so this is the
expression I'm thinking about.

0:10:44.390,0:10:46.140
And it's the same as this, right?

0:10:46.140,0:10:51.420
I've simply written it all in one
long line, one long expression.

0:10:51.420,0:10:57.610
Okay, so what do I see here now, I
really have my rotation and my circle in

0:10:57.610,0:11:02.400
the same context where I could think about
where is it needed to really rotate that circle?

0:11:02.400,0:11:03.820
And how could I do this?

0:11:03.820,0:11:04.920
Or how could I think about this?

0:11:04.920,0:11:08.290
What I could think about is that there are some
laws maybe, just as in mathematics, we have

0:11:08.290,0:11:10.170
laws, like x + y = y + x.

0:11:10.170,0:11:17.440
If I want to apply the same approach here
to a graphical expression, let me actually

0:11:17.440,0:11:18.440
think about laws.

0:11:18.440,0:11:20.700
Yes, this is my expression I'm interested in.

0:11:20.700,0:11:22.870
Let me think about not only
what to do

0:11:22.870,0:11:27.331
with this expression, but a general idea
of what's going on, let me think about

0:11:27.331,0:11:29.870
a law.

0:11:29.870,0:11:35.210
Just like a mathematical law, like commutativity,
or anything like that, but on these operations.

0:11:35.210,0:11:44.730
So, one thing I could imagine that is true,
is something like that: "rotated", with some

0:11:44.730,0:11:51.580
argument (I don't need to have the pi over
two or something, I can take an arbitrary

0:11:51.580,0:11:57.330
angle), and a solid circle, and probably
the same holds for a normal circle.

0:11:57.330,0:12:00.540
But since I have a solid circle
above it, let me do this.

0:12:00.540,0:12:04.240
And again, the radius of the circle is not
important, whether it's two or three, or whatever.

0:12:04.240,0:12:07.410
So, let me take just a variable for this as
well.

0:12:07.410,0:12:16.180
Then I could say, well, probably there should
be a law which says, if I rotate a circle,

0:12:16.180,0:12:17.180
that's really the same thing.

0:12:17.180,0:12:22.880
And let me use the symbol for semantically
equivalent (the equal sign from mathematics,

0:12:22.880,0:12:31.850
basically). Well, the rotated circle is
really just that circle of the same radius.

0:12:31.850,0:12:37.240
And the angle by which to rotate is irrelevant,
because I don't even need to rotate the circle.

0:12:37.240,0:12:39.340
Okay, but that's probably my
intuition why I was thinking:

0:12:39.340,0:12:41.810
a rotated circle doesn't really
make much sense.

0:12:41.810,0:12:43.040
It's just a circle.

0:12:43.040,0:12:52.940
So, this law somehow exactly incorporates
this inspiration or this thinking I had.

0:12:52.940,0:12:53.940
Okay.

0:12:53.940,0:12:58.000
However, that doesn't really apply here, right,
you don't have something of the form rotated

0:12:58.000,0:12:59.460
of an angle of a circle.

0:12:59.460,0:13:01.290
That's not what we see here.

0:13:01.290,0:13:05.360
And just as in mathematics, you
cannot apply the distributive law.

0:13:05.360,0:13:09.870
if you don't have the correct shape. In
our mathematical expression, we need more.

0:13:09.870,0:13:11.980
So actually, we don't need just one law.

0:13:11.980,0:13:15.410
But maybe more than one, maybe additional
laws.

0:13:15.410,0:13:17.540
Let's think about more laws.

0:13:17.540,0:13:23.420
If I, for example, want to be able to apply
this, then probably I should somehow get this

0:13:23.420,0:13:25.690
“rotated” further inside.

0:13:25.690,0:13:31.000
Just as in mathematics, you will sometimes just
have to do some steps in order to ultimately

0:13:31.000,0:13:35.730
really be able to apply, for
example, the distributive law.

0:13:35.730,0:13:42.070
So, some other useful law would be… and then
we can think about whether it's actually true.

0:13:42.070,0:13:47.450
But something that would be useful here, in
order to apply the first law would be if you

0:13:47.450,0:13:54.390
had something like: if you rotate something
which is colored, so if we have a variable

0:13:54.390,0:13:56.700
for the color c,

0:13:56.700,0:14:01.920
and for some picture p, which could be anything
(anything that is a picture), then well, what

0:14:01.920,0:14:02.920
would we have?

0:14:02.920,0:14:07.690
You could say, well, to rotate a colored picture
is the same as coloring a rotated picture,

0:14:07.690,0:14:10.170
that would certainly be useful
in the above expression.

0:14:10.170,0:14:19.510
So, let's say or let's make a hypothesis: This
is the same as basically switching these two

0:14:19.510,0:14:22.320
calls.

0:14:22.320,0:14:31.640
So, we're taking a picture, coloring it and
then rotating it by some angle. Is it the

0:14:31.640,0:14:36.430
same as taking the picture, first
rotating it, and then coloring it?

0:14:36.430,0:14:41.160
And well, whether this is true or not depends on
the library, of course, on the implementation,

0:14:41.160,0:14:45.160
but if the implementation somehow is really
the library that we use, the CodeWorld library

0:14:45.160,0:14:51.790
is really implementing meaningful versions of
rotation, coloring, and picture primitives,

0:14:51.790,0:14:54.230
then that's probably a law
that you also expect to hold.

0:14:54.230,0:15:02.790
And of course, for other ones, we could also
have further laws, like for example, it says

0:15:02.790,0:15:13.920
similar things about what it means
to move a colored picture, etc.

0:15:13.920,0:15:18.760
So basically, for all or many of the combinations
of our picture primitives, we could think

0:15:18.760,0:15:19.760
about laws.

0:15:19.760,0:15:20.760
Okay.

0:15:20.760,0:15:27.690
Now let's assume that these are valid, (these
laws), then with these two together, we could

0:15:27.690,0:15:34.520
actually switch the order of these two calls,
and then eliminate the “rotated” because it

0:15:34.520,0:15:36.500
sees a solid circle.

0:15:36.500,0:15:45.550
And this means, at least if I put this r here,
that actually we can eliminate it completely.

0:15:45.550,0:15:54.420
Okay, so let me actually fix
this and put the radius here.

0:15:54.420,0:15:59.510
Okay, and what I've been doing here, or what I
am suggesting here to improve the above program

0:15:59.510,0:16:04.660
is really the same as we do in
mathematics when we simplify expressions.

0:16:04.660,0:16:08.330
It's simply applied to a different domain,
namely, in this case, the domain of picture

0:16:08.330,0:16:09.330
expressions.

0:16:09.330,0:16:23.640
So, it's really the same as in mathematics,
arithmetic, to have laws, like a + b is b + a

0:16:23.640,0:16:34.980
or a × (b + c) is a × b + a × c.

0:16:34.980,0:16:39.720
Okay, that's the same kind of
reasoning or thinking I do here.

0:16:39.720,0:16:43.330
Now, is this specific to Haskell
programming or functional programming?

0:16:43.330,0:16:45.920
Or could I do this in other languages as
well?

0:16:45.920,0:16:49.360
Well, to some extent, you could say,
maybe I can do the same thing in Java.

0:16:49.360,0:16:56.440
If in Java, or C, or Python, I do write my
library in a style that I have these primitives,

0:16:56.440,0:17:02.990
maybe I could also apply such refactorings to
my programs, which to some extent, is true.

0:17:02.990,0:17:11.110
But of course, since Java, or C, or Python
programs are not only or to a large extent,

0:17:11.110,0:17:18.240
even expressed in terms of nested function
calls, there is not that much opportunity.

0:17:18.240,0:17:20.640
It's not like mathematics, where
everything is an expression.

0:17:20.640,0:17:26.120
So certainly, functional programming, or Haskell
programming very much encourages or forces

0:17:26.120,0:17:29.110
this style of programming; we are
building expressions like this.

0:17:29.110,0:17:33.440
And as soon as we are in a language where that
is not the case, then it might be possible to

0:17:33.440,0:17:38.681
do some small modifications, but not in the
same spirit that you will really think about

0:17:38.681,0:17:41.070
programs in terms of such transformations.

0:17:41.070,0:17:42.330
Okay.

0:17:42.330,0:17:47.800
And then you could also say maybe I don't
need these laws, right? I see this expression,

0:17:47.800,0:17:48.880
I see what's going on.

0:17:48.880,0:17:49.910
So, I simply improve it.

0:17:49.910,0:17:53.100
Well, maybe if it was a small
example like that, it's true.

0:17:53.100,0:17:56.640
But such common-sense reasoning is
not something that works at scale.

0:17:56.640,0:18:00.330
There's a reason that mathematicians do not
just look at equations and say, well, I see

0:18:00.330,0:18:05.700
the solution; they really apply laws like
this.

0:18:05.700,0:18:10.170
And there's a reason for doing it that way,
because you can prove that something is true.

0:18:10.170,0:18:16.860
And you can handle larger examples, then,
or larger problems, than if you would simply

0:18:16.860,0:18:19.420
work by common sense and say
I see what the solution is.

0:18:19.420,0:18:20.890
And the same applies to programs.

0:18:20.890,0:18:25.520
In a small program, maybe it's not
necessary to really work with these laws.

0:18:25.520,0:18:31.350
But as soon as you work in the context of a
larger program, it's really helpful to know

0:18:31.350,0:18:37.750
why you do some, for example, simplification
steps, and then having laws like this is really

0:18:37.750,0:18:38.750
the way to go.

0:18:38.750,0:18:41.770
They also actually serve other purposes.

0:18:41.770,0:18:46.300
They could be used as documentation
for the API, for the library.

0:18:46.300,0:18:49.510
They could, for example, be used for
testing the library / the implementation.

0:18:49.510,0:18:55.300
So, once we have our library, and we know
what the functions are, we could think about

0:18:55.300,0:18:58.290
useful laws, that should be true.

0:18:58.290,0:19:02.080
And then we could make tests of the library to
see whether these laws are really satisfied.

0:19:02.080,0:19:07.330
And if they don't, then probably there's a
problem not in our thinking about the property

0:19:07.330,0:19:12.360
or operation, but in the
implementation of the library.

0:19:12.360,0:19:13.760
Okay.

0:19:13.760,0:19:18.540
So, I want to make another excursion,
since I just mentioned Java.

0:19:18.540,0:19:26.300
So, could you imagine that the same kind of
approach would work in Java or other languages

0:19:26.300,0:19:27.300
that you know?

0:19:27.300,0:19:34.090
Let's think about it: could we do
something like this in Java as well?

0:19:34.090,0:19:35.590
Well, to some extent, probably, yes.

0:19:35.590,0:19:41.230
So, let's think about this in
object-oriented style, for example.

0:19:41.230,0:19:47.060
So certainly, you could imagine that if you
introduce methods on a picture class, for

0:19:47.060,0:19:50.420
coloring, for rotation, for moving, etc.

0:19:50.420,0:19:56.020
you could probably write things like:
if I have a picture, and I color it

0:19:56.020,0:20:01.780
(let's say we have a method for this
and it takes a picture argument because

0:20:01.780,0:20:05.540
it operates on an object of the class Picture),

0:20:05.540,0:20:17.060
and then afterwards, I rotate this by some
angle, then you could probably expect and

0:20:17.060,0:20:26.480
establish for some library, that this is the same
as first rotating the picture and then coloring

0:20:26.480,0:20:27.480
it.

0:20:27.480,0:20:30.299
Yes, so, this is in this spirit.

0:20:30.299,0:20:37.750
Definitely very similar to what I gave above
as the second law. And for the other laws, you

0:20:37.750,0:20:45.550
could probably write down in many cases, write
down something also in this object-oriented

0:20:45.550,0:20:46.560
notation.

0:20:46.560,0:20:54.640
Okay, well, that's good luck here in some
sense, because the syntax works nicely in

0:20:54.640,0:21:00.590
this way for methods that operate
on exactly one picture, right?

0:21:00.590,0:21:05.100
Coloring takes one picture,
rotation works on one picture, etc.

0:21:05.100,0:21:11.470
So, for example, already, if you want to do
something for the combination of pictures,

0:21:11.470,0:21:15.120
it becomes more complicated.

0:21:15.120,0:21:23.070
Yes, so this really doesn't work so nicely for,

0:21:23.070,0:21:26.160
for example, binary methods.

0:21:26.160,0:21:30.160
So, methods that take two picture arguments.

0:21:30.160,0:21:38.660
So, exactly like the combination function,
whereas in a functional expression style setting,

0:21:38.660,0:21:42.810
it doesn't really matter how many arguments functions
take. As long as everything is an expression…

0:21:42.810,0:21:46.600
If you have a function that
takes three arguments, then

0:21:46.600,0:21:48.760
you can still write down
laws about it.

0:21:48.760,0:21:50.310
So, there's no problem with this.

0:21:50.310,0:21:59.100
And also, actually, just by the way,
object-orientation works, usually, but there are

0:21:59.100,0:22:03.410
of course problems

0:22:03.410,0:22:05.790
with stuff like the following.

0:22:05.790,0:22:16.450
So, let's say we have a picture, and we
want to have a colored version of it.

0:22:16.450,0:22:25.000
But we also want to draw the same basic picture
in a different place, but without a new color.

0:22:25.000,0:22:29.650
Say we have a triangle, and we want
to move it somewhere, but we also want

0:22:29.650,0:22:31.920
to color it red, but these
as two independent things.

0:22:31.920,0:22:38.380
We want to have a colored triangle somewhere
and an uncolored triangle somewhere else.

0:22:38.380,0:22:44.710
And then that's not really what this expression
would give us right because in this interpretation,

0:22:44.710,0:22:49.520
where a method like this operates on the object,
then this would mean if evaluated from left

0:22:49.520,0:22:54.530
to right, then this first call will take
our triangle and color it red, for example.

0:22:54.530,0:23:02.250
And then the second call would move
the, now red, triangle somewhere

0:23:02.250,0:23:03.250
else, right?

0:23:03.250,0:23:07.880
Because this will have had an
effect on the p, of writing

0:23:07.880,0:23:12.140
some instance variables or setting
the color or something like that.

0:23:12.140,0:23:19.350
Okay, well, this is not the same as in mathematics,
where something like this cannot happen.

0:23:19.350,0:23:23.500
Just because we have some call of “colored” on p in
some part of the expression, it doesn't mean that

0:23:23.500,0:23:28.760
other occurrences of the same expression
will also magically change their color.

0:23:28.760,0:23:34.410
That's because of side effects,
imperative programming, etc.

0:23:34.410,0:23:41.740
Okay, and well, finally, coming back
to another aspect from last week.

0:23:41.740,0:23:48.620
Of course, already the idea that we can do such
transformations in context is important, right?

0:23:48.620,0:23:58.020
I mean, even if I have proved something about
rotation and color, etc., then it's important

0:23:58.020,0:23:59.380
to know that it holds everywhere.

0:23:59.380,0:24:04.220
So, it doesn't matter whether I do this in a
“translated” call or somewhere else in the program.

0:24:04.220,0:24:09.220
If I do a calculation like this, then
I want this to be true everywhere.

0:24:09.220,0:24:15.010
Just as in mathematics, if I write in mathematics,
something like… let me take another law

0:24:15.010,0:24:20.550
or other simplification in some sense, let's say
we want to replace division by multiplication.

0:24:20.550,0:24:24.040
Yes, that is a mathematics example.

0:24:24.040,0:24:37.370
Let's say we have something like x divided
by y. And for whatever reason, I want to

0:24:37.370,0:24:41.830
write this with y to the
power of minus one (y^(-1)).

0:24:41.830,0:24:49.320
So, the reciprocal of this, and I want to
multiply it by x. Then that is certainly an

0:24:49.320,0:24:53.400
appropriate law in mathematics and is
also something that holds in C. If you

0:24:53.400,0:24:58.530
think of this as floating-point division
and multiplication etc., then up to rounding

0:24:58.530,0:25:00.320
inaccuracies,

0:25:00.320,0:25:05.490
this is also something that should be
thought of as a mathematical law in C.

0:25:05.490,0:25:11.220
But unfortunately, in a non-mathematical language
like C, that doesn't mean that we can use

0:25:11.220,0:25:13.770
this wherever we like in a program.

0:25:13.770,0:25:15.220
And why is that not the case?

0:25:15.220,0:25:19.440
Well, it's again, this occurrence from last
week that I showed with this minor thing.

0:25:19.440,0:25:31.450
So, let's say in Java,
or C, or Python, or

0:25:31.450,0:25:33.210
whatever,

0:25:33.210,0:25:37.590
you have these two expressions x and y, and they
are actually something like a call to the input

0:25:37.590,0:25:44.610
function (which isn't a function in the mathematical
sense, but looks like a function syntactically,

0:25:44.610,0:25:52.110
in these languages), then you know that
this is not something that is true, right?

0:25:52.110,0:25:56.300
Because it does make a difference whether
you first read the x and then the y or first

0:25:56.300,0:26:01.620
read the y and then the x. Providing
two values at the prompt, 2 and 7,

0:26:01.620,0:26:06.059
will lead to completely different results
here on the left- and on the right-hand side,

0:26:06.059,0:26:13.920
simply because these so-called expressions of
functions are not, in a mathematical sense,

0:26:13.920,0:26:15.720
expressions or functions.

0:26:15.720,0:26:21.740
So, laws like this, even though they make
sense in arithmetic, cannot be applied in an

0:26:21.740,0:26:23.240
effectful setting with side effects.

0:26:23.240,0:26:25.740
Okay, and again, of course,
this is a small example.

0:26:25.740,0:26:30.180
But think about the same kind of
situation for larger programs with

0:26:30.180,0:26:34.900
not just multiplication, division, but really
domain-specific operations like coloring,

0:26:34.900,0:26:39.010
etc., for the picture domain. And then
immediately you get power by transforming

0:26:39.010,0:26:43.510
expressions, but you can't do that in a
language that doesn't follow expression

0:26:43.510,0:26:44.010
style.
