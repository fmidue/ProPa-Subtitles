0:00:01.530,0:00:09.650
Lassen Sie mich die Vorlesungsvideos für
diese Woche wieder mit einigen Bemerkungen

0:00:09.650,0:00:16.880
auf dem Whiteboard beginnen. Wieder mit
Auffrischen einiger Aspekte des Ausdrucksstils, der

0:00:16.880,0:00:23.170
letzte Woche besprochen wurde. Aber auch schon
ein paar Aspekte oder Beobachtungen, die ich aus

0:00:23.170,0:00:24.650
den ersten Übungsabgaben (eines
früheren Jahres) gewonnen habe.

0:00:24.650,0:00:29.650
Also, normalerweise versuche ich, das zu tun, einen Blick
zu werfen auf die Übungseinsendungen vor der Vorlesung,

0:00:29.650,0:00:35.250
und dann die Dinge zu kommentieren, die ich beobachtet habe
und die mir wichtig oder interessant erscheinen für die

0:00:35.250,0:00:36.250
Vorlesung.

0:00:36.250,0:00:47.239
Ich weiß nicht, ob das dieses Jahr oft möglich
sein wird, weil [... veraltete Kommentare ...]

0:00:47.239,0:00:52.710
Also, in diesem Fall einen Tag vor der Vorlesung,
aber in anderen Fällen werde ich vielleicht sogar

0:00:52.710,0:00:55.129
Videos zwei Tage oder früher
vor der Vorlesung aufnehmen.

0:00:55.129,0:01:00.539
Und dann will ich natürlich nicht
zu viel von der Übung verderben.

0:01:00.539,0:01:06.680
Okay, wie auch immer, also ein paar kleine Dinge kann
ich jetzt besprechen, weil ich zumindest einen Blick

0:01:06.680,0:01:10.840
auf die ersten Abgaben geworfen habe,
auch wenn noch nicht alle im System sind.

0:01:10.840,0:01:15.000
Lassen Sie mich erst ein
paar kleine Dinge besprechen.

0:01:15.000,0:01:17.340
Eine Sache ist Syntax.

0:01:17.340,0:01:23.100
Das ist etwas, worauf ich bereits in der Vorlesung
und den Beispielen von letzter Woche eingegangen bin.

0:01:23.100,0:01:28.539
Und das Wichtigste, auch das, worauf Autotool
in den ersten Abgaben hingewiesen hat,

0:01:28.539,0:01:37.109
also Dinge wie studentische
Abgaben mit Code

0:01:37.109,0:01:38.109
wie solchem hier.

0:01:38.109,0:01:43.039
Also, ein Aufruf der Funktion "translated" mit
zwei Argumenten für die x- und y-Richtung und

0:01:43.039,0:01:47.860
dann ein Rechteck oder was auch immer.

0:01:47.860,0:01:53.200
Und wenn Sie genau hinschauen, dann hätte
Autotool in einer Einreichung wie dieser gesagt,

0:01:53.200,0:01:58.479
dass diese Klammern unnötig sind. Und würde
sogar vorschlagen, dass Sie dort nur fünf

0:01:58.479,0:01:59.499
und drei schreiben sollten.

0:01:59.499,0:02:02.310
Wir bestraften das da noch nicht.

0:02:02.310,0:02:08.679
Die Vorschläge, die das Autotool macht,
sind also wirklich vorerst nur Vorschläge.

0:02:08.679,0:02:14.010
Aber ich ermutige Sie trotzdem, dieses Feedback zu
lesen und auch darauf zu reagieren, denn früher

0:02:14.010,0:02:17.550
oder später werden wir mehr von
diesen Vorschlägen durchsetzen.

0:02:17.550,0:02:24.159
Sie werden also tatsächlich zur Pflicht werden
und dann muss man seinen Code ändern, weil

0:02:24.159,0:02:26.550
er sonst nicht akzeptiert wird.

0:02:26.550,0:02:28.870
Und das wollen Sie nicht,
im Sinne der Korrektheit.

0:02:28.870,0:02:33.620
Es ist also eine gute Angewohnheit, am Anfang
wirklich das Feedback zu lesen, das Autotool

0:02:33.620,0:02:34.620
Ihnen gibt.

0:02:34.620,0:02:41.470
Damit Sie sowohl Ihren Code verbessern können als auch
tatsächlich später nicht frustriert sind, weil Autotool

0:02:41.470,0:02:47.210
Ihre Eingaben nicht einmal akzeptiert,
weil Sie bestimmte Stil- und andere

0:02:47.210,0:02:50.250
Richtlinien verletzen, die wir durchsetzen.

0:02:50.250,0:02:51.250
Ja, gut.

0:02:51.250,0:02:58.180
Und ich habe auch gesehen, dass in einigen
Fällen in der ersten Woche das Autotool-Feedback

0:02:58.180,0:03:03.030
etwas Falsches enthielt. Insbesondere die
ersten paar Einsendungen von Studierenden

0:03:03.030,0:03:08.250
hatten in ihrem Autotool-Feedback einige
Kommentare, die nicht wirklich sinnvoll waren.

0:03:08.250,0:03:12.870
Sinn ergeben; etwas über einen Teil des Codes,
der nur in Ihrer Einreichung auftaucht. Das war

0:03:12.870,0:03:18.379
ein kleiner Fehler in Autotool, dass es etwas
ausgegeben hat, was es nicht hätte ausgeben sollen

0:03:18.379,0:03:19.379
an diesen Stellen.

0:03:19.379,0:03:21.959
Das Problem wurde also behoben
und sollte nicht wieder auftreten.

0:03:21.959,0:03:28.370
Also, die allgemeine Bemerkung ist, dass man
das Feedback lesen und darauf reagieren sollte.

0:03:28.370,0:03:32.030
Aber ein paar Studierende werden in der ersten Woche ein
Feedback bekommen haben, das sie nicht umsetzen konnten,

0:03:32.030,0:03:34.680
weil es nicht
viel Sinn ergeben hat.

0:03:34.680,0:03:38.180
Aber das sollte eine Ausnahme sein und
sollte nicht wieder vorkommen, hoffen wir.

0:03:38.180,0:03:39.180
Okay.

0:03:39.180,0:03:44.670
Das Vorige war also eine allgemeine Bemerkung zur
Syntax, die auf eine ganze Reihe von Abgaben zutraf.

0:03:44.670,0:03:51.030
Und dann möchte ich eine eher semantische und
interessantere Bemerkung machen, in der es um eine

0:03:51.030,0:03:55.400
bestimmte Einreichung geht, nicht weil sie schlecht war
oder so, sondern eigentlich ist es eine interessante

0:03:55.400,0:03:56.400
Einreichung.

0:03:56.400,0:04:01.519
Und ich werde sie nicht komplett wiedergeben, aber
ich möchte einige Teile davon zeigen und das verwenden

0:04:01.519,0:04:06.819
für eine Diskussion des Ausdrucksstils,
die irgendwie ganz gut passt.

0:04:06.819,0:04:13.420
Okay, es gab also die Aufgabe, diesen Baum zu zeichnen,
und ohne hier eine vollständige Lösung zu geben,

0:04:13.420,0:04:15.719
denn dafür sind die Übungen da,

0:04:15.719,0:04:23.150
möchte ich einen Teil oder eine Skizze von einer Lösung
zeigen, die ich in einer der ersten Einsendungen gesehen habe.

0:04:23.150,0:04:26.759
Die sah in etwa so aus (ich lasse
all die Typ-Anmerkungen weg).

0:04:26.759,0:04:34.110
Also, es gab so etwas wie das hier, der scene-Wert,
der aus ein paar Komponenten zusammengesetzt war,

0:04:34.110,0:04:38.830
und eine davon waren die Blätter, richtig, denn
dieser Baum sollte ja auch ein paar Blätter

0:04:38.830,0:04:39.830
haben.

0:04:39.830,0:04:42.960
Also, es gab eine Definition, dann die
Blätter. Wie wurden die Blätter definiert?

0:04:42.960,0:04:46.110
Na ja, es gab eine eigene Definition.

0:04:46.110,0:04:53.090
Und die bestand wiederum aus einigen Unterausdrücken,
und einer davon war so etwas wie ein rotierter

0:04:53.090,0:04:54.090
Kreis.

0:04:54.090,0:04:59.460
Also, der Name einiger anderer Ausdrücke,
eines anderen Bildes, das irgendwo in

0:04:59.460,0:05:10.340
der Mitte eines größeren Ausdrucks auftritt. Und dann
wurde dieser rotierte Kreis definiert als etwas wie

0:05:10.340,0:05:17.160
die ... wir riefen diese Funktion zum Verschieben
eines Bildes mit einigen Argumenten auf, etwa so

0:05:17.160,0:05:18.440
wie das.

0:05:18.440,0:05:19.440
Und was war das?

0:05:19.440,0:05:20.810
Was wurde bewegt?

0:05:20.810,0:05:28.810
Nun, ein Aufruf der Funktion "rotated" mit
einigen Argumenten, etwas wie pi durch vier.

0:05:28.810,0:05:29.810
Und wovon?

0:05:29.810,0:05:34.910
Nun, von einer grünen Form, die Teil
der Blätter sein sollte, anscheinend.

0:05:34.910,0:05:36.590
Und wie wurde diese grüne Form definiert?

0:05:36.590,0:05:39.030
Nun, wieder in einer separaten Definition.

0:05:39.030,0:05:46.770
Und das war natürlich ein "colored"-Aufruf,
denn es soll ja eine grüne Form sein.

0:05:46.770,0:05:47.889
Und was ist "colored"?

0:05:47.889,0:05:56.560
Nun, in diesem Fall war es ein fester
Kreis mit einem gewissen Radius, 2 oder so.

0:05:56.560,0:05:57.560
Okay.

0:05:57.560,0:06:00.860
So, und dann gab es natürlich noch eine
Vervollständigung von dieser ganzen Sache.

0:06:00.860,0:06:04.500
Also, das war ein funktionierendes
Programm. Alles ist in Ordnung.

0:06:04.500,0:06:06.979
Okay, ein paar Beobachtungen dazu.

0:06:06.979,0:06:11.510
Nun, eine Sache, die ich anmerken würde,
und das wirklich für eine Menge der Abgaben,

0:06:11.510,0:06:18.000
ist die Balance zwischen Top-Level-Definitionen
und lokalen Definitionen, okay?

0:06:18.000,0:06:22.280
Es gab eine lange Datei, es gibt viel
mehr Formen, die definiert wurden

0:06:22.280,0:06:23.319
auf die gleiche Art und Weise.

0:06:23.319,0:06:27.710
Und alle bekamen einen Top-Level-Namen und
erschienen dann in dieser langen Liste von Dingen.

0:06:27.710,0:06:28.759
Das ist schon in Ordnung.

0:06:28.759,0:06:33.490
Aber eigentlich würde ich argumentieren, dass wahrscheinlich
die meisten dieser Definitionen auch einfach als

0:06:33.490,0:06:34.840
eine lokale Definition verwendet werden.

0:06:34.840,0:06:39.260
Wenn Sie also in der Übung auf eine
Situation wie diese treffen, wo Sie

0:06:39.260,0:06:44.550
viele Definitionen schreiben, sollten Sie vielleicht darüber
nachdenken, ob man nicht statt diese grüne Form auf oberster

0:06:44.550,0:06:47.430
Ebene zu haben, sie zum Beispiel hier
als eine lokale Definition schreibt.

0:06:47.430,0:06:50.610
Ja, das haben wir in den Beispielen
der letzten Woche gesehen,

0:06:50.610,0:06:57.949
dass man auch hier eine Definition schreiben
kann. Dann ist es irgendwie logischer gruppiert.

0:06:57.949,0:07:04.919
Okay, das ist eine allgemeine Bemerkung, die auf
viele der Abgaben zutrifft, die ich gesehen habe.

0:07:04.919,0:07:07.600
Nochmal: es bedeutet nicht, dass
das, was Sie hier sehen, falsch ist.

0:07:07.600,0:07:14.220
Es ist nur eine allgemeine Bemerkung, dass man mehr
Gebrauch von lokalen Definitionen machen könnte.

0:07:14.220,0:07:21.000
Aber es gibt noch eine andere Sache, die mich
überrascht hat, als ich das hier gesehen habe.

0:07:21.000,0:07:24.250
Und im Grunde ist es hauptsächlich
dieser Name: rotatedCircle.

0:07:24.250,0:07:29.139
Ich habe mich gefragt, warum sollte ich einen Kreis
rotieren? Ein Kreis ist ein rundes Ding, das nicht wirklich

0:07:29.139,0:07:30.240
Ausrichtungen hat.

0:07:30.240,0:07:32.190
Warum sollte ich einen Kreis rotieren?

0:07:32.190,0:07:36.930
Und in der Tat, wenn Sie sich das nächste Beispiel ansehen,
werden Sie wahrscheinlich erkennen, und Sie könnten es sogar

0:07:36.930,0:07:41.820
ausprobieren, wenn Sie die Lösung vor sich
haben, dass man den rotated-Aufruf wahrscheinlich

0:07:41.820,0:07:42.820
nicht braucht.

0:07:42.820,0:07:45.811
Ja, man könnte darüber nachdenken und sagen, na
ja, ich brauche den Kreis nicht zu rotieren, weil

0:07:45.811,0:07:49.479
er seine Form nur durch Rotation nicht ändert.

0:07:49.479,0:07:51.539
Das ist eine Möglichkeit, es zu betrachten.

0:07:51.539,0:07:55.140
Aber dann ist da natürlich auch die Frage,
ob man das generell argumentieren kann?

0:07:55.140,0:07:56.319
Oder ob man das beweisen kann?

0:07:56.319,0:08:00.780
Oder ist das etwas, was man im Rahmen des
Refactorings macht, wenn man solchen Code sieht.

0:08:00.780,0:08:03.229
Zum Beispiel: (es ist nicht mein Code,
es ist der Code eines Studierenden)

0:08:03.229,0:08:09.139
Also, ich bin mir vielleicht nicht sicher, allein anhand
des Namens (vielleicht ist das nicht genug Hinweis,

0:08:09.139,0:08:12.770
dass ich es wirklich ändern sollte) - vielleicht
ist dieser Name einfach nicht angemessen.

0:08:12.770,0:08:17.319
Also, was könnte ich tun, um dieses Programm
zu verbessern oder das Programm zu ändern?

0:08:17.319,0:08:21.720
Ob ich diese Rotation eines Kreises
wirklich brauche oder nicht brauche?

0:08:21.720,0:08:23.120
Nun, schauen wir es uns an.

0:08:23.120,0:08:26.560
Und schauen wir es uns in diesem
Ausdrucksstil und -ansatz an.

0:08:26.560,0:08:33.120
Also, lassen Sie einen Ausdruck erstellen und
darüber nachdenken, ob man den Ausdruck manipulieren

0:08:33.120,0:08:34.910
kann, genau wie in der Mathematik.
Man manipuliert Formeln.

0:08:34.910,0:08:41.590
Wenn ich etwas sehe wie x + y × (p + c), oder was auch
immer, und es sieht zu kompliziert aus, dann kann ich auch

0:08:41.590,0:08:47.750
anfangen, algebraische Gesetze anzuwenden, um diese
Formel, vielleicht zu etwas zu vereinfachen, wo

0:08:47.750,0:08:50.970
ich eine bessere Lösung sehen kann, oder
die gar direkt eine einfachere Lösung ist.

0:08:50.970,0:08:57.170
Okay, also lassen Sie uns versuchen, die gleiche Gewohnheit hier
anzuwenden und zu versuchen, dieses Programm zu vereinfachen,

0:08:57.170,0:09:00.550
wie man einen arithmetischen
Ausdruck vereinfachen würde.

0:09:00.550,0:09:06.520
Okay, und um das zu tun, sollte ich
vielleicht zuerst wirklich einen Ausdruck

0:09:06.520,0:09:07.520
aus dem hier machen.

0:09:07.520,0:09:11.700
Und das kann ich tun, weil ich diese Definitionen
einfach "inline", wie Sie wissen. Und wie wir

0:09:11.700,0:09:16.300
letzte Woche besprochen haben, sind diese Definitionen
hier nicht irgendwie Zuweisungsbefehle. Sie

0:09:16.300,0:09:18.860
sind nur Namen für Unterausdrücke.

0:09:18.860,0:09:26.440
Ja, also kann ich natürlich auch
die Teile von Ausdrücken einfügen,

0:09:26.440,0:09:29.000
über die ich nachdenken möchte, und
diese in eine Gesamtzeile packen.

0:09:29.000,0:09:36.060
Also, genau da dieser rotierte
Kreis das war, worüber ich

0:09:36.060,0:09:39.700
nachdachte, ob ich ihn irgendwie ändern könnte.

0:09:39.700,0:09:45.590
Lassen Sie mich diesen Ausdruck nehmen und ich
schreibe ihn komplett auf, ohne diese Indirektion,

0:09:45.590,0:09:48.010
indem ich den Unterausdruck benenne.

0:09:48.010,0:09:49.010
Was erhalte ich dann?

0:09:49.010,0:09:55.190
Ich erhalte diesen etwas komplexeren Ausdruck.

0:09:55.190,0:10:00.980
Also, ich kopiere, was ich oben habe.

0:10:00.980,0:10:05.880
Lassen Sie mich das als Variablennamen schreiben
wie in Haskell, anstatt dieses mathematische

0:10:05.880,0:10:06.880
Pi.

0:10:06.880,0:10:11.730
Und dann kann ich anstelle von "greenForm" hier
wirklich einfach eine Definition einer grünen Form

0:10:11.730,0:10:12.730
einfügen.

0:10:12.730,0:10:15.940
Das ist genau das, was es bedeutet,
einen Unterausdruck zu haben.

0:10:15.940,0:10:23.340
Also, was ich mir dann
vorstellen kann, ist "colored".

0:10:23.340,0:10:33.200

0:10:33.200,0:10:37.690
Und dann brauche ich eine
entsprechende Anzahl von Klammern.

0:10:37.690,0:10:44.390
Okay, das ist also der
Ausdruck, an den ich denke.

0:10:44.390,0:10:46.140
Und es ist dasselbe wie das hier, richtig?

0:10:46.140,0:10:51.420
Ich habe das einfach alles in eine lange
Zeile geschrieben, einen langen Ausdruck.

0:10:51.420,0:10:57.610
Okay, also was sehe ich hier jetzt? Ich habe
wirklich meine Rotation und meinen Kreis in

0:10:57.610,0:11:02.400
demselben Kontext, wo ich darüber nachdenken kann.
Ist es nötig, diesen Kreis wirklich zu rotieren?

0:11:02.400,0:11:03.820
Und wie könnte ich das machen?

0:11:03.820,0:11:04.920
Oder wie könnte ich darüber nachdenken?

0:11:04.920,0:11:08.290
Worüber ich nachdenken könnte, ist, dass es einige
Gesetze gibt, so wie wir in der Mathematik haben.

0:11:08.290,0:11:10.170
Gesetze wie: x + y ist y + x.

0:11:10.170,0:11:17.440
Wenn ich den gleichen Ansatz hier auf einen
grafischen Ausdruck anwenden will, muss ich

0:11:17.440,0:11:18.440
über Gesetze nachdenken.

0:11:18.440,0:11:20.700
Ja, das ist mein Ausdruck, der mich interessiert.

0:11:20.700,0:11:22.870
Lassen Sie mich darüber nachdenken,
nicht nur was zu tun ist

0:11:22.870,0:11:27.331
mit diesem Ausdruck, sondern eine allgemeine
Idee von dem, was vor sich geht. Lassen Sie mich

0:11:27.331,0:11:29.870
über ein Gesetz nachdenken.

0:11:29.870,0:11:35.210
So wie ein mathematisches Gesetz, wie die Kommutativität,
oder so etwas, aber für diese Operationen.

0:11:35.210,0:11:44.730
Also, eine Sache, die ich mir vorstellen könnte, die
wahr ist, ist so etwas wie das: "rotated", mit einem

0:11:44.730,0:11:51.580
Argument (ich muss nicht Pi durch 2
haben oder so, ich kann einen beliebigen

0:11:51.580,0:11:57.330
Winkel nehmen) und einem ausgefüllten Kreis, und
wahrscheinlich gilt dasselbe für einen normalen Kreis.

0:11:57.330,0:12:00.540
Aber da ich einen ausgefüllten Kreis
habe, lassen Sie mich das darüber machen.

0:12:00.540,0:12:04.240
Und noch einmal: Der Radius des Kreises ist nicht
wichtig, ob er 2 oder 3 ist, oder was auch immer.

0:12:04.240,0:12:07.410
Also, lassen Sie mich auch
hierfür eine Variable nehmen.

0:12:07.410,0:12:16.180
Dann könnte ich sagen, naja, wahrscheinlich sollte es ein
Gesetz geben, das sagt: Wenn ich einen Kreis rotiere,

0:12:16.180,0:12:17.180
ändert sich nichts.

0:12:17.180,0:12:22.880
Und lassen Sie mich das Symbol für "semantisch äquivalent"
(grundsätzlich das Gleichheitszeichen aus der Mathematik)

0:12:22.880,0:12:31.850
nehmen. Nun, der rotierte Kreis ist wirklich
nur der Kreis mit dem gleichen Radius.

0:12:31.850,0:12:37.240
Und der Winkel, um den rotiert wird, ist irrelevant,
weil ich den Kreis gar nicht rotieren muss.

0:12:37.240,0:12:39.340
Okay, und das war wahrscheinlich
meine Intuition, warum ich dachte:

0:12:39.340,0:12:41.810
ein rotierter Kreis ergibt
nicht wirklich viel Sinn.

0:12:41.810,0:12:43.040
Es ist einfach nur ein Kreis.

0:12:43.040,0:12:52.940
Also, dieses Gesetz beinhaltet irgendwie
genau diese Intuition, die ich hatte.

0:12:52.940,0:12:53.940
Okay.

0:12:53.940,0:12:58.000
Aber das trifft hier nicht wirklich zu, richtig,
man hat ja nicht etwas in der Form: ein Kreis,

0:12:58.000,0:12:59.460
rotiert um einen Winkel.

0:12:59.460,0:13:01.290
Das ist nicht das, was wir hier sehen.

0:13:01.290,0:13:05.360
Genau wie man in der Mathematik das
Distributivgesetz nicht anwenden kann,

0:13:05.360,0:13:09.870
wenn man nicht die richtige Form hat. In unserem
mathematischen Ausdruck brauchen wir mehr.

0:13:09.870,0:13:11.980
Also brauchen wir eigentlich
nicht nur ein Gesetz,

0:13:11.980,0:13:15.410
sondern vielleicht mehr als eines,
vielleicht zusätzliche Gesetze.

0:13:15.410,0:13:17.540
Lassen Sie uns über weitere Gesetze nachdenken.

0:13:17.540,0:13:23.420
Wenn ich zum Beispiel in der Lage sein will, das
anzuwenden, dann sollte ich wahrscheinlich irgendwie diese

0:13:23.420,0:13:25.690
"rotated" weiter nach innen schieben.

0:13:25.690,0:13:31.000
Genau wie man in der Mathematik manchmal ein
paar Schritte machen muss, um letztendlich

0:13:31.000,0:13:35.730
wirklich etwa das Distributivgesetz
anwenden zu können.

0:13:35.730,0:13:42.070
Also, ein anderes nützliches Gesetz wäre ..., und dann
können wir darüber nachdenken, ob es tatsächlich wahr ist.

0:13:42.070,0:13:47.450
Aber etwas, das hier nützlich wäre, um das
erste Gesetz anzuwenden, wäre, wenn man

0:13:47.450,0:13:54.390
so etwas hat wie: wenn man etwas rotiert, was
farbig ist, also wenn wir eine Variable haben

0:13:54.390,0:13:56.700
für die Farbe c,

0:13:56.700,0:14:01.920
und für ein Bild p, das alles Mögliche sein kann
(irgendetwas, das ein Bild ist), dann, na ja, was

0:14:01.920,0:14:02.920
würden wir haben?

0:14:02.920,0:14:07.690
Man könnte sagen: Nun, ein farbiges Bild zu drehen,
ist dasselbe wie ein gedrehtes Bild zu färben.

0:14:07.690,0:14:10.170
Das wäre in dem obigen
Ausdruck sicherlich nützlich.

0:14:10.170,0:14:19.510
Also, sagen wir mal, beziehungsweise stellen wir eine Hypothese
auf: Das ist im Grunde genommen dasselbe, wie wenn man diese beiden

0:14:19.510,0:14:22.320
Aufrufe hat.

0:14:22.320,0:14:31.640
Also, wir nehmen ein Bild auf, färben es ein und
drehen es dann um einen bestimmten Winkel. Ist es

0:14:31.640,0:14:36.430
dasselbe wie ein Bild zu nehmen, es
zuerst zu drehen und dann einzufärben?

0:14:36.430,0:14:41.160
Und nun, ob das stimmt oder nicht, hängt natürlich
von der Bibliothek, von der Implementierung ab.

0:14:41.160,0:14:45.160
Aber wenn die Implementierung, die
CodeWorld-Bibliothek, die wir benutzen,

0:14:45.160,0:14:51.790
wirklich sinnvolle Versionen von Rotation,
Färbung und anderen Bildprimitiven implementiert,

0:14:51.790,0:14:54.230
dann ist das wahrscheinlich ein Gesetz,
von dem Sie auch erwarten, dass es gilt.

0:14:54.230,0:15:02.790
Und für andere Situationen könnten wir natürlich
auch weitere Gesetze haben, wie zum Beispiel,

0:15:02.790,0:15:13.920
was es bedeutet, ein farbiges
Bild zu bewegen, usw.

0:15:13.920,0:15:18.760
Im Grunde genommen können wir also für viele
der Kombinationen unserer Bildprimitiven

0:15:18.760,0:15:19.760
über Gesetze nachdenken.

0:15:19.760,0:15:20.760
Ja, gut.

0:15:20.760,0:15:27.690
Nehmen wir nun an, dass diese Gesetze gültig
sind, dann könnten wir mit diesen beiden zusammen

0:15:27.690,0:15:34.520
tatsächlich die Reihenfolge dieser beiden Aufrufe
vertauschen und dann das "rotated" eliminieren, weil es

0:15:34.520,0:15:36.500
einen Kreis sieht.

0:15:36.500,0:15:45.550
Und das bedeutet, zumindest wenn ich dieses r hier hinstelle,
dass wir es eigentlich komplett eliminieren können.

0:15:45.550,0:15:54.420
Okay, dann werde ich das jetzt mal
festziehen und den Radius hier hinstellen.

0:15:54.420,0:15:59.510
Okay, und was ich hier gemacht habe, oder was ich
hier vorschlage, um das obige Programm zu verbessern,

0:15:59.510,0:16:04.660
ist eigentlich dasselbe, was wir in der Mathematik
machen, wenn wir Ausdrücke vereinfachen.

0:16:04.660,0:16:08.330
Es wird einfach auf einen anderen Bereich angewendet,
nämlich in diesem Fall auf den Bereich von

0:16:08.330,0:16:09.330
Bild-Ausdrücken.

0:16:09.330,0:16:23.640
Also, es ist wirklich das Gleiche wie in der Mathematik,
der Arithmetik, wo wir Gesetze haben wie "a + b ist b + a"

0:16:23.640,0:16:34.980
oder "a × (b + c)" ist "a × b + a × c".

0:16:34.980,0:16:39.720
Okay, das ist die gleiche Art der Argumentation
oder des Denkens, das ich hier mache.

0:16:39.720,0:16:43.330
Ist das nun spezifisch für die Haskell-Programmierung
oder für die funktionale Programmierung?

0:16:43.330,0:16:45.920
Oder kann ich das auch in
anderen Sprachen machen?

0:16:45.920,0:16:49.360
Nun, bis zu einem gewissen Grad könnte man sagen,
vielleicht kann ich das Gleiche in Java machen.

0:16:49.360,0:16:56.440
Wenn ich in Java oder C oder Python meine Bibliothek so
schreibe, in einem Stil, dass ich diese Primitiven habe,

0:16:56.440,0:17:02.990
vielleicht könnte ich solche Refactorings auch da auf meine
Programme anwenden. Was bis zu einem gewissen Grad auch stimmt.

0:17:02.990,0:17:11.110
Aber natürlich, da Java- oder C- oder
Python-Programme nicht auch nur zu einem großen Teil

0:17:11.110,0:17:18.240
in Form von verschachtelten Funktionsaufrufen ausgedrückt
werden, gibt es nicht so viele Möglichkeiten.

0:17:18.240,0:17:20.640
Es ist nicht wie in der Mathematik,
wo alles ein Ausdruck ist.

0:17:20.640,0:17:26.120
Tatsächlich ermutigt oder erzwingt die funktionale
Programmierung, oder die Haskell-Programmierung,

0:17:26.120,0:17:29.110
diese Art von Programm; wir bauen
Ausdrücke neu auf wie diese.

0:17:29.110,0:17:33.440
Und sobald wir in einer Sprache sind, in der das
nicht der Fall ist, dann könnte es möglich sein,

0:17:33.440,0:17:38.681
ein paar kleine Änderungen vorzunehmen, aber
nicht in demselben Geist, dass man wirklich

0:17:38.681,0:17:41.070
über Programme in Bezug auf solche
Transformationen nachdenken wird.

0:17:41.070,0:17:42.330
Ja, okay.

0:17:42.330,0:17:47.800
Und dann könnte man auch sagen, vielleicht brauche ich
diese Gesetze nicht, richtig? Ich sehe diesen Ausdruck,

0:17:47.800,0:17:48.880
ich sehe, was hier los ist.

0:17:48.880,0:17:49.910
Also, ich verbessere es einfach.

0:17:49.910,0:17:53.100
Na ja, vielleicht wenn das so ein
kleines Beispiel war, ist das wahr.

0:17:53.100,0:17:56.640
Aber solche naheliegenden Überlegungen sind
nicht etwas, das in großem Maßstab funktioniert.

0:17:56.640,0:18:00.330
Es gibt einen Grund, warum Mathematiker nicht
Gleichungen anschauen und sagen: Na ja, ich sehe

0:18:00.330,0:18:05.700
die Lösung. Sie wenden
wirklich Gesetze an wie diese.

0:18:05.700,0:18:10.170
Und es gibt einen Grund dafür, es so zu machen,
weil man dann beweisen kann, dass etwas wahr ist.

0:18:10.170,0:18:16.860
Und man kann dann mit größeren Beispielen umgehen
oder größeren Problemen, als wenn man einfach

0:18:16.860,0:18:19.420
nach gesundem Menschenverstand arbeitet
und sagt: Ich sehe, was die Lösung ist.

0:18:19.420,0:18:20.890
Und das Gleiche gilt für Programme.

0:18:20.890,0:18:25.520
In einem kleinen Programm ist es vielleicht nicht
notwendig, wirklich mit diesen Gesetzen zu arbeiten.

0:18:25.520,0:18:31.350
Aber sobald man im Kontext eines größeren Programms
arbeitet, ist es wirklich hilfreich zu wissen,

0:18:31.350,0:18:37.750
warum man einige, zum Beispiel, Vereinfachungsschritte
durchführt. Und dann sind Gesetze wie diese wirklich

0:18:37.750,0:18:38.750
der richtige Weg.

0:18:38.750,0:18:41.770
Sie dienen eigentlich auch anderen Zwecken.

0:18:41.770,0:18:46.300
Sie könnten als Dokumentation für
die API, für die Bibliothek, dienen.

0:18:46.300,0:18:49.510
Sie könnten zum Beispiel auch zum Testen der
Bibliothek oder der Implementierung dienen.

0:18:49.510,0:18:55.300
Wenn wir also unsere Bibliothek haben und
wissen, was die Funktionen sind, können wir über

0:18:55.300,0:18:58.290
nützliche Gesetze nachdenken,
die wahr sein sollten.

0:18:58.290,0:19:02.080
Und dann könnten wir Tests auf der Bibliothek durchführen,
um zu sehen, ob diese Gesetze wirklich erfüllt sind.

0:19:02.080,0:19:07.330
Und wenn sie das nicht sind, dann gibt es wahrscheinlich
ein Problem, nicht in unserem Denken über die Eigenschaft

0:19:07.330,0:19:12.360
oder Operation, sondern in der
Implementierung der Bibliothek.

0:19:12.360,0:19:13.760
Okay.

0:19:13.760,0:19:18.540
Also, ich möchte einen weiteren Exkurs
machen, da ich gerade Java erwähnt habe.

0:19:18.540,0:19:26.300
Könnten Sie sich also vorstellen, dass die gleiche Art von
Ansatz in Java oder anderen Sprachen funktionieren würde,

0:19:26.300,0:19:27.300
die Sie kennen?

0:19:27.300,0:19:34.090
Lassen Sie uns darüber nachdenken:
Könnten wir so etwas auch in Java machen?

0:19:34.090,0:19:35.590
Nun, bis zu einem gewissen
Grad wahrscheinlich ja.

0:19:35.590,0:19:41.230
Also, lassen Sie uns darüber im
objektorientierten Stil nachdenken, zum Beispiel.

0:19:41.230,0:19:47.060
Sie können sich also vorstellen, dass Sie, wenn Sie
Methoden für eine Picture-Klasse einführen, zum Beispiel

0:19:47.060,0:19:50.420
zum Färben, zum Drehen, zum Verschieben usw.,

0:19:50.420,0:19:56.020
man wahrscheinlich Dinge schreiben könnte
wie: Wenn ich ein Bild habe und es einfärbe

0:19:56.020,0:20:01.780
(ja, sagen wir, wir haben eine Methode
dafür und sie nimmt ein Bildargument, weil

0:20:01.780,0:20:05.540
sie auf einem Objekt der Klasse Bild operiert),

0:20:05.540,0:20:17.060
und danach drehe ich das um einen bestimmten
Winkel, dann kann man wahrscheinlich erwarten und

0:20:17.060,0:20:26.480
für irgendeine Bibliothek feststellen, dass das das
Gleiche ist als wenn man das Bild erst dreht und es dann

0:20:26.480,0:20:27.480
einfärbt.

0:20:27.480,0:20:30.299
Ja, also, das ist in diesem Geiste.

0:20:30.299,0:20:37.750
Definitiv sehr ähnlich zu dem, was ich oben angegeben habe
als das zweite Gesetz. Und für die anderen Gesetze gilt, dass

0:20:37.750,0:20:45.550
man wahrscheinlich in vielen Fällen etwas
aufschreiben könnte, auch in dieser objektorientierten

0:20:45.550,0:20:46.560
Notation.

0:20:46.560,0:20:54.640
Okay, also, das ist hier in gewisser Weise ein
Glücksfall, denn die Syntax funktioniert sehr gut

0:20:54.640,0:21:00.590
auf diese Weise für Methoden, die
auf genau ein Bild wirken, richtig?

0:21:00.590,0:21:05.100
Einfärben braucht ein Bild, Drehen
funktioniert auf einem Bild usw.

0:21:05.100,0:21:11.470
Wenn man also zum Beispiel schon etwas
für die Kombination von Bildern tut,

0:21:11.470,0:21:15.120
wird es komplizierter.

0:21:15.120,0:21:23.070
Ja, also das funktioniert
wirklich nicht so schön für

0:21:23.070,0:21:26.160
zum Beispiel binäre Methoden,

0:21:26.160,0:21:30.160
also Methoden, die zwei Bildargumente annehmen.

0:21:30.160,0:21:38.660
Also genau wie die Kombinationsfunktion,
aber im funktionalen Ausdrucksstil

0:21:38.660,0:21:42.810
ist es kein Problem, wie viele Argumente
Funktionen haben. Solange alles ein Ausdruck ist...

0:21:42.810,0:21:46.600
Wenn Sie eine Funktion haben,
die drei Argumente nimmt, dann

0:21:46.600,0:21:48.760
kann man immer noch
Gesetze darüber schreiben.

0:21:48.760,0:21:50.310
Also, es gibt kein Problem damit.

0:21:50.310,0:21:59.100
Und auch, nur so nebenbei, Objektorientierung
funktioniert normalerweise, hat aber

0:21:59.100,0:22:03.410
natürlich Probleme

0:22:03.410,0:22:05.790
mit Sachen wie dem Folgenden.

0:22:05.790,0:22:16.450
Nehmen wir an, wir haben ein Bild und
wollen eine farbige Version davon haben.

0:22:16.450,0:22:25.000
Wir wollen aber auch dasselbe Grundbild an
einer anderen Stelle, ohne eine neue Farbe.

0:22:25.000,0:22:29.650
Sagen wir, wir haben ein Dreieck, und wir
wollen es irgendwo hinbewegen, aber wir wollen

0:22:29.650,0:22:31.920
es auch rot einfärben, aber
das als zwei unabhängige Dinge.

0:22:31.920,0:22:38.380
Wir wollen irgendwo ein farbiges Dreieck haben
und ein ungefärbtes Dreieck irgendwo anders.

0:22:38.380,0:22:44.710
Und das ist dann nicht wirklich das, was dieser Ausdruck sagt.
Denn in dieser Interpretation würde er uns genau das geben,

0:22:44.710,0:22:49.520
wo eine Methode wie diese auf das Objekt
wirkt; dann würde das bedeuten, wenn von links

0:22:49.520,0:22:54.530
nach rechts ausgewertet wird, dann würde dieser erste
Aufruf unser Dreieck nehmen und färbt es z.B. rot.

0:22:54.530,0:23:02.250
Und dann würde der zweite Aufruf das
Dreieck, das jetzt rot ist, irgendwo

0:23:02.250,0:23:03.250
hinbewegen, richtig?

0:23:03.250,0:23:07.880
Denn das wird eine Auswirkung auf
das p gehabt haben, durch Schreiben

0:23:07.880,0:23:12.140
einiger Instanzvariablen oder Setzen
der Farbe oder so etwas in der Art.

0:23:12.140,0:23:19.350
Okay, nun, das ist nicht dasselbe wie in der
Mathematik, wo so etwas nicht passieren kann.

0:23:19.350,0:23:23.500
Nur weil wir an irgendeiner Stelle des Ausdrucks einen
"colored"-Aufruf für p haben, heißt das nicht, dass

0:23:23.500,0:23:28.760
andere Vorkommen desselben Ausdrucks ebenfalls
auf magische Weise ihre Farbe ändern.

0:23:28.760,0:23:34.410
Das liegt an den Seiteneffekten der
imperativen Programmierung, etc.

0:23:34.410,0:23:41.740
Okay, und nun, zum Schluss, zurück zu
einem anderen Aspekt von letzter Woche.

0:23:41.740,0:23:48.620
Natürlich ist schon die Idee, dass wir solche
Transformationen in Kontext ausführen können, wichtig, oder?

0:23:48.620,0:23:58.020
Ich meine, selbst wenn ich etwas über Rotation und
Farbe bewiesen habe, etc., dann ist es wichtig,

0:23:58.020,0:23:59.380
zu wissen, dass es überall gilt.

0:23:59.380,0:24:04.220
Es spielt also keine Rolle, ob ich das in einem
"translated"-Aufruf oder irgendwo anders im Programm mache.

0:24:04.220,0:24:09.220
Wenn ich eine Berechnung wie diese durchführe,
dann möchte ich dies überall als wahr ansehen.

0:24:09.220,0:24:15.010
Genau wie in der Mathematik. Wenn ich in der Mathematik
so etwas schreibe wie... nehmen wir ein anderes Gesetz,

0:24:15.010,0:24:20.550
oder eine andere Vereinfachung in gewissem Sinne; sagen
wir mal, wir wollen Division durch Multiplikation ersetzen.

0:24:20.550,0:24:24.040
Ja, das ist ein Beispiel aus der Mathematik.

0:24:24.040,0:24:37.370
Nehmen wir an, wir haben etwas wie x geteilt durch
y. Und, aus welchem Grund auch immer, möchte ich

0:24:37.370,0:24:41.830
dies mit y in der Potenz
minus eins ( y^-1 ) schreiben.

0:24:41.830,0:24:49.320
Also, der Kehrwert davon, und den will ich mit
x multiplizieren. Dann ist das sicherlich ein

0:24:49.320,0:24:53.400
geeignetes Gesetz in der Mathematik und
auch etwas, das in C gilt. Wenn Sie

0:24:53.400,0:24:58.530
an Fließkommadivision und -multiplikation
etc. denken, dann ist das bis auf

0:24:58.530,0:25:00.320
Rundungsungenauigkeiten

0:25:00.320,0:25:05.490
etwas, das man auch als mathematisches
Gesetz in C ansehen könnte.

0:25:05.490,0:25:11.220
Aber leider, in einer nicht-mathematischen
Sprache wie C, bedeutet das nicht, dass wir es

0:25:11.220,0:25:13.770
an beliebiger Stelle in einem
Programm verwenden können.

0:25:13.770,0:25:15.220
Und warum ist das nicht der Fall?

0:25:15.220,0:25:19.440
Nun, es ist wieder diese Begebenheit von letzter Woche,
die ich mit einem kleinen Beispiel gezeigt hatte.

0:25:19.440,0:25:31.450
Also, sagen wir mal in Java,
oder C, oder Python, oder

0:25:31.450,0:25:33.210
was auch immer,

0:25:33.210,0:25:37.590
haben Sie diese beiden Ausdrücke x und y, und die sind in
Wirklichkeit so etwas wie ein Aufruf der Eingabefunktion

0:25:37.590,0:25:44.610
(die keine Funktion im mathematischen Sinne
ist, aber syntaktisch wie eine Funktion aussieht

0:25:44.610,0:25:52.110
in diesen Sprachen), dann wissen Sie, dass
das nicht etwas ist, das wahr ist, richtig?

0:25:52.110,0:25:56.300
Weil es einen Unterschied macht, ob man
zuerst das x und dann das y liest oder zuerst

0:25:56.300,0:26:01.620
das y und dann das x liest. Die Angabe von zwei
Werten in der Eingabeaufforderung, 2 und 7,

0:26:01.620,0:26:06.059
führt zu völlig unterschiedlichen Ergebnissen
hier auf der linken und auf der rechten Seite,

0:26:06.059,0:26:13.920
weil diese sogenannten Funktionsausdrücke
nicht im mathematischen Sinne

0:26:13.920,0:26:15.720
Ausdrücke von Funktionen sind.

0:26:15.720,0:26:21.740
Also, Gesetze wie dieses, obwohl sie in der Arithmetik
Sinn ergeben, können nicht verwendet werden in einer

0:26:21.740,0:26:23.240
effektvollen Umgebung mit Seiteneffekten.

0:26:23.240,0:26:25.740
Okay, und das ist natürlich
nur ein kleines Beispiel.

0:26:25.740,0:26:30.180
Aber stellen Sie sich die gleiche
Situation vor für größere Programme mit

0:26:30.180,0:26:34.900
nicht nur Multiplikation, Division, sondern
wirklich domänenspezifischen Operationen wie Färben

0:26:34.900,0:26:39.010
usw., für die Picture-Domäne. Und dann
erhält man sofort Macht durch die Umwandlung

0:26:39.010,0:26:43.510
von Ausdrücken, aber das kann man nicht in einer
Sprache machen, die nicht dem Ausdrucksstil

0:26:43.510,0:26:44.010
folgt.
