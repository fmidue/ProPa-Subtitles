0:00:01.530,0:00:09.650
Lassen Sie mich die Vorlesungsvideos für
diese Woche wieder mit einigen Bemerkungen

0:00:09.650,0:00:16.880
auf dem Whiteboard beginnen, wieder, mit Auffrischen
einiger Aspekte des Ausdrucksstils, der

0:00:16.880,0:00:23.170
letzte Woche besprochen wurde, aber auch schon
ein paar Aspekte oder Beobachtungen, die ich aus

0:00:23.170,0:00:24.650
den ersten Übungsabgaben (eines früheren Jahres) gewonnen habe.

0:00:24.650,0:00:29.650
Also, normalerweise versuche ich das zu tun, einen Blick zu werfen auf
die Übungseinsendungen vor der Vorlesung,

0:00:29.650,0:00:35.250
und dann die Dinge zu kommentieren, die ich beobachtet habe
und die mir wichtig oder interessant erscheinen für die

0:00:35.250,0:00:36.250
Vorlesung.

0:00:36.250,0:00:47.239
Ich weiß nicht, ob das dieses Jahr oft möglich sein wird,
weil [... veraltete Kommentare ...]

0:00:47.239,0:00:52.710
Also, in diesem Fall einen Tag vor der Vorlesung,
aber in anderen Fällen werde ich vielleicht sogar

0:00:52.710,0:00:55.129
Videos zwei Tage oder früher vor der Vorlesung aufnehmen.

0:00:55.129,0:01:00.539
Und dann will ich natürlich nicht
zu viel von der Übung verderben.

0:01:00.539,0:01:06.680
Okay, wie auch immer, also ein paar kleine Dinge kann ich
jetzt besprechen, weil ich zumindest einen Blick

0:01:06.680,0:01:10.840
auf die ersten Abgaben geworfen habe, auch wenn
noch nicht alle im System sind.

0:01:10.840,0:01:15.000
Lassen Sie mich also ein paar kleine Dinge besprechen.

0:01:15.000,0:01:17.340
Erstens, eine Sache ist die Syntax.

0:01:17.340,0:01:23.100
Das ist etwas, worauf ich bereits
in der Vorlesung und den Beispielen von letzter Woche eingegangen bin.

0:01:23.100,0:01:28.539
Und das wichtigste, auch das, worauf Autotool in den ersten Abgaben hingewiesen hat,

0:01:28.539,0:01:37.109
also Dinge wie studentische
Abgaben bestehend aus, oder mit Code

0:01:37.109,0:01:38.109
wie solchem hier.

0:01:38.109,0:01:43.039
Also, ein Aufruf der Funktion "translated" mit
zwei Argumenten für die x- und y-Richtung, und

0:01:43.039,0:01:47.860
dann ein Rechteck oder was auch immer.

0:01:47.860,0:01:53.200
Und wenn Sie genau hinschauen, dann hätte Autotool
in einer Einreichung wie dieser gesagt,

0:01:53.200,0:01:58.479
dass diese Klammern unnötig sind. Und würde
sogar vorschlagen, dass Sie dort nur fünf

0:01:58.479,0:01:59.499
und drei schreiben sollten.

0:01:59.499,0:02:02.310
Wir bestraften das da noch nicht.

0:02:02.310,0:02:08.679
Die Vorschläge, die das Autotool macht, sind
also wirklich vorerst nur Vorschläge.

0:02:08.679,0:02:14.010
Aber ich ermutige Sie trotzdem, dieses Feedback zu lesen
und auch darauf zu reagieren, denn früher

0:02:14.010,0:02:17.550
oder später werden wir mehr von diesen Vorschlägen durchsetzen.

0:02:17.550,0:02:24.159
Sie werden also tatsächlich zur Pflicht werden
und dann muss man seinen Code ändern, weil

0:02:24.159,0:02:26.550
er sonst nicht akzeptiert wird.

0:02:26.550,0:02:28.870
Und das wollen Sie nicht, im Sinne der Korrektheit.

0:02:28.870,0:02:33.620
Es ist also eine gute Angewohnheit, am Anfang wirklich
das Feedback zu lesen, das Autotool

0:02:33.620,0:02:34.620
Ihnen gibt.

0:02:34.620,0:02:41.470
Damit Sie sowohl Ihren Code verbessern können als auch
tatsächlich später nicht frustriert sind, weil Autotool

0:02:41.470,0:02:47.210
Ihre Eingaben nicht einmal akzeptiert,
weil Sie bestimmte Stil- und andere

0:02:47.210,0:02:50.250
Richtlinien verletzen, die wir durchsetzen.

0:02:50.250,0:02:51.250
Ja, gut.

0:02:51.250,0:02:58.180
Und ich weiß und habe auch gesehen, dass in einigen
Fällen in der ersten Woche das Autotool-Feedback

0:02:58.180,0:03:03.030
etwas Falsches enthielt. Insbesondere
die ersten paar Einsendungen von Studierenden

0:03:03.030,0:03:08.250
hatten in ihrem Autotool-Feedback
einige Kommentare, die nicht wirklich sinnvoll waren.

0:03:08.250,0:03:12.870
Sinn ergeben; etwas über einen Teil des Codes
der nur in Ihrer Einreichung auftaucht. Das war

0:03:12.870,0:03:18.379
ein kleiner Fehler in Autotool, dass es etwas ausgegeben
hat, was es nicht hätte ausgeben sollen

0:03:18.379,0:03:19.379
an diesen Stellen.

0:03:19.379,0:03:21.959
Das Problem wurde also behoben und sollte nicht
wieder auftreten.

0:03:21.959,0:03:28.370
Also, die allgemeine Bemerkung ist, dass man
das Feedback lesen und darauf reagieren sollte.

0:03:28.370,0:03:32.030
Aber ein paar Studierende werden in der ersten Woche
ein Feedback bekommen haben, das sie nicht umsetzen konnten,

0:03:32.030,0:03:34.680
weil es nicht
viel Sinn ergeben hat.

0:03:34.680,0:03:38.180
Aber das sollte eine Ausnahme sein und sollte nicht
wieder vorkommen, hoffen wir.

0:03:38.180,0:03:39.180
Okay.

0:03:39.180,0:03:44.670
Voriges war also eine allgemeine Bemerkung zur Syntax, die
auf eine ganze Reihe von Abgaben zutraf.

0:03:44.670,0:03:51.030
Und dann möchte ich eine eher semantische
und interessantere Bemerkung machen, in der es um eine

0:03:51.030,0:03:55.400
bestimmte Einreichung geht, nicht weil sie
schlecht war oder so, sondern eigentlich ist es eine interessante

0:03:55.400,0:03:56.400
Einreichung.

0:03:56.400,0:04:01.519
Und ich werde sie nicht komplett wiedergeben, aber ich
möchte einige Teile davon zeigen und das verwenden

0:04:01.519,0:04:06.819
für die Diskussion der Ausdrucksseite, die
irgendwie ganz gut passt.

0:04:06.819,0:04:13.420
Okay, es gab also die Aufgabe, diesen Baum zu zeichnen,
und ohne hier eine vollständige Lösung zu geben,

0:04:13.420,0:04:15.719
denn dafür sind die Übungen da,

0:04:15.719,0:04:23.150
möchte ich einen Teil oder eine Skizze von einer Lösung
zeigen, die ich in einer der ersten Einsendungen gesehen habe.

0:04:23.150,0:04:26.759
Die sah in etwa so aus (ich lasse all
die Typ-Anmerkungen weg).

0:04:26.759,0:04:34.110
Also, es gab so etwas wie das hier, der scene-Wert,
der aus ein paar Komponenten zusammengesetzt war,

0:04:34.110,0:04:38.830
und eine davon waren die Blätter, richtig,
denn dieser Baum sollte ja auch ein paar Blätter

0:04:38.830,0:04:39.830
haben.

0:04:39.830,0:04:42.960
Also, es gab eine Definition, dann die Blätter.
Wie wurden die Blätter definiert?

0:04:42.960,0:04:46.110
Na ja, es gab eine eigene Definition.

0:04:46.110,0:04:53.090
Und die bestand wiederum aus einigen Unterausdrücken,
und einer davon war so etwas wie ein rotierter

0:04:53.090,0:04:54.090
Kreis.

0:04:54.090,0:04:59.460
Also, der Name einiger anderer Ausdrücke, eines
anderen Bildes, das irgendwo in

0:04:59.460,0:05:10.340
der Mitte eines größeren Ausdrucks auftritt. Und dann wurde dieser
rotierte Kreis definiert als etwas wie

0:05:10.340,0:05:17.160
die ... wir riefen diese Funktion zum Verschieben
eines Bildes mit einigen Argumenten auf, etwa so

0:05:17.160,0:05:18.440
wie das.

0:05:18.440,0:05:19.440
Und was war das?

0:05:19.440,0:05:20.810
Was wurde bewegt?

0:05:20.810,0:05:28.810
Nun, ein Aufruf der Funktion "rotated" mit einigen
Argumenten, etwas wie pi durch vier.

0:05:28.810,0:05:29.810
Und wovon?

0:05:29.810,0:05:34.910
Nun, von einer grünen Form, die
Teil der Blätter sein sollte, anscheinend.

0:05:34.910,0:05:36.590
Und wie wurde diese grüne Form definiert?

0:05:36.590,0:05:39.030
Nun, wieder in einer separaten Definition.

0:05:39.030,0:05:46.770
Und das war natürlich ein "colored" Aufruf, denn
es soll ja eine grüne Form sein.

0:05:46.770,0:05:47.889
Und was ist "colored"?

0:05:47.889,0:05:56.560
Nun, in diesem Fall war es ein fester Kreis
mit einem gewissen Radius, 2 oder so.

0:05:56.560,0:05:57.560
Okay.

0:05:57.560,0:06:00.860
So, und dann gab es natürlich noch eine Vervollständigung
von dieser ganzen Sache.

0:06:00.860,0:06:04.500
Also, das war ein funktionierendes Programm. Alles ist
in Ordnung.

0:06:04.500,0:06:06.979
Okay, ein paar Beobachtungen dazu.

0:06:06.979,0:06:11.510
Nun, eine Sache, die ich anmerken würde, und das
wirklich für eine Menge der Abgaben,

0:06:11.510,0:06:18.000
ist die Balance zwischen Top-Level-Definitionen
und lokalen Definitionen, okay?

0:06:18.000,0:06:22.280
Es gab eine lange
Datei, es gibt viel mehr Formen, die definiert wurden

0:06:22.280,0:06:23.319
auf die gleiche Art und Weise.

0:06:23.319,0:06:27.710
Und alle bekamen einen Top-Level-Namen und erschienen dann
in dieser langen Liste von Dingen.

0:06:27.710,0:06:28.759
Das ist schon in Ordnung.

0:06:28.759,0:06:33.490
Aber eigentlich würde ich argumentieren, dass wahrscheinlich
die meisten dieser Definitionen auch einfach als

0:06:33.490,0:06:34.840
eine lokale Definition verwendet werden.

0:06:34.840,0:06:39.260
Wenn Sie also in der Übung auf eine Situation
wie diese treffen, wo Sie

0:06:39.260,0:06:44.550
viele Definitionen schreiben, sollten Sie vielleicht darüber
nachzudenken, ob man nicht statt diese grüne Form auf oberster

0:06:44.550,0:06:47.430
Ebene zu haben, sie zum Beispiel hier als eine
lokale Definition schreibt.

0:06:47.430,0:06:50.610
Ja, das haben wir in den Beispielen der letzten Woche gesehen,

0:06:50.610,0:06:57.949
dass man auch hier eine Definition schreiben kann.
Dann ist es irgendwie logischer gruppiert.

0:06:57.949,0:07:04.919
Okay, das ist eine allgemeine Bemerkung, die
auf viele der Abgaben zutrifft, die ich gesehen habe.

0:07:04.919,0:07:07.600
Nochmal: es bedeutet nicht, dass das, was Sie hier sehen,
falsch ist.

0:07:07.600,0:07:14.220
Es ist nur eine allgemeine Bemerkung, dass man
mehr Gebrauch von lokalen Definitionen machen könnte.

0:07:14.220,0:07:21.000
Aber es gibt noch eine andere Sache, die
mich überrascht hat, als ich das hier gesehen habe.

0:07:21.000,0:07:24.250
Und im Grunde ist es hauptsächlich dieser Name: rotatedCircle.

0:07:24.250,0:07:29.139
Ich habe mich gefragt, warum sollte ich einen Kreis rotieren?
Ein Kreis ist ein rundes Ding, das nicht wirklich

0:07:29.139,0:07:30.240
Ausrichtungen hat.

0:07:30.240,0:07:32.190
Warum sollte ich einen Kreis rotieren?

0:07:32.190,0:07:36.930
Und in der Tat, wenn Sie sich das nächste Beispiel ansehen,
werden Sie wahrscheinlich erkennen, und Sie könnten es sogar

0:07:36.930,0:07:41.820
ausprobieren, wenn Sie die Lösung vor sich haben,
dass man den rotated-Aufruf wahrscheinlich

0:07:41.820,0:07:42.820
nicht braucht.

0:07:42.820,0:07:45.811
Ja, man könnte darüber nachdenken und sagen, na ja,
ich brauche den Kreis nicht zu rotieren, weil

0:07:45.811,0:07:49.479
er seine Form nur durch Rotation nicht ändert.

0:07:49.479,0:07:51.539
Das ist eine Möglichkeit, es zu betrachten.

0:07:51.539,0:07:55.140
Aber dann ist da natürlich auch die Frage,
ob man das generell argumentieren kann?

0:07:55.140,0:07:56.319
Oder ob man das beweisen kann?

0:07:56.319,0:08:00.780
Oder ist das etwas, was man im Rahmen
des Refactorings macht, wenn man solchen Code sieht.

0:08:00.780,0:08:03.229
Zum Beispiel: (es ist nicht mein Code, es ist der
Code eines Studierenden)

0:08:03.229,0:08:09.139
Also, ich bin mir vielleicht nicht sicher, allein
anhand des Names (vielleicht ist das nicht genug Hinweis,

0:08:09.139,0:08:12.770
dass ich es wirklich ändern sollte) - vielleicht ist dieser
Name einfach nicht angemessen.

0:08:12.770,0:08:17.319
Also, was könnte ich tun, um dieses Programm zu verbessern
oder das Programm zu ändern?

0:08:17.319,0:08:21.720
Ob ich diese Rotation eines Kreises wirklich brauche oder nicht
brauche?

0:08:21.720,0:08:23.120
Nun, schauen wir es uns an.

0:08:23.120,0:08:26.560
Und schauen wir es uns in diesem Ausdrucksstil und
-ansatz an.

0:08:26.560,0:08:33.120
Also, lassen Sie einen Ausdruck erstellen und
darüber nachdenken, ob man den Ausdruck manipulieren

0:08:33.120,0:08:34.910
kann, genau wie in der Mathematik. Man manipuliert
Formeln.

0:08:34.910,0:08:41.590
Wenn ich etwas sehe wie x + y × (p + c), oder was auch immer,
und es sieht zu kompliziert aus, dann kann ich auch

0:08:41.590,0:08:47.750
anfangen, algebraische Gesetze anzuwenden, um diese
Formel, vielleicht zu etwas zu vereinfachen, wo

0:08:47.750,0:08:50.970
ich eine bessere Lösung sehen kann, oder die gar direkt eine einfachere
Lösung ist.

0:08:50.970,0:08:57.170
Okay, also lassen Sie uns versuchen, die gleiche Gewohnheit hier anzuwenden
und zu versuchen, dieses Programm zu vereinfachen

0:08:57.170,0:09:00.550
wie man einen arithmetischen Ausdruck vereinfachen würde.

0:09:00.550,0:09:06.520
Okay, und um das zu tun, sollte ich vielleicht
zuerst wirklich einen Ausdruck

0:09:06.520,0:09:07.520
aus dem hier machen.

0:09:07.520,0:09:11.700
Und das kann ich tun, weil ich diese Definitionen einfach "inline",
wie Sie wissen. Und wie wir

0:09:11.700,0:09:16.300
letzte Woche besprochen haben, sind diese Definitionen hier
nicht irgendwie Zuweisungsbefehle. Sie

0:09:16.300,0:09:18.860
sind nur Namen für Unterausdrücke.

0:09:18.860,0:09:26.440
Ja, also kann ich natürlich auch die Teile von Ausdrücken
einfügen,

0:09:26.440,0:09:29.000
über die ich nachdenken möchte und diese eine geschlossene Zeile packen.

0:09:29.000,0:09:36.060
Also, genau
da dieser rotierte Kreis das war, worüber ich

0:09:36.060,0:09:39.700
nachdachte, ob ich ihn irgendwie ändern könnte.

0:09:39.700,0:09:45.590
Lassen Sie mich diesen Ausdruck nehmen und
ich schreibe ihn komplett auf, ohne diese Indirektion,

0:09:45.590,0:09:48.010
indem ich den Unterausdruck benenne.

0:09:48.010,0:09:49.010
Was erhalte ich dann?

0:09:49.010,0:09:55.190
Ich erhalte diesen etwas komplexeren Ausdruck.

0:09:55.190,0:10:00.980
Also, ich kopiere, was ich oben habe.

0:10:00.980,0:10:05.880
Lassen Sie mich das als Variablennamen schreiben,
wie in Haskell, anstatt dieses mathematischen

0:10:05.880,0:10:06.880
Pi.

0:10:06.880,0:10:11.730
Und dann kann ich anstelle von "greenForm" hier
wirklich einfach eine Definition einer grünen Form

0:10:11.730,0:10:12.730
einfügen.

0:10:12.730,0:10:15.940
Das ist genau das, was es bedeutet,
einen Unterausdruck zu haben.

0:10:15.940,0:10:23.340
Also, was ich mir dann vorstellen kann,
ist "colored".

0:10:23.340,0:10:33.200


0:10:33.200,0:10:37.690
Und dann brauche ich eine entsprechende Anzahl von Klammern.

0:10:37.690,0:10:44.390
Okay, das ist also der Ausdruck, an den ich
denke.

0:10:44.390,0:10:46.140
Und es ist dasselbe wie das hier, richtig?

0:10:46.140,0:10:51.420
Ich habe das einfach alles in eine lange Zeile geschrieben,
ein langer Ausdruck.

0:10:51.420,0:10:57.610
Okay, also was sehe ich hier jetzt? Ich habe wirklich
meine Rotation und meinen Kreis in

0:10:57.610,0:11:02.400
demselben Kontext, wo ich darüber nachdenken kann.
Ist es nötig, diesen Kreis wirklich zu rotieren?

0:11:02.400,0:11:03.820
Und wie könnte ich das machen?

0:11:03.820,0:11:04.920
Oder wie könnte ich darüber nachdenken?

0:11:04.920,0:11:08.290
Worüber ich nachdenken könnte, ist, dass es einige
Gesetze gibt, so wie wir in der Mathematik haben.

0:11:08.290,0:11:10.170
Gesetze wie: x + y ist y + x.

0:11:10.170,0:11:17.440
Wenn ich den gleichen Ansatz hier
auf einen grafischen Ausdruck anwenden will, muss ich

0:11:17.440,0:11:18.440
über Gesetze nachdenken.

0:11:18.440,0:11:20.700
Ja, das ist mein Ausdruck, der mich interessiert.

0:11:20.700,0:11:22.870
Lasses Sie mich darüber nachdenken, nicht nur
was zu tun ist

0:11:22.870,0:11:27.331
mit diesem Ausdruck, sondern eine allgemeine
Idee von dem, was vor sich geht. Lassen Sie mich

0:11:27.331,0:11:29.870
über ein Gesetz nachdenken.

0:11:29.870,0:11:35.210
So wie ein mathematisches Gesetz, wie die Kommutativität,
oder so etwas, aber für diese Operationen.

0:11:35.210,0:11:44.730
Also, eine Sache, die ich mir vorstellen könnte, die wahr ist, ist
so etwas wie das: "rotated", mit einem

0:11:44.730,0:11:51.580
Argument (ich muss nicht Pi durch 2 haben
oder so, ich kann einen beliebigen

0:11:51.580,0:11:57.330
Winkel nehmen) und einem ausgefüllten Kreis, und wahrscheinlich gilt
dasselbe für einen normalen Kreis.

0:11:57.330,0:12:00.540
Aber da ich einen ausgefüllten Kreis habe,
lassen Sie mich das darüber machen.

0:12:00.540,0:12:04.240
Und noch einmal: Der Radius des Kreises ist nicht
wichtig, ob er 2 oder 3 ist, oder was auch immer.

0:12:04.240,0:12:07.410
Also, lassen Sie mich auch hierfür eine Variable
nehmen.

0:12:07.410,0:12:16.180
Dann könnte ich sagen, naja, wahrscheinlich sollte es
ein Gesetz geben, das sagt: wenn ich einen Kreis rotiere,

0:12:16.180,0:12:17.180
ändert sich nichts.

0:12:17.180,0:12:22.880
Und lassen Sie mich das Symbol für "semantisch
äquivalent" (grundsätzlich das Gleichheitszeichen aus der Mathematik)

0:12:22.880,0:12:31.850
nehmen. Nun, der rotierte Kreis ist
wirklich nur der Kreis mit dem gleichen Radius.

0:12:31.850,0:12:37.240
Und der Winkel, um den rotiert wird, ist irrelevant,
weil ich den Kreis gar nicht rotieren muss.

0:12:37.240,0:12:39.340
Okay, und das war wahrscheinlich meine Intuition, warum ich
dachte:

0:12:39.340,0:12:41.810
ein rotierte Kreis ergibt nicht wirklich
viel Sinn.

0:12:41.810,0:12:43.040
Es ist einfach nur ein Kreis.

0:12:43.040,0:12:52.940
Also dieses Gesetz beinhaltet irgendwie genau
diese Intuition, die ich hatte.

0:12:52.940,0:12:53.940
Okay.

0:12:53.940,0:12:58.000
Aber das trifft hier nicht wirklich zu, richtig,
man hat ja nicht etwas in der Form: rotiert

0:12:58.000,0:12:59.460
um einen Winkel einen Kreises.

0:12:59.460,0:13:01.290
Das ist nicht das, was wir hier sehen.

0:13:01.290,0:13:05.360
Genau wie man in der Mathematik
das Distributivgesetz nicht anwenden kann,

0:13:05.360,0:13:09.870
wenn man nicht die richtige Form hat. In unserem
mathematischen Ausdruck brauchen wir mehr.

0:13:09.870,0:13:11.980
Also brauchen wir eigentlich nicht nur ein Gesetz,

0:13:11.980,0:13:15.410
sondern vielleicht mehr als eines, vielleicht zusätzliche
Gesetze.

0:13:15.410,0:13:17.540
Lassen Sie uns über weitere Gesetze nachdenken.

0:13:17.540,0:13:23.420
Wenn ich zum Beispiel in der Lage sein will, das anzuwenden,
dann sollte ich wahrscheinlich irgendwie diese

0:13:23.420,0:13:25.690
"rotated" weiter nach innen schieben.

0:13:25.690,0:13:31.000
Genau wie man in der Mathematik manchmal
ein paar Schritte machen muss, um letztendlich

0:13:31.000,0:13:35.730
wirklich etwa das
Distributivgesetz anwenden zu können.

0:13:35.730,0:13:42.070
Also, ein anderes nützliches Gesetz wäre ..., und dann
können wir darüber nachdenken, ob es tatsächlich wahr ist.

0:13:42.070,0:13:47.450
Aber etwas, das hier nützlich wäre,
um das erste Gesetz anzuwenden, wäre, wenn man

0:13:47.450,0:13:54.390
so etwas hat wie: wenn man etwas rotiert
was farbig ist, also wenn wir eine Variable haben

0:13:54.390,0:13:56.700
für die Farbe c,

0:13:56.700,0:14:01.920
und für ein Bild p, das alles Mögliche sein kann
(irgendetwas, das ein Bild ist), dann, na ja, was

0:14:01.920,0:14:02.920
würden wir haben?

0:14:02.920,0:14:07.690
Man könnte sagen: Nun, ein farbiges Bild zu drehen
ist dasselbe wie ein gedrehtes Bild zu färben,

0:14:07.690,0:14:10.170
Das wäre in dem obigen Ausdruck sicherlich nützlich.

0:14:10.170,0:14:19.510
Also, sagen wir mal, bzw. stellen wir eine Hypothese auf:
Das ist im Grunde genommen dasselbe, wie wenn man diese beiden

0:14:19.510,0:14:22.320
Aufrufe hat.

0:14:22.320,0:14:31.640
Also, wir nehmen ein Bild auf, färben es ein, und
drehen es dann um einen bestimmten Winkel. Ist es

0:14:31.640,0:14:36.430
dasselbe wie ein Bild zu nehmen, es zuerst zu drehen
und dann einzufärben?

0:14:36.430,0:14:41.160
Und nun, ob das stimmt oder nicht, hängt natürlich
von der Bibliothek, von der Implementierung ab.

0:14:41.160,0:14:45.160
Aber wenn die Implementierung,
die CodeWorld-Bibliothek, die wir benutzen,

0:14:45.160,0:14:51.790
wirklich sinnvolle Versionen
von Rotation, Färbung und anderen Bildprimitiven implementiert,

0:14:51.790,0:14:54.230
dann ist das wahrscheinlich ein Gesetz, von dem Sie auch erwarten,
dass es gilt.

0:14:54.230,0:15:02.790
Und für andere Situation könnten wir natürlich auch
weitere Gesetze haben, wie zum Beispiel,

0:15:02.790,0:15:13.920
was es bedeutet,
ein farbiges Bild zu bewegen, usw.

0:15:13.920,0:15:18.760
Im Grunde genommen können wir also für viele der Kombinationen
unserer Bildprimitiven

0:15:18.760,0:15:19.760
über Gesetze nachdenken.

0:15:19.760,0:15:20.760
Ja, gut.

0:15:20.760,0:15:27.690
Nehmen wir nun an, dass diese Gesetze gültig sind, dann könnten wir mit diesen beiden zusammen

0:15:27.690,0:15:34.520
tatsächlich die Reihenfolge dieser beiden Aufrufe vertauschen,
und dann das "rotated" eliminieren, weil es

0:15:34.520,0:15:36.500
einen Kreis sieht.

0:15:36.500,0:15:45.550
Und das bedeutet, zumindest wenn ich dieses r hier hinstelle,
dass wir es eigentlich komplett eliminieren können.

0:15:45.550,0:15:54.420
Okay, dann werde ich das jetzt mal korrigieren und
den Radius hier hinstellen.

0:15:54.420,0:15:59.510
Okay, und was ich hier gemacht habe, oder was
ich hier vorschlage, um das obige Programm zu verbessern,

0:15:59.510,0:16:04.660
ist eigentlich dasselbe, was wir in der Mathematik machen,
wenn wir Ausdrücke vereinfachen.

0:16:04.660,0:16:08.330
Es wird einfach auf einen anderen Bereich angewendet,
nämlich in diesem Fall auf den Bereich von

0:16:08.330,0:16:09.330
Bild-Ausdrücken.

0:16:09.330,0:16:23.640
Also, es ist wirklich das Gleiche wie in der Mathematik,
der Arithmetik, wo wir Gesetze haben wie "a + b ist b + a"

0:16:23.640,0:16:34.980
oder "a × (b + c)" ist "a × b + a × c".

0:16:34.980,0:16:39.720
Okay, das ist die gleiche Art der Argumentation oder des
Denkens, das ich hier mache.

0:16:39.720,0:16:43.330
Ist das nun spezifisch für die Haskell-Programmierung
oder für die funktionale Programmierung?

0:16:43.330,0:16:45.920
Oder kann ich das auch in anderen Sprachen machen?

0:16:45.920,0:16:49.360
Nun, bis zu einem gewissen Grad könnte man sagen, vielleicht
kann ich das Gleiche in Java machen.

0:16:49.360,0:16:56.440
Wenn ich in Java oder C oder Python meine Bibliothek so schreibe,
in einem Stil, dass ich diese Primitiven habe,

0:16:56.440,0:17:02.990
vielleicht könnte ich solche Refactorings auch da
auf meine Programme anwenden. Was bis zu einem gewissen Grad auch stimmt.

0:17:02.990,0:17:11.110
Aber natürlich, da Java- oder C- oder Python-Programme
nicht auch nur zu einem großen Teil

0:17:11.110,0:17:18.240
in Form von verschachtelten Funktionsaufrufen
ausgedrückt werden, gibt es nicht so viele Möglichkeiten.

0:17:18.240,0:17:20.640
Es ist nicht wie in der Mathematik, wo alles
ein Ausdruck ist.

0:17:20.640,0:17:26.120
Tatsächlich ermutigt oder erzwingt die funktionale Programmierung,
oder die Haskell-Programmierung

0:17:26.120,0:17:29.110
diese Art von Programm; wir bauen Ausdrücke neu auf
wie diese.

0:17:29.110,0:17:33.440
Und sobald wir die Sprache lernen, lernen wir, dass wenn das
nicht der Fall ist, dann könnte es möglich sein

0:17:33.440,0:17:38.681
ein paar kleine Änderungen vorzunehmen, aber nicht in
demselben Geist, dass man wirklich

0:17:38.681,0:17:41.070
über Programme in Bezug auf solche Transformationen nachdenken wird.

0:17:41.070,0:17:42.330
Ja, okay.

0:17:42.330,0:17:47.800
Und dann könnte man auch sagen, vielleicht brauche ich
diese Gesetze nicht, richtig? Ich sehe diesen Ausdruck,

0:17:47.800,0:17:48.880
ich sehe, was hier los ist.

0:17:48.880,0:17:49.910
Also, ich verbessere es einfach.

0:17:49.910,0:17:53.100
Na ja, vielleicht wenn das so ein kleines Beispiel war,
ist das wahr.

0:17:53.100,0:17:56.640
Aber solche naheliegenden Überlegungen sind nicht etwas,
das in großem Maßstab funktioniert.

0:17:56.640,0:18:00.330
Es gibt einen Grund, warum Mathematiker nicht
Gleichungen anschauen und sagen: Na ja, ich sehe

0:18:00.330,0:18:05.700
die Lösung. Sie wenden wirklich Gesetze an wie
diese.

0:18:05.700,0:18:10.170
Und es gibt einen Grund dafür, es so zu machen,
weil man dann beweisen kann, dass etwas wahr ist.

0:18:10.170,0:18:16.860
Und man kann dann mit größeren Beispielen umgehen,
oder größeren Probleme, als wenn man einfach

0:18:16.860,0:18:19.420
nach gesundem Menschenverstand arbeitet und sagt: Ich sehe, was die
Lösung ist.

0:18:19.420,0:18:20.890
Und das Gleiche gilt für Programme.

0:18:20.890,0:18:25.520
In einem kleinen Programm ist es vielleicht nicht notwendig,
wirklich mit diesen Gesetzen zu arbeiten.

0:18:25.520,0:18:31.350
Aber sobald man im Kontext eines größeren Programms
arbeitet, ist es wirklich hilfreich zu wissen,

0:18:31.350,0:18:37.750
warum man einige, zum Beispiel, Vereinfachungsschritte
durchführt, und dann sind Gesetze wie diese wirklich

0:18:37.750,0:18:38.750
der richtige Weg.

0:18:38.750,0:18:41.770
Sie dienen eigentlich auch anderen Zwecken.

0:18:41.770,0:18:46.300
Sie könnten als Dokumentation für die
API, für die Bibliothek, dienen.

0:18:46.300,0:18:49.510
Sie könnten zum Beispiel auch zum Testen der Bibliothek
oder der Implementierung dienen.

0:18:49.510,0:18:55.300
Wenn wir also unsere Bibliothek haben und wissen,
was die Funktionen sind, können wir über

0:18:55.300,0:18:58.290
nützliche Gesetze nachdenken, die wahr sein sollten.

0:18:58.290,0:19:02.080
Und dann könnten wir Tests auf der Bibliothek durchführen,
um zu sehen, ob diese Gesetze wirklich erfüllt sind.

0:19:02.080,0:19:07.330
Und wenn sie das nicht sind, dann gibt es wahrscheinlich ein
Problem nicht in unserem Denken über die Eigenschaft

0:19:07.330,0:19:12.360
oder Operation, sondern in der Implementierung der Bibliothek.

0:19:12.360,0:19:13.760
Okay.

0:19:13.760,0:19:18.540
Also, ich möchte einen weiteren Exkurs machen, da
ich gerade Java erwähnt habe.

0:19:18.540,0:19:26.300
Könnten Sie sich also vorstellen, dass die gleiche Art von
Ansatz in Java oder anderen Sprachen funktionieren würde,

0:19:26.300,0:19:27.300
die Sie kennen?

0:19:27.300,0:19:34.090
Lassen Sie uns darüber nachdenken: Könnten wir
so etwas auch in Java machen?

0:19:34.090,0:19:35.590
Nun, bis zu einem gewissen Grad wahrscheinlich ja.

0:19:35.590,0:19:41.230
Also, lassen Sie uns darüber im objektorientierten Stil nachdenken,
zum Beispiel.

0:19:41.230,0:19:47.060
Sie können sich also vorstellen, dass Sie, wenn Sie
Methoden für eine Picture-Klasse einführen, zum Beispiel

0:19:47.060,0:19:50.420
zum Färben, zum Drehen, zum Verschieben, usw.,

0:19:50.420,0:19:56.020
Man könnte wahrscheinlich Dinge schreiben wie, wenn ich
ein Bild habe und es einfärbe

0:19:56.020,0:20:01.780
Ja, sagen wir, wir haben eine Methode dafür und
sie nimmt ein Bildargument, weil

0:20:01.780,0:20:05.540
sie auf einem Objekt der Klasse Bild operiert,

0:20:05.540,0:20:17.060
und danach drehe ich das um einen bestimmten
Winkel, dann kann man wahrscheinlich erwarten und

0:20:17.060,0:20:26.480
für irgendeine Bibliothek feststellen, dass das das Gleiche
ist als wenn man das Bild erst dreht und es dann

0:20:26.480,0:20:27.480
einfärbt.

0:20:27.480,0:20:30.299
Ja, also, das ist in diesem Geiste.

0:20:30.299,0:20:37.750
Definitiv sehr ähnlich zu dem, was ich oben angegeben habe
als das zweite Gesetz. Und für die anderen Gesetze gilt, dass

0:20:37.750,0:20:45.550
man wahrscheinlich in vielen Fällen etwas aufschreiben
könnte, auch in dieser objektorientierten

0:20:45.550,0:20:46.560
Notation.

0:20:46.560,0:20:54.640
Okay, also, das ist hier in gewisser Weise ein Glücksfall,
denn die Syntax funktioniert sehr gut

0:20:54.640,0:21:00.590
auf diese Weise für Methoden, die
auf genau ein Bild wirken, richtig?

0:21:00.590,0:21:05.100
Einfärben braucht ein Bild, Drehen funktioniert
auf einem Bild, usw.

0:21:05.100,0:21:11.470
Wenn man also zum Beispiel schon
etwas für die Kombination von Bildern tut,

0:21:11.470,0:21:15.120
wird es komplizierter.

0:21:15.120,0:21:23.070
Ja, also das funktioniert wirklich nicht so schön für

0:21:23.070,0:21:26.160
zum Beispiel binäre Methoden,

0:21:26.160,0:21:30.160
also Methoden, die zwei Bildargumente annehmen.

0:21:30.160,0:21:38.660
Also genau wie die Kombinationsfunktion,
aber im funktionalen Ausdrucksstil

0:21:38.660,0:21:42.810
ist es kein Problem, wie viele Argumente
Funktionen haben. Solange alles ein Ausdruck ist...

0:21:42.810,0:21:46.600
Wenn Sie eine Funktion haben,
die drei Argumente nimmt, dann

0:21:46.600,0:21:48.760
kann man immer noch
Gesetze darüber schreiben.

0:21:48.760,0:21:50.310
Also, es gibt kein Problem damit.

0:21:50.310,0:21:59.100
Und auch, nur so nebenbei, Objektorientierung funktioniert normalerweise, aber hat

0:21:59.100,0:22:03.410
natürlich Probleme

0:22:03.410,0:22:05.790
mit Sachen wie dem Folgenden.

0:22:05.790,0:22:16.450
Nehmen wir an, wir haben ein Bild und wollen
eine farbige Version davon haben.

0:22:16.450,0:22:25.000
Wir wollen aber auch dasselbe Grundbild an
einer anderen Stelle, ohne eine neue Farbe.

0:22:25.000,0:22:29.650
Sagen wir, wir haben ein Dreieck, und wir
wollen es irgendwo hinbewegen, aber wir wollen

0:22:29.650,0:22:31.920
es auch rot einfärben, aber das als zwei unabhängige
Dinge.

0:22:31.920,0:22:38.380
Wir wollen irgendwo ein farbiges Dreieck haben
und ein ungefärbtes Dreieck irgendwo anders.

0:22:38.380,0:22:44.710
Und das ist dann nicht wirklich das, was dieser Ausdruck sagt.
Denn in dieser Interpretation würde er uns genau das geben,

0:22:44.710,0:22:49.520
wo eine Methode wie diese auf das Objekt wirkt;
dann würde das bedeuten, wenn von links

0:22:49.520,0:22:54.530
nach rechts ausgewertet wird, dann wird dieser erste Aufruf unser
Dreieck nehmen und färbt es z.B. rot.

0:22:54.530,0:23:02.250
Und dann würde der zweite Aufruf
das Dreieck, das jetzt rot ist, irgendwo

0:23:02.250,0:23:03.250
hinbewegen, richtig?

0:23:03.250,0:23:07.880
Denn das wird eine Auswirkung
auf das p gehabt haben, durch Schreiben

0:23:07.880,0:23:12.140
einiger Instanzvariablen oder Setzen der Farbe
oder so etwas in der Art.

0:23:12.140,0:23:19.350
Okay, nun, das ist nicht dasselbe wie in der Mathematik,
wo so etwas nicht passieren kann.

0:23:19.350,0:23:23.500
Nur weil wir an irgendeiner Stelle des Ausdrucks einen
"colored"-Aufruf für p haben, heißt das nicht, dass

0:23:23.500,0:23:28.760
andere Vorkommen desselben Ausdrucks
ebenfalls auf magische Weise ihre Farbe ändern.

0:23:28.760,0:23:34.410
Das liegt an den Seiteneffekten der imperativen
Programmierung, etc.

0:23:34.410,0:23:41.740
Okay, und nun, zum Schluss, zurück zu einem anderen
Aspekt, von letzter Woche.

0:23:41.740,0:23:48.620
Natürlich schon die Idee, dass wir solche Transformationen
in Kontext ausführen können, ist wichtig, oder?

0:23:48.620,0:23:58.020
Ich meine, selbst wenn ich etwas bewiesen habe über
Rotation und Farbe, etc., dann ist es wichtig,

0:23:58.020,0:23:59.380
zu wissen, dass es überall gilt.

0:23:59.380,0:24:04.220
Es spielt also keine Rolle, ob ich das in einem
"translated"-Aufruf oder irgendwo anders im Programm mache.

0:24:04.220,0:24:09.220
Wenn ich eine Berechnung wie diese durchführe, dann möchte ich
dies überall als wahr ansehen.

0:24:09.220,0:24:15.010
Genau wie in der Mathematik. Wenn ich in der Mathematik
so etwas schreibe wie... nehmen wir ein anderes Gesetz,

0:24:15.010,0:24:20.550
oder eine andere Vereinfachung in gewissem Sinne; sagen wir mal,
wir wollen Division durch Multiplikation ersetzen.

0:24:20.550,0:24:24.040
Ja, das ist ein Beispiel aus der Mathematik.

0:24:24.040,0:24:37.370
Nehmen wir an, wir haben etwas wie x geteilt
durch y. Und, aus welchem Grund auch immer, möchte ich

0:24:37.370,0:24:41.830
dies mit y in der Potenz
minus eins ( y^-1 ) schreiben.

0:24:41.830,0:24:49.320
Also, der Kehrwert davon, und den will ich
mit x multiplizieren. Dann ist das sicherlich ein

0:24:49.320,0:24:53.400
geeignetes Gesetz in der Mathematik und auch
etwas, das in C gilt. Wenn Sie

0:24:53.400,0:24:58.530
an Fließkommadivision und -multiplikation
etc. denken, dann ist das bis auf

0:24:58.530,0:25:00.320
Rundungs-Ungenauigkeiten

0:25:00.320,0:25:05.490
etwas, das man auch als
mathematisches Gesetz in C ansehen könnte.

0:25:05.490,0:25:11.220
Aber leider, in einer nicht-mathematischen Sprache
wie C, bedeutet das nicht, dass wir es

0:25:11.220,0:25:13.770
an beliebiger Stelle in einem Programm verwenden können.

0:25:13.770,0:25:15.220
Und warum ist das nicht der Fall?

0:25:15.220,0:25:19.440
Nun, es ist wieder diese Begebenheit von letzter
Woche, die ich mit einem kleinen Beispiel gezeigt hatte.

0:25:19.440,0:25:31.450
Also, sagen wir mal in Java,
oder C, oder Python, oder

0:25:31.450,0:25:33.210
was auch immer,

0:25:33.210,0:25:37.590
haben Sie diese beiden Ausdrücke x und y, und die sind
in Wirklichkeit so etwas wie ein Aufruf der Eingabe-Funktion

0:25:37.590,0:25:44.610
(die keine Funktion im mathematischen Sinne
ist, aber syntaktisch wie eine Funktion aussieht

0:25:44.610,0:25:52.110
in diesen Sprachen), dann wissen Sie, dass das
nicht etwas ist, das wahr ist, richtig?

0:25:52.110,0:25:56.300
Weil es einen Unterschied macht, ob
man zuerst das x und dann das y liest oder zuerst

0:25:56.300,0:26:01.620
das y und dann das x liest. Die Angabe von zwei Werten
in der Eingabeaufforderung, 2 und 7,

0:26:01.620,0:26:06.059
führt zu völlig unterschiedlichen Ergebnissen
hier auf der linken und auf der rechten Seite,

0:26:06.059,0:26:13.920
weil diese sogenannten Funktionsausdrücke
nicht im mathematischen Sinne

0:26:13.920,0:26:15.720
Ausdrücke von Funktionen sind.

0:26:15.720,0:26:21.740
Also, Gesetze wie dieses, obwohl sie in der Arithmetik Sinn ergeben,
können nicht verwendet werden in einer

0:26:21.740,0:26:23.240
effektvollen Umgebung mit Seiteneffekten.

0:26:23.240,0:26:25.740
Okay, und das ist natürlich nur ein kleines
Beispiel.

0:26:25.740,0:26:30.180
Aber stellen Sie sich die gleiche Situation vor
für größere Programme mit

0:26:30.180,0:26:34.900
nicht nur Multiplikation, Division, sondern wirklich
domänenspezifischen Operationen wie Färben

0:26:34.900,0:26:39.010
usw., für die Picture-Domäne. Und dann
erhält man sofort Macht durch die Umwandlung

0:26:39.010,0:26:43.510
von Ausdrücken, aber das kann man nicht in einer
Sprache machen, die nicht dem Ausdrucksstil

0:26:43.510,0:26:44.010
folgt.
