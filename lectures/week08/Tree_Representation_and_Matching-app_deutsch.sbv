0:00:01.440,0:00:07.840
Okay, schauen wir uns diesen Datenwert vom Typ
'Connection', den wir auf den Folien hatten,

0:00:07.840,0:00:12.480
und wo ich versprochen hatte, dass ich
zeigen würde, wie er einem Baum entspricht.

0:00:12.480,0:00:15.840
Wie man sich dies als einen
solchen vorstellen kann.

0:00:15.840,0:00:18.960
Und natürlich ist
die Illustration sehr einfach.

0:00:18.960,0:00:23.360
Sie ist sehr ähnlich zu dem, wie ich
zuvor andere Ausdrücke dargestellt habe.

0:00:23.360,0:00:26.080
Denn es ist auch nur ein Ausdruck,
wo die Funktionen jetzt nicht

0:00:26.800,0:00:31.600
'colored' und 'translated' und andere Dinge sind, die ich
verwendet habe, als ich über Picture-Ausdrücke gesprochen habe.

0:00:31.600,0:00:34.640
Sondern das sind jetzt Daten
Konstruktoren, die auch Funktionen sind.

0:00:34.640,0:00:38.480
Wie ist das nun zu interpretieren?

0:00:38.480,0:00:46.080
Wir haben also etwas, das mit diesem
Train-Datenkonstruktor konstruiert wird.

0:00:46.080,0:00:56.640
Als Baum wäre der Zug also das, was an der
Wurzel des Knotens des Baums erscheint.

0:00:57.280,0:01:00.640
Und wir wissen, dass er drei Argumente hat.

0:01:00.640,0:01:05.680
Wir wissen das sowohl aus dem Ausdruck, wie wir hier
sehen, sondern auch aus den Datentypdefinitionen.

0:01:05.680,0:01:08.240
Das bedeutet also, dass es drei Argumente gibt.

0:01:08.240,0:01:13.200
Also, in diesem Ausdruck,
Abbildung, drei Teilbäume.

0:01:13.200,0:01:16.880
Und der erste ist dieser
Pfad, dieser Ausdruck,

0:01:16.880,0:01:20.480
der wiederum von Day auf drei
Argumente angewendet wird.

0:01:20.480,0:01:27.600
An dieser Stelle des Baums würde also diese
Bezeichnung/Konstruktor/Tag-Name 'Day' erscheinen.

0:01:30.400,0:01:33.600
Darunter haben wir drei Argumente, bei
denen es sich um drei Ganzzahlen handelt.

0:01:33.600,0:01:38.400
Sie sind also einfach Konstanten,
die hier in der Struktur erscheinen.

0:01:39.680,0:01:45.200
Dann haben wir das zweite Argument, den
zweiten Teilbaum von Train, der diese Form hat.

0:01:45.200,0:01:52.880
Das ist also unser Konstruktor,
und das Argument 11.

0:01:53.520,0:01:55.360
Und das Gleiche gilt für die letzte Sache.

0:01:57.040,0:02:03.600
Okay, und dann kann auf diese Weise natürlich
jeder Wert vom Typ 'Connection' abgebildet werden.

0:02:03.600,0:02:07.680
Und wenn es eine Flight-Connection wäre, dann
würde hier an der Wurzel ein Flug stehen.

0:02:07.680,0:02:09.920
Und es würde eine andere
Anzahl von Argumenten haben.

0:02:09.920,0:02:12.560
Und auch die Rolle wäre eine andere.

0:02:12.560,0:02:14.480
So wäre das erste Argument
eine Zeichenkette, usw.

0:02:14.480,0:02:20.320
Aber es wird immer noch ein Baum sein,
den wir leicht interpretieren können.

0:02:21.360,0:02:24.560
Okay, so wird dies also als Baum gezeichnet.

0:02:24.560,0:02:30.160
Und auf der nächsten Folie habe ich auch über
die nächste Folie, die Berechnung, wie es ist.

0:02:31.760,0:02:35.120
Ich habe versprochen, dass
dies auch erklärt wird.

0:02:35.120,0:02:42.080
Und dafür können wir einfach
diesen Code hier nehmen.

0:02:43.040,0:02:49.840
Und nun, lassen Sie uns das etwas
vergrößern, um zu sehen, was da passiert.

0:02:50.880,0:02:54.960
Okay, nehmen wir also an,
dass wir diese 'travelTime'

0:02:55.840,0:03:01.520
Funktion auf genau diesen Wert
anwenden, den wir hier oben haben.

0:03:02.160,0:03:04.080
Was muss dann passieren?

0:03:04.080,0:03:06.880
Nun, zuerst muss man entscheiden, welche der
beiden Gleichungen verwendet werden soll.

0:03:06.880,0:03:08.560
Aber das ist natürlich nicht sehr schwierig.

0:03:09.680,0:03:10.880
Oder?
Wir haben zwei Gleichungen.

0:03:10.880,0:03:13.680
Eine für Züge und eine für Flüge.

0:03:13.680,0:03:15.040
Und nur eine der beiden gilt.

0:03:15.040,0:03:16.960
Und es ist eigentlich egal,
in welcher Reihenfolge.

0:03:16.960,0:03:21.280
Selbst wenn dies die erste Gleichung über
den Flug wäre, würde sie nicht passen.

0:03:21.280,0:03:26.800
Denn wir haben einen Wert für Züge an der
Wurzel dieses vollständigen Arguments.

0:03:26.800,0:03:33.760
In jedem Fall würden Sie also immer am
Ende diese Gleichung hier verwenden.

0:03:35.760,0:03:37.680
Okay, und wie wird das dann verwendet?

0:03:37.680,0:03:38.480
Nun, schauen wir mal.

0:03:39.840,0:03:42.160
Im Grunde genommen, indem
man prüft: Wir haben 'Train'.

0:03:42.160,0:03:43.440
Das ist also dieser 'Train'.

0:03:44.080,0:03:47.360
Dann gibt es eine anonyme Variable.

0:03:47.360,0:03:49.920
Das erste Argument interessiert uns hier nicht.

0:03:49.920,0:03:52.960
Denn das ist nicht relevant, um die
Reisezeit in Stunden zu berechnen.

0:03:53.760,0:04:00.080
Nach unserer Definition spielt es keine
Rolle, an welchen Tagen das passiert.

0:04:00.080,0:04:03.120
Das ist also der Grund, warum
wir diesen Teil nicht verwenden.

0:04:03.120,0:04:05.680
Oder wir machen gar nichts damit.

0:04:05.680,0:04:08.960
Dann muss das zweite Argument
eine 'Hour' von etwas sein.

0:04:08.960,0:04:10.960
Nun, das ist genau das, was hier passiert.

0:04:10.960,0:04:15.520
Und nun, diese 'Hour' im konkreten
Beispiel ist natürlich 11.

0:04:15.520,0:04:20.240
Und in der Funktionsdefinition wird die
Variable (namens 'd') dafür verwendet,

0:04:20.240,0:04:28.240
was uns sagt, dass wir dies mit der
Variable ('d') für die rechte Seite machen.

0:04:28.240,0:04:30.400
Dann passiert natürlich etwas Ähnliches,

0:04:30.400,0:04:34.800
mit dem letzten Argument, also dem dritten
Argument von 'Train', und es steht in 'Hour'.

0:04:36.880,0:04:39.040
Und das stimmt natürlich
mit dieser 'Hour' überein.

0:04:40.160,0:04:43.840
Wir haben also jetzt einen
Abgleich mit diesem und mit diesem.

0:04:44.400,0:04:52.480
Und das sagt uns, dass dieses tiefere Argument,
also was wir hier haben, ist das ('a').

0:04:55.600,0:04:58.800
Okay, für diese erste Sache wäre es
ein ('d'), und dies ist ein ('a').

0:04:59.520,0:05:00.160
Okay.

0:05:00.160,0:05:03.040
Und dann haben wir die ganze
linke Seite abgeglichen.

0:05:03.040,0:05:05.280
Ja, wir haben herausgefunden,
dass dies tatsächlich passt.

0:05:05.280,0:05:07.920
Oder dies ist anwendbar auf den
Wert, den wir erhalten haben.

0:05:08.560,0:05:13.040
Das heißt, wir sollten die rechte
Seite genau dieser Gleichung verwenden.

0:05:13.040,0:05:18.960
Und die rechte Seite sagt: a minus d plus eins.

0:05:18.960,0:05:25.520
Und das ist natürlich dasselbe
wie 14 minus 11 plus eins,

0:05:25.520,0:05:29.360
das wissen wir jetzt. Und
das ist das Gleiche wie 4.

0:05:31.520,0:05:34.400
Also, 'travelTime' angewandt auf diesen Wert,

0:05:35.520,0:05:43.360
auf diesen Datenwert angewendet, ergibt
die Berechnung in der Ganzzahlform.

0:05:44.880,0:05:45.520
Das war es,

0:05:45.520,0:05:48.080
wie dieses Pattern-Matching und
diese Berechnung funktioniert.

0:05:48.080,0:05:51.680
Und so funktioniert es bei allen Datentypen.

0:05:51.680,0:05:53.760
Unabhängig davon, wie sie definiert sind.

0:05:53.760,0:05:59.440
Der Compiler prüft, ob die Pattern, die hier verwendet
werden, tatsächlich dem Typ entsprechend sinnvoll sind.

0:06:00.640,0:06:02.800
Der Eingabetyp der Funktion und natürlich,

0:06:02.800,0:06:05.200
die Datentypdefinition, die
für Verbindungen gegeben wurde.

0:06:05.200,0:06:09.760
Wir können also nicht irgendwie, zum Beispiel,
diese anonyme Variable komplett vergessen.

0:06:09.760,0:06:14.400
Wenn Sie das nicht schreiben, dann wird der Compiler
sich beschweren, noch bevor er etwas berechnet hat,

0:06:14.400,0:06:15.840
dass dies keinen Sinn ergibt.

0:06:15.840,0:06:18.720
Denn 'Train' nimmt laut Typdefinition
drei Argumente und nicht nur zwei.

0:06:19.440,0:06:19.680
Richtig?

0:06:19.680,0:06:30.400
Und in diesem Sinne funktioniert alles zusammen
und führt zu sinnvollen Berechnungen zur Laufzeit.
