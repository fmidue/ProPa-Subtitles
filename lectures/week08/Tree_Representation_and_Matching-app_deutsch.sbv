0:00:01.440,0:00:07.840
Okay, schauen wir uns diesen Datenwert vom
Typ "Connection", den wir auf den Folien hatten,

0:00:07.840,0:00:12.480
und wo ich versprochen hatte, dass ich zeigen würde,
wie er einem Baum entspricht.

0:00:12.480,0:00:15.840
Wie man sich dies als einen solchen vorstellen kann.

0:00:15.840,0:00:18.960
Und natürlich ist
die Illustration sehr einfach.

0:00:18.960,0:00:23.360
Sie ist sehr ähnlich zu dem, wie ich zuvor
andere Ausdrücke dargestellt habe.

0:00:23.360,0:00:26.080
Denn es ist auch nur ein Ausdruck
wo die Funktionen jetzt nicht

0:00:26.800,0:00:31.600
"colored" und "translated" und andere Dinge, die ich
verwendet habe, als ich über Picture-Ausdrücke gesprochen habe.

0:00:31.600,0:00:34.640
Sondern das sind jetzt Daten
Konstruktoren, die auch Funktionen sind.

0:00:34.640,0:00:38.480
Wie ist das nun zu interpretieren?

0:00:38.480,0:00:46.080
Wir haben also etwas, das
mit diesem Train-Datenkonstruktor konstruiert wird.

0:00:46.080,0:00:56.640
Als Baum wäre der Zug also das, was
an der Wurzel des Knotens des Baums erscheint.

0:00:57.280,0:01:00.640
Und wir wissen, dass er drei Argumente hat.

0:01:00.640,0:01:05.680
Wir wissen das sowohl aus dem Ausdruck, wie wir hier
sehen, sondern auch aus den Datentypdefinitionen.

0:01:05.680,0:01:08.240
Das bedeutet also, dass es drei Argumente gibt.

0:01:08.240,0:01:13.200
Also, in diesem Ausdruck,
Abbildung, drei Teilbäume.

0:01:13.200,0:01:16.880
Und der erste ist dieser
Pfad, dieser Ausdruck,

0:01:16.880,0:01:20.480
der wiederum von Day auf drei Argumente angewendet wird.

0:01:20.480,0:01:27.600
An dieser Stelle des Baums würde also
diese Bezeichnung/Konstrukteur/Techname "Day".

0:01:30.400,0:01:33.600
Darunter haben wir drei
Argumente, bei denen es sich um drei Ganzzahlen handelt.

0:01:33.600,0:01:38.400
Sie sind also einfach Konstanten
die hier in der Struktur erscheinen.

0:01:39.680,0:01:45.200
Dann haben wir das zweite Argument, den zweiten
Teilbaum von Train, der diese Form hat.

0:01:45.200,0:01:52.880
Das ist also unser Konstruktor, und das Argument 11.

0:01:53.520,0:01:55.360
Und das Gleiche gilt für die letzte Sache.

0:01:57.040,0:02:03.600
Okay, und dann kann auf diese Weise natürlich jeder
Wert vom Typ "Connection" abgebildet werden.

0:02:03.600,0:02:07.680
Und wenn es eine "Flight"-Verbindung wäre,
dann würde hier an der Wurzel ein Flug stehen.

0:02:07.680,0:02:09.920
Und es würde eine andere Anzahl von Argumenten haben.

0:02:09.920,0:02:12.560
Und auch die Rolle wäre eine andere.

0:02:12.560,0:02:14.480
So wäre das erste Argument
eine Zeichenkette, usw.

0:02:14.480,0:02:20.320
Aber es wird immer noch ein Baum sein,
den wir leicht interpretieren können.

0:02:21.360,0:02:24.560
Okay, so wird dies also als Baum gezeichnet.

0:02:24.560,0:02:30.160
Und auf der nächsten Folie habe ich auch über die
nächsten Folie, die Berechnung, wie es ist.

0:02:31.760,0:02:35.120
Ich habe versprochen, dass dies auch erklärt wird.

0:02:35.120,0:02:42.080
Und dafür können wir einfach diesen Code hier nehmen.

0:02:43.040,0:02:49.840
Und nun, lassen Sie uns das etwas
vergrößern, um zu sehen, was da passiert.

0:02:50.880,0:02:54.960
Okay, nehmen wir also an, dass wir
diese travelTime

0:02:55.840,0:03:01.520
Funktion auf genau diesen
Wert anwenden, den wir hier oben haben.

0:03:02.160,0:03:04.080
Was muss dann passieren?

0:03:04.080,0:03:06.880
Nun, zuerst muss man entscheiden
welche der beiden Gleichungen verwendet werden soll.

0:03:06.880,0:03:08.560
Aber das ist natürlich nicht sehr schwierig.

0:03:09.680,0:03:10.880
Oder?
Wir haben zwei Gleichungen.

0:03:10.880,0:03:13.680
Eine für Züge und eine für Flüge.

0:03:13.680,0:03:15.040
Und nur eine der beiden gilt.

0:03:15.040,0:03:16.960
Und es ist eigentlich egal, in welcher Reihenfolge.

0:03:16.960,0:03:21.280
Selbst wenn dies die erste Gleichung wäre
über den Flug wäre, würde sie nicht passen.

0:03:21.280,0:03:26.800
Denn wir haben einen Wert für Züge an der
Wurzel dieses vollständigen Arguments.

0:03:26.800,0:03:33.760
In jedem Fall würden Sie also immer
am Ende immer diese Gleichung hier verwenden.

0:03:35.760,0:03:37.680
Okay, und wie wird das dann verwendet?

0:03:37.680,0:03:38.480
Nun, schauen wir mal.

0:03:39.840,0:03:42.160
Im Grunde genommen, indem man prüft: Wir haben Train.

0:03:42.160,0:03:43.440
Das ist also dieser Train.

0:03:44.080,0:03:47.360
Dann gibt es eine anonyme Variable.

0:03:47.360,0:03:49.920
Das erste Argument interessiert uns hier nicht.

0:03:49.920,0:03:52.960
Denn das ist nicht relevant, um die
Reisezeit in Stunden zu berechnen.

0:03:53.760,0:04:00.080
Nach unserer Definition spielt es keine Rolle,
an welchen Tagen das passiert.

0:04:00.080,0:04:03.120
Das ist also der Grund, warum wir diesen Teil nicht verwenden.

0:04:03.120,0:04:05.680
Oder wir machen gar nichts damit.

0:04:05.680,0:04:08.960
Dann muss das zweite Argument
eine "Hour" von etwas sein.

0:04:08.960,0:04:10.960
Nun, das ist genau das, was hier passiert.

0:04:10.960,0:04:15.520
Und nun, diese Hour im
konkreten Beispiel ist natürlich 11.

0:04:15.520,0:04:20.240
Und in der Funktionsdefinition wird die
Variable (namens d) dafür verwendet,

0:04:20.240,0:04:28.240
was uns sagt, dass wir dies mit der
die Variable (d) für die rechte Seite.

0:04:28.240,0:04:30.400
Dann passiert natürlich etwas Ähnliches,

0:04:30.400,0:04:34.800
mit dem letzten Argument, also dem dritten
Argument von Train und es steht in Hour.

0:04:36.880,0:04:39.040
Und das stimmt natürlich mit dieser Hour überein.

0:04:40.160,0:04:43.840
Wir haben also jetzt einen Abgleich
mit diesem und mit diesem.

0:04:44.400,0:04:52.480
Und das sagt uns, dass dieses tiefere
Argument, also was wir hier haben, ist das (a).

0:04:55.600,0:04:58.800
Okay, für diese erste Sache,
wäre es ein (d) und dies ist ein (a).

0:04:59.520,0:05:00.160
Okay.

0:05:00.160,0:05:03.040
Und dann haben wir die ganze linke Seite abgeglichen.

0:05:03.040,0:05:05.280
Ja, wir haben herausgefunden, dass dies tatsächlich passt

0:05:05.280,0:05:07.920
oder dies ist anwendbar auf den
Wert, den wir erhalten haben.

0:05:08.560,0:05:13.040
Das heißt, wir sollten die
rechte Seite genau dieser Gleichung verwenden.

0:05:13.040,0:05:18.960
Und die rechte Seite sagt: a minus d plus eins.

0:05:18.960,0:05:25.520
Und das ist natürlich dasselbe
wie 14 minus 11 plus eins,

0:05:25.520,0:05:29.360
das wissen wir jetzt. Und das ist das Gleiche wie 4.

0:05:31.520,0:05:34.400
Also, travelTime angewandt auf diesen Wert,

0:05:35.520,0:05:43.360
auf diesen Datenwert angewendet, ergibt
die Berechnung in der Ganzzahlform.

0:05:44.880,0:05:45.520
Das war es,

0:05:45.520,0:05:48.080
wie dieses Pattern-Matching
und diese Berechnung funktioniert.

0:05:48.080,0:05:51.680
Und so funktioniert es bei allen Datentypen.

0:05:51.680,0:05:53.760
Unabhängig davon, wie sie definiert sind.

0:05:53.760,0:05:59.440
Der Compiler prüft, ob die Pattern, die hier
verwendet werden, tatsächlich dem Typ entsprechend sinnvoll sind.

0:06:00.640,0:06:02.800
Der Eingabetyp der Funktion und natürlich,

0:06:02.800,0:06:05.200
die Datentypdefinition, die
für Verbindungen gegeben wurde.

0:06:05.200,0:06:09.760
Wir können also nicht irgendwie, zum Beispiel, diese anonyme Variable komplett
diese anonyme Variable vergessen.

0:06:09.760,0:06:14.400
Wenn Sie das nicht schreiben, dann wird der Compiler
sich beschweren, noch bevor er etwas berechnet hat,

0:06:14.400,0:06:15.840
dass dies keinen Sinn ergibt.

0:06:15.840,0:06:18.720
Denn Train nimmt laut Typdefinition drei Argumente
der Typdefinition drei Argumente, nicht nur zwei.

0:06:19.440,0:06:19.680
Richtig?

0:06:19.680,0:06:30.400
Und in diesem Sinne funktioniert alles zusammen
und führt zu sinnvollen Berechnungen zur Laufzeit.
