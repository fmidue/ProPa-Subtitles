128 # slide
00:00:01,819 --> 00:00:05,680
Willkommen zurück zu
einer weiteren Woche ProPa.

00:00:05,680 --> 00:00:12,139
Diese Woche werden wir wieder über Typen
sprechen, aber nicht über polymorphe Typen, nicht über

00:00:12,139 --> 00:00:16,880
Typen höherer Ordnung,
zumindest nicht im Fokus.

00:00:16,880 --> 00:00:22,519
Stattdessen werden wir über neue Typkonstrukte
sprechen, die algebraische Datentypen genannt werden.

00:00:22,519 --> 00:00:27,830
Tatsächlich lassen sie sich auch mit Polymorphie
kombinieren und haben interessante Anwendungen höherer Ordnung.

00:00:27,830 --> 00:00:33,780
Aber zumindest für dieses erste Video werden
wir uns auf sehr einfache algebraische Datentypen

00:00:33,780 --> 00:00:41,680
konzentrieren: zunächst einfache Aufzählungstypen und
dann nicht-rekursive algebraische Datentypen, und wahrscheinlich

00:00:41,680 --> 00:00:44,289
auch noch nicht auf Polymorphie eingehen.

00:00:44,289 --> 00:00:50,180
Diese interessanteren/komplexeren Konstrukte und die
Wechselwirkungen mit Polymorphismus und vielleicht höherer

00:00:50,180 --> 00:00:57,110
Ordnung werden in späteren Videos
auch in dieser Woche Thema sein.

129 # slide
00:00:57,110 --> 00:01:03,019
Welche Arten von Typen
haben wir also bisher gesehen?

00:01:03,019 --> 00:01:10,030
Zum einen haben wir uns natürlich mit
Dingen wie einfachen Basistypen wie Zahlentypen oder

00:01:10,030 --> 00:01:12,330
Booleans und Zeichen beschäftigt.

00:01:12,330 --> 00:01:19,110
Also Dinge, die in die Sprache eingebaut sind,
und aus denen andere Typen konstruiert werden können.

00:01:19,110 --> 00:01:24,650
Und insbesondere haben wir uns Listen- und
Tupelkonstruktionen angesehen, mit denen man zusammengesetzte Typen bilden

00:01:24,650 --> 00:01:29,380
kann: Listen von Paaren von
Ganzzahlen und Fließkommazahlen und solche Dinge.

00:01:29,380 --> 00:01:34,240
Natürlich gab es ab letzter Woche, als
wir uns mit Polymorphismus beschäftigt haben, Typvariablen.

00:01:34,240 --> 00:01:38,170
Aber letztlich würden auch diese Typvariablen
durch Typen ersetzt werden, die wir schon

00:01:38,170 --> 00:01:42,119
gesehen haben, wie Ganzzahlen oder
Zeichen oder Listen davon usw.

00:01:42,119 --> 00:01:47,479
Dann gibt es natürlich Funktionstypen, die
wir jetzt aus dem Higher-Order Teil der

00:01:47,479 --> 00:01:51,479
Vorlesung kennen, dass wir Typen haben
können, die z.B. Funktionen als Argumente nehmen.

00:01:51,479 --> 00:01:57,259
Dann haben wir den Funktionspfeil, der auch
in Typen und Teilen von Typen vorkommt.

00:01:57,259 --> 00:02:03,829
Aber letztlich wären die Dinge, die
zwischen den Funktionspfeilen stehen, bisher vorwiegend

00:02:03,829 --> 00:02:11,570
Basistypen wie diese, oder zusammengesetzte
Typen, die aus diesen bestehen.

00:02:11,570 --> 00:02:16,580
Denken Sie auch daran, dass ich bei
der Einführung von Listen bereits gesagt habe, dass

00:02:16,580 --> 00:02:19,260
wir letztlich nicht alle unsere
Strukturen aus Listen aufbauen wollen.

00:02:19,260 --> 00:02:25,420
Denn obwohl es für Beispiele in einer Vorlesung
wie dieser ganz nett ist, sind Listen in der

00:02:25,420 --> 00:02:32,720
Realität nicht immer die beste Struktur, um Dinge
zu halten, zum Beispiel in einer zusammengesetzten Umgebung.

00:02:32,720 --> 00:02:36,020
Um Dinge zu kombinieren, können Sie manchmal Listen verwenden,
aber Sie sollten nicht immer eine Liste verwenden, also

00:02:36,020 --> 00:02:37,290
muss es auch etwas anderes geben.

00:02:37,290 --> 00:02:41,040
Genauso wie wir in
anderen Sprachen andere Datentypen haben.

00:02:41,040 --> 00:02:45,020
Wir haben nicht nur die Typen gesehen,
die in diesem ersten Punkt erwähnt werden.

00:02:45,020 --> 00:02:52,300
Im Fall der CodeWorld Bibliothek (auf der CodeWorld-Website)
haben wir zum Beispiel auch gesehen, dass

00:02:52,300 --> 00:02:56,190
es auch domänenspezifische Typen wie diesen Picture-Typ
geben kann, der eindeutig nicht etwas ist,

00:02:56,190 --> 00:02:59,460
das in die Sprache eingebaut ist,
wie es Integer und Floats sind.

00:02:59,460 --> 00:03:04,250
Es war etwas, das wir verwendet haben (das
uns von der Bibliothek gegeben wurde), aber es ist

00:03:04,250 --> 00:03:09,450
wahrscheinlich etwas, das jemand in der Sprache
definiert hat, anstatt dass es bereits von

00:03:09,450 --> 00:03:16,560
der Sprache selbst, vom Compiler
oder etwas Ähnlichem bereitgestellt wird.

00:03:16,560 --> 00:03:22,030
Das ist letztendlich das, was wir wollen, wenn
wir eine Menge Projekte erstellen, dass wir unsere eigenen

00:03:22,030 --> 00:03:23,060
Typen definieren können.

00:03:23,060 --> 00:03:25,280
Und die Bibliothek macht
das für diesen Picture-Typ.

00:03:25,280 --> 00:03:30,790
Es ist wie in einer objektorientierten Sprache, wo
Sie Ihre eigene Klasse definieren, die für Ihre

00:03:30,790 --> 00:03:35,760
Domäne relevant ist, und dann könnte Picture eine
Klasse sein und hat Objekte und Methoden, die auf

00:03:35,760 --> 00:03:37,090
diesen Objekten operieren.

00:03:37,090 --> 00:03:40,740
Und die Situation ist hier ähnlich, nur
dass wir keine Klassen im Sinne der objektorientierten

00:03:40,740 --> 00:03:41,740
Programmierung haben.

00:03:41,740 --> 00:03:42,740
Wir haben Typen.

00:03:42,740 --> 00:03:44,010
Und 'Picture' ist ein Typ.

00:03:44,010 --> 00:03:45,500
Und wir haben Werte von diesem Typ.

00:03:45,500 --> 00:03:48,160
Und wir haben Funktionen, die
mit Werten dieses Typs arbeiten.

00:03:48,160 --> 00:03:55,970
Den Typ 'Picture' selbst werden
wir in der Vorlesung nicht definieren.

00:03:55,970 --> 00:03:59,710
Er könnte mit algebraischen Datentypen definiert werden,
aber das ist nichts, was wir tun

00:03:59,710 --> 00:04:00,710
werden.

00:04:00,710 --> 00:04:06,950
Denn für unsere Zwecke und Anwendungen von
CodeWorld ist es ausreichend, wenn wir 'Picture' einfach

00:04:06,950 --> 00:04:07,950
als abstrakten Typ haben.

00:04:07,950 --> 00:04:09,500
Wir wissen also, dass er existiert.

00:04:09,500 --> 00:04:10,870
Wir kennen die Operationen auf ihm.

00:04:10,870 --> 00:04:13,550
Wir wollen nicht
unseren eigenen Picture-Typ definieren.

00:04:13,550 --> 00:04:20,820
Aber wenn wir das tun wollten, oder
etwas Ähnliches für eine andere Domäne als Vektorgrafik,

00:04:20,820 --> 00:04:23,820
dann würden wir
algebraische Datentypen verwenden.

00:04:23,820 --> 00:04:35,550
Das ist also der Weg, um über
diese Basistypen und vorgegebene Kombinationen von ihnen mit

00:04:35,550 --> 00:04:37,630
Konstrukten wie Listen
und Paaren hinauszugehen.

00:04:37,630 --> 00:04:40,060
Nun, was sind
diese algebraischen Datentypen?

00:04:40,060 --> 00:04:42,740
Außerdem, in welchem
Sinne sind sie algebraisch?

00:04:42,740 --> 00:04:43,740
Das klingt etwas mathematisch.

00:04:43,740 --> 00:04:46,980
Und wir werden die
Mathematik dahinter nicht diskutieren.

00:04:46,980 --> 00:04:52,830
Aber ich hoffe, dass trotzdem deutlich wird,
was daran algebraisch ist, sobald wir einige

00:04:52,830 --> 00:04:55,430
Signaturen sehen.

00:04:55,430 --> 00:05:00,150
In erster Näherung könnten wir sagen,
dass algebraische Datentypen etwas sind, was Sie

00:05:00,150 --> 00:05:03,460
vielleicht schon in anderen Sprachen
in irgendeiner Form gesehen haben.

00:05:03,460 --> 00:05:12,060
Man kann sie zum Beispiel als
allgemeinere (und auch strengere, statisch sicherere)

00:05:12,060 --> 00:05:19,400
Versionen dessen sehen, was man als
Aufzählungs- oder Union-Typen kennt (in sehr

00:05:19,400 --> 00:05:21,530
einfachen Formen
algebraischer Datentypen).

00:05:21,530 --> 00:05:29,070
Aber tatsächlich haben moderne Sprachen
wie Swift Funktionen wie *rekursive* Aufzählungstypen,

00:05:29,070 --> 00:05:36,300
die wirklich weit von einfachen
Aufzählungstypen in z.B. C entfernt sind.

00:05:36,300 --> 00:05:41,780
Und diese (rekursive Aufzählungstypen) sind
schon etwas Ähnliches wie algebraische Datentypen.

00:05:41,780 --> 00:05:48,840
Und noch einmal, die Übertragung hier ist nicht, dass
algebraische Datentypen das sind, was Swift hat und dann allgemeiner

00:05:48,840 --> 00:05:49,980
gemacht wird.

00:05:49,980 --> 00:05:50,980
Es ist eigentlich genau andersherum.

00:05:50,980 --> 00:05:55,150
Algebraische Datentypen gibt es schon
seit langer Zeit in funktionalen Sprachen.

00:05:55,150 --> 00:06:02,500
Und dann haben sich Swift und
andere moderne Mainstream-Sprachen davon inspirieren lassen.

00:06:02,500 --> 00:06:06,930
Und letztendlich würde ich sagen, dass algebraische
Datentypen immer noch die schönere Version davon

00:06:06,930 --> 00:06:12,080
sind, während die rekursiven Enum-Typen in Swift
ähnlich sind, aber einige pragmatische Kompromisse gemacht

00:06:12,080 --> 00:06:13,080
haben.

00:06:13,080 --> 00:06:18,960
Sie sind also nicht auf dem gleichen,
sagen wir mal, mathematischen Niveau wie algebraische Datentypen.

00:06:18,960 --> 00:06:28,830
Aber für Anwender, für Sie, wenn Sie diese
verwenden, wird das nicht allzu sehr durchscheinen, denke ich.

130 # slide
00:06:28,830 --> 00:06:31,920
Lassen Sie uns
also ganz einfach anfangen.

00:06:31,920 --> 00:06:35,870
Nehmen wir an, wir wollen
über die Wochentage sprechen können.

00:06:35,870 --> 00:06:39,700
Also, Montag, Dienstag, Mittwoch usw.

00:06:39,700 --> 00:06:45,642
Und auf diesen Daten wollen wir Dinge berechnen wie:
Das ist ein Werktag, ja oder nein, oder eine

00:06:45,642 --> 00:06:52,030
andere Ermittlung, welche Eigenschaften
ein bestimmter Tag hat.

00:06:52,030 --> 00:06:54,990
Wie würden wir dies derzeit tun?

00:06:54,990 --> 00:06:56,610
Wie würden wir das
vielleicht in anderen Sprachen machen?

00:06:56,610 --> 00:06:58,810
Wie würden wir es in Haskell machen?

00:06:58,810 --> 00:07:05,060
Typischerweise könnten wir sagen: Wir legen eine
Kodierung der Wochentage (Montag, Dienstag etc.) als Zahlen

00:07:05,060 --> 00:07:06,060
fest.

00:07:06,060 --> 00:07:07,600
Und selbstverständlich gibt
es einige natürliche Wahlmöglichkeiten.

00:07:07,600 --> 00:07:12,170
Zum Beispiel könnten wir sagen: Montag ist der
erste Tag, Dienstag ist der zweite Tag, usw.

00:07:12,170 --> 00:07:16,860
Wir würden also die Zahlen von 1 bis
7 verwenden, um Montag bis Sonntag zu kodieren.

00:07:16,860 --> 00:07:21,720
Und wenn wir dann Funktionen schreiben wollen, die ausdrücken,
ob ein Tag ein Werktag ist oder eine andere

00:07:21,720 --> 00:07:24,960
Eigenschaft hat, dann könnten wir
eine Funktion wie diese hier schreiben.

00:07:24,960 --> 00:07:27,100
Die Funktion 'workday' geht
also von 'Integer' zu 'Bool'.

00:07:27,100 --> 00:07:32,510
Es ist ein Prädikat auf
'Integer', die als Wochentage interpretiert werden.

00:07:32,510 --> 00:07:34,510
Und wir wollen wissen, ob
ein Tag ein Werktag ist.

00:07:34,510 --> 00:07:40,710
Dann könnten wir natürlich sagen: Wir vergleichen
einfach den Zahlencode dieses Tages mit der 6.

00:07:40,710 --> 00:07:47,050
Die 6 bedeutet Samstag, also ist alles kleinere
ein Tag von Montag bis Freitag, also ein

00:07:47,050 --> 00:07:48,050
Werktag.

00:07:48,050 --> 00:07:51,081
Das ist natürlich möglich.

00:07:51,081 --> 00:07:53,590
In diesem Fall haben wir etwas Glück.

00:07:53,590 --> 00:07:59,050
Die Funktion ist so einfach, dass sie
einfach ein Vergleich ist, denn die Eigenschaft, die

00:07:59,050 --> 00:08:03,210
uns hier interessiert, entspricht wirklich einem Zahlenbereich, in
diesem Fall 1 bis 5, während das Gegenteil

00:08:03,210 --> 00:08:04,840
6 bis 7 wäre.

00:08:04,840 --> 00:08:09,550
Wenn wir also eine so einfache Eigenschaft wie diese
haben, bei der man die Sache, die man wissen

00:08:09,550 --> 00:08:17,169
will, wirklich berechnen kann, indem man Zahlen
gegen Zahlen vergleicht, dann wird dies eine sehr

00:08:17,169 --> 00:08:21,000
einfache Funktion. Aber natürlich muss es nicht immer so
einfach sein, wenn Sie etwas über Tagen berechnen wollen.

131 # slide
00:08:21,160 --> 00:08:32,210
Wir könnten zum Beispiel berechnen wollen, an welchen
Tage der Woche eine Übungsstunde stattfindet

00:08:32,210 --> 00:08:33,210
in dieser Lehrveranstaltung stattfindet.

00:08:33,210 --> 00:08:36,580
Natürlich ist das in diesem Semester vielleicht
nicht so eine nützliche Frage, weil wir keine

00:08:36,580 --> 00:08:38,540
tatsächlichen Übungseinheiten haben.

00:08:38,540 --> 00:08:43,750
Diese Frage stammt eigentlich aus den Folien vom letzten Jahr,
wo das mehr Sinn machte.

00:08:43,750 --> 00:08:53,950
Aber es ist immer noch eine vernünftige Sache: zu wollen
generell eine Eigenschaft an unseren Wochentagen zu haben

00:08:53,950 --> 00:08:55,240
die diese Form hat.

00:08:55,240 --> 00:09:00,230
Wenn wir also bestimmte Wochentage auswählen, die
die Eigenschaft "An diesem Tag findet eine Trainingseinheit

00:09:00,230 --> 00:09:04,270
statt" (oder etwas anderes)
erfüllen.

00:09:04,270 --> 00:09:09,990
Okay, dieses Mal ist die Antwort nicht so einfach...
das Programm ist nicht so einfach wie ein Vergleich

00:09:09,990 --> 00:09:12,460
wie: ist d kleiner als 6 aus der vorherigen
Folie.

00:09:12,460 --> 00:09:13,460
Warum nicht?

00:09:13,460 --> 00:09:18,290
Weil es keine aufeinanderfolgende Reihe von Tagen
gibt, an denen wir Übungen haben und an denen wir

00:09:18,290 --> 00:09:19,290
nicht haben.

00:09:19,290 --> 00:09:21,980
Eine Möglichkeit, diese Eigenschaft zu berechnen, ist zum Beispiel

00:09:21,980 --> 00:09:27,990
(Ich glaube, das stammt aus den Daten des letzten Jahres,
also, wenn es tatsächlich Übungseinheiten gab

00:09:27,990 --> 00:09:28,990
letztes Jahr.

00:09:28,990 --> 00:09:34,560
Und wahrscheinlich hätte derselbe Plan auch dieses Jahr gegolten,
wenn wir einen tatsächlichen Präsenzkurs gehabt hätten).

00:09:34,560 --> 00:09:40,770
Also, man kann hier etwas ausdrücken wie:
Die 3 ist kein Übungstag.

00:09:40,770 --> 00:09:41,950
Er entspricht dem Mittwoch.

00:09:41,950 --> 00:09:45,740
Und am Wochenende gab es letztes Jahr auch keine Übungen.

00:09:45,740 --> 00:09:49,880
Wir könnten also sagen: Am Mittwoch, Samstag,
und Sonntag, haben wir keine Übungen.

00:09:49,880 --> 00:09:51,970
Und an allen Tagen haben wir Übungen.

00:09:51,970 --> 00:09:56,750
Wir haben hier diesen Auffangtatbestand.

00:09:56,750 --> 00:09:58,310
Natürlich können wir das auch schreiben.

00:09:58,310 --> 00:10:03,000
Es ist vielleicht nicht sehr lesbar.

00:10:03,000 --> 00:10:07,839
Da muss man schon etwas nachdenken: Was ist das
3 eigentlich?

00:10:07,839 --> 00:10:12,520
Warum sagen wir, das sind die Falsch-Fälle, und
dann haben wir einen Auffangfall für Wahr?

00:10:12,520 --> 00:10:14,760
Warum machen wir es nicht andersherum?

00:10:14,760 --> 00:10:16,430
Außerdem können wir wieder Fehler machen, die nicht von der Hand zu weisen sind.

00:10:16,430 --> 00:10:22,470
Wenn ich mir also nicht sicher bin, wie meine Kodierung funktioniert:
Je nachdem, ob ich mit der Zählung des Montags

00:10:22,470 --> 00:10:27,510
bei 1 oder bei 0 beginne, könnte ich leicht falsch interpretieren
was hier geschieht.

00:10:27,510 --> 00:10:32,330
Aber natürlich, wenn ich eine feste Kodierung habe wie:
Montag beginnt bei 1, usw..., dann ist das

00:10:32,330 --> 00:10:35,380
eine Möglichkeit, die Eigenschaft zu implementieren.

00:10:35,380 --> 00:10:44,391
Wir könnten auch versuchen, dies scheinbar effizienter zu
machen, indem wir etwas sagen wie: Vielleicht

00:10:44,391 --> 00:10:48,460
Ich kann immer noch einen Vergleich anstellen, indem ich zuerst
alle Wochenendtage ausschließen.

00:10:48,460 --> 00:10:53,520
Vielleicht kann ich einen Guard verwenden, der sagt: Wenn der Tag
mehr als 6 ist, oder wenn er größer als 5 ist,

00:10:53,520 --> 00:10:54,980
dann ist es definitiv kein Übungstag.

00:10:54,980 --> 00:10:58,170
Ich könnte hier also tatsächlich verschiedene Definitionen schreiben.

00:10:58,170 --> 00:11:02,860
Aber es ist nicht klar, dass die Arbeit mit diesen
Vergleichen und Zahlen wirklich zu einer

00:11:02,860 --> 00:11:06,500
schönen Art wird, diese Funktion auszudrücken.

00:11:06,500 --> 00:11:15,339
Außerdem besteht eine weitere Gefahr, wenn man diesen Typ "Integer
→ Bool", denn 'Integer' ist ein viel größerer

00:11:15,339 --> 00:11:19,279
Typ ist als nur 1 bis 7, den ich für
meine Wochentage.

00:11:19,279 --> 00:11:23,970
Nehmen wir also an, ich hätte eine Funktion wie diese...
eigentlich die Funktion aus der vorherigen Folie.

00:11:23,970 --> 00:11:29,730
Die Frage ist: Was passiert, wenn ich die
exerciseDay-Funktion mit einer Eingabe wie

00:11:29,730 --> 00:11:30,790
12 aufrufe?

00:11:30,790 --> 00:11:33,200
Das kann ich tun, weil 12 eine Ganzzahl ist.

00:11:33,200 --> 00:11:36,649
Dann ist natürlich die Frage: Was macht
sie?

00:11:36,649 --> 00:11:42,680
Sie berechnet etwas wie: im "workday"
aus der vorigen Folie würde es Folgendes berechnen

00:11:42,680 --> 00:11:48,220
Falsch, weil der Vergleich "d<6" war,
also wird aus irgendeinem Grund der 12. Tag der Woche,

00:11:48,220 --> 00:11:51,590
den es gar nicht gibt, kein Arbeitstag ist.

00:11:51,590 --> 00:11:58,860
Für die hier beschriebene Funktion 'exerciseDay' hingegen
für die Eingabe 12 sagen würde: Es ist ein

00:11:58,860 --> 00:12:00,610
exerciseDay, aus welchem Grund auch immer.

00:12:00,610 --> 00:12:04,820
Der Grund dafür ist, dass sie in diesen Auffangfall
Fall hier.

00:12:04,820 --> 00:12:07,290
Sie würde True zurückgeben, aber das hat keine
eine sinnvolle Interpretation.

00:12:07,290 --> 00:12:14,190
Und wenn ich versuchen würde, diese Funktion auf andere Weise umzuschreiben,
vielleicht mit einem Abgleich auf die Übungstage,

00:12:14,190 --> 00:12:18,950
anstatt einen Auffangfall zu haben,
oder das für False zu tun, dann wäre plötzlich der 12.

00:12:18,950 --> 00:12:21,149
Tag der Woche kein Übungstag sein.

00:12:21,149 --> 00:12:25,610
Aus Sicht der Wochentage macht es also nicht wirklich
Sicht der Wochentage nicht wirklich sinnvoll.

00:12:25,610 --> 00:12:34,220
Die Tage haben also nicht die Eigenschaft, dass
es einen 12. Wochentag oder etwas Ähnliches gibt.

00:12:34,220 --> 00:12:41,399
Hier ist etwas faul, und
es hat mit dieser naiven Kodierung/Verwendung

00:12:41,399 --> 00:12:45,149
von Zahlen für Wochentage zu tun.

00:12:45,149 --> 00:12:46,390
Das ist nicht sehr abstrakt.

00:12:46,390 --> 00:12:47,880
Es ist zu niedrigschwellig.

132 # slide
00:12:47,880 --> 00:12:54,030
Was ist also eine Alternative?

00:12:54,030 --> 00:13:01,360
In Haskell können wir zum Beispiel etwas
wie dieses definieren, das neue Werte eines

00:13:01,360 --> 00:13:02,360
neuen Typs einführt.

00:13:02,360 --> 00:13:06,580
Hier sagen wir also: Wir führen einen Datentyp ein.

00:13:06,580 --> 00:13:08,310
Er bekommt einen Namen Day.

00:13:08,310 --> 00:13:13,140
Das ist also nicht so etwas wie Picture, etwas
das wir in anderen Typen als Argumente verwenden können

00:13:13,140 --> 00:13:14,740
oder Ergebnisse von Funktionen.

00:13:14,740 --> 00:13:19,570
Und dann führen wir auch ein, welche Werte dieser
neue Typ Day hat.

00:13:19,570 --> 00:13:26,600
Und er hat die neuen Werte: Montag, Dienstag,
Mittwoch, usw. bis hin zu Sonntag.

00:13:26,600 --> 00:13:34,180
Und dann können wir diese neuen Konstanten verwenden in
Berechnungen, als Rückgabewerte von Funktionen,

00:13:34,180 --> 00:13:35,180
usw.

00:13:35,180 --> 00:13:39,250
Auf den ersten Blick sieht das aus wie ein Union-Typ
oder ein Aufzählungstyp.

00:13:39,250 --> 00:13:41,480
Sogar so etwas wie C hat so etwas.

00:13:41,480 --> 00:13:48,910
Der Unterschied ist zum Beispiel, dass Aufzählungstypen
Typen in C durch die Einführung von Namen

00:13:48,910 --> 00:13:49,910
Konstanten einführen.

00:13:49,910 --> 00:13:54,430
Wenn wir also etwas wie dieses mit der
Syntax, die C für Aufzählungstypen erlaubt,

00:13:54,430 --> 00:13:58,450
dann sind wir eigentlich wieder bei demselben Ansatz
wie auf den vorherigen Folien.

00:13:58,450 --> 00:14:06,280
Dann wäre Day im Grunde nur ein anderer
/ ein Tarnname für 'Integer' oder einen anderen

00:14:06,280 --> 00:14:09,339
Basistyp, und Montag wäre eine Konstante
(0 oder 1).

00:14:09,339 --> 00:14:14,380
Es würde also wieder davon abhängen, ob C entscheidet
die Dinge zu zählen.

00:14:14,380 --> 00:14:19,100
Es könnte mit der Zählung bei 0 oder 1 beginnen, aber eigentlich,
würde man letztlich einfach neue

00:14:19,100 --> 00:14:21,040
benannte Konstanten einführen, die Integer-Konstanten sind.

00:14:21,040 --> 00:14:25,640
Sie würden diese Namen haben, aber unter der
Haube wären sie immer noch 1,2,3,4,5 oder etwas

00:14:25,640 --> 00:14:26,820
oder so ähnlich.

00:14:26,820 --> 00:14:28,831
Das ist hier nicht der Fall.

00:14:28,831 --> 00:14:32,779
Was hier wirklich passiert, ist, dass der Typ
der durch diese Definition eingeführt wird, ein

00:14:32,779 --> 00:14:35,589
völlig neuer Typ ist, der sich von allen
anderen Typen in der Sprache.

00:14:35,589 --> 00:14:38,420
Es handelt sich also nicht um einen Integer-Typ oder eine Umbenennung
des Integer-Typs.

00:14:38,420 --> 00:14:43,050
Es handelt sich wirklich um etwas völlig Neues, und
der Compiler erlaubt nun zum Beispiel,

00:14:43,050 --> 00:14:46,500
diese Konstanten als Zahlen zu verwenden, weil
sie keine Zahlen sind.

00:14:46,500 --> 00:14:51,300
Sie sind neue Werte des neuen Typs, der
in dieser Deklaration eingeführt wurde.

00:14:51,300 --> 00:14:57,380
Sie sind also völlig unabhängig von allem
bereits in der Sprache oder im Code des Benutzers existierenden.

00:15:02,380 --> 00:15:04,399
Und wie würden wir dann damit rechnen?

00:15:04,399 --> 00:15:08,470
Zum Beispiel könnte unsere exerciseDay-Funktion
wie folgt aussehen.

00:15:08,470 --> 00:15:12,780
Sie würde natürlich nicht mehr von Integer
zu Bool, sondern von diesem neuen Typ Day zu Bool.

00:15:12,780 --> 00:15:15,820
Deshalb verwenden wir hier den Typnamen.

00:15:15,820 --> 00:15:18,850
Das, was links von diesem Gleichheitszeichen steht
ist der Name des Typs.

00:15:18,850 --> 00:15:21,100
Und auf der rechten Seite haben wir die Wertnamen.

00:15:21,100 --> 00:15:25,550
Day kann hier also als Typname vorkommen, und
dann haben wir eine Eigenschaft.

00:15:25,550 --> 00:15:26,950
Wir geben also 'Bool' zurück.

00:15:26,950 --> 00:15:34,029
Und wenn wir unsere Definition der Funktion angeben,
erwähnen wir hier nicht 2 oder 3 oder 6 oder 7,

00:15:34,029 --> 00:15:38,579
oder so etwas in der Art, sondern wir erwähnen tatsächlich
die Konstanten, die wir für diesen neuen

00:15:38,579 --> 00:15:39,579
Typ eingeführt haben.

00:15:39,579 --> 00:15:41,110
Also, exerciseDay Mittwoch ist False.

00:15:41,110 --> 00:15:42,339
Samstag ist False.

00:15:42,339 --> 00:15:43,570
Sonntag ist False.

00:15:43,570 --> 00:15:44,570
Alles andere ist True.

00:15:44,570 --> 00:15:47,360
Natürlich stellt sich hier die Frage: Was ist alles
anderes?

00:15:47,360 --> 00:15:52,209
Nun, alles andere sind genau die vier
Werte, die hier erwähnt werden und die

00:15:52,209 --> 00:15:54,230
auf den vorherigen drei Folien nicht behandelt wurden.

00:15:54,230 --> 00:16:01,140
Also, es gibt keinen 12. Wochentag in
dieser Interpretation, denn es gibt

00:16:01,140 --> 00:16:04,260
keinen 8., 9. oder 10. Wert gibt.

00:16:04,260 --> 00:16:06,279
Dies sind keine Ganzzahlen.

00:16:06,279 --> 00:16:09,680
Das sind nicht einfach nur Indizes.

00:16:09,680 --> 00:16:14,770
Nein, wir haben genau sieben Werte von diesem Typ
wie hier eingeführt.

00:16:14,770 --> 00:16:20,660
Und alles, was in diesen anonymen
Platz kommen könnte, wären die, die hier noch nicht

00:16:20,660 --> 00:16:21,839
behandelt wurden.

00:16:21,839 --> 00:16:28,250
Es ist also einfach illegal, aus der Sicht des Compilers
Perspektive bereits, etwas anderes zu übergeben

00:16:28,250 --> 00:16:30,899
als einen dieser sieben Tage.

00:16:30,899 --> 00:16:34,890
Natürlich würde jemand sagen: Wir verlieren einige
Möglichkeiten.

00:16:34,890 --> 00:16:37,760
Also, zum Beispiel können wir jetzt nicht mehr mit
Zahlen rechnen.

00:16:37,760 --> 00:16:40,950
Also, wenn man den Wochenendtag einführen will...

00:16:40,950 --> 00:16:49,920
Wenn man also mit der Funktion Werktag prüfen will,
ob es ein Arbeitstag ist, können wir jetzt nicht

00:16:49,920 --> 00:16:54,120
etwas berechnen wie: gib mir den Tag, und
dann vergleiche ich, ob er kleiner ist als

00:16:54,120 --> 00:16:55,120
6.

00:16:55,120 --> 00:16:56,990
Das ergibt keinen Sinn, denn das sind
keine Zahlen mehr sind.

00:16:56,990 --> 00:17:02,230
Wir verlieren einige Tricks, die wir mit enum
Typen in C machen können, zum Beispiel das Wissen, dass sie

00:17:02,230 --> 00:17:06,279
letztlich nur Zahlen sind, aber diese Tricks
sind einfach Tricks.

00:17:06,279 --> 00:17:09,749
Sie sind keine gut zu pflegende Art der Programmierung.

00:17:09,749 --> 00:17:12,669
Ich würde das also nicht einmal einen Vorteil nennen
den wir verlieren.

00:17:12,669 --> 00:17:19,640
Es ist einfach deklarativer und klarer
dass es sich um neue Werte eines neuen Typs handelt, und

00:17:19,640 --> 00:17:23,890
wir nicht mit ihnen rechnen können durch "+" oder
"-" oder "<" usw. rechnen können, weil Wochentage

00:17:23,890 --> 00:17:26,069
nicht auf diese Weise funktionieren.

00:17:26,069 --> 00:17:32,869
Sie sind keine Zahlen, also sollten wir sie auch nicht
wie Zahlen behandeln, wie es eine weniger streng typisierte Sprache

00:17:32,869 --> 00:17:34,210
tut.

00:17:34,210 --> 00:17:38,809
Dann gibt es noch ein weiteres Problem oder eine Sorge, die
sich an dieser Stelle aufdrängt.

00:17:38,809 --> 00:17:42,789
Man könnte also denken: Der C-Ansatz muss
viel effizienter sein.

00:17:42,789 --> 00:17:48,049
Diese Dinge einfach als Zahlen zu kodieren und
dann mit Zahlen zu rechnen, ist natürlich viel

00:17:48,049 --> 00:17:52,889
effizienter als dieser Ansatz, bei dem
wir diese neuen Strings einführen und dann vergleichen

00:17:53,889 --> 00:17:57,759
Bedeutet das, dass ich zwei Strings der Länge 8 oder so ähnlich

00:17:57,759 --> 00:18:00,539
vergleichen muss, anstatt einfach etwas
mit der Zahl 6 zu vergleichen?

00:18:00,539 --> 00:18:01,539
Nun... nein.

00:18:01,539 --> 00:18:02,980
Das ist nur das, was an der Oberfläche dieser
Sprache.

00:18:02,980 --> 00:18:05,070
Das ist nicht das, was in der Implementierung passiert.

00:18:05,070 --> 00:18:11,830
Sie müssen sich keine Sorgen machen, dass diese irgendwie
als Strings gespeichert werden, und dann zur Laufzeit

00:18:11,830 --> 00:18:16,159
einige dieser Strings verglichen werden mit
einige dieser Strings oder ähnliches verglichen werden.

00:18:16,159 --> 00:18:18,919
Natürlich macht der Compiler einen effizienteren
Code daraus.

00:18:18,919 --> 00:18:23,289
Unter der Haube handelt es sich also nicht um einen String-Vergleich.

00:18:23,289 --> 00:18:29,609
Das bedeutet auch, dass Sie nicht einmal versuchen
müssen, die Namen Ihrer Werte kurzzuhalten,

00:18:29,609 --> 00:18:32,619
in der Hoffnung, dass dies das Programm effizienter
macht.

00:18:32,619 --> 00:18:34,809
Das ist völliger Blödsinn.

00:18:34,809 --> 00:18:38,019
Man muss uns beibringen, dass es so nicht funktioniert.
das funktioniert.

00:18:38,019 --> 00:18:42,840
Das ist etwas, was der Compiler und der
Programmierer sehen (diese Namen), aber die Maschine

00:18:42,840 --> 00:18:46,639
wird diese Namen im kompilierten Code nie sehen.

00:18:46,639 --> 00:18:50,679
Unter der Haube wird dies in etwas umgewandelt
das der C-Methode ähnelt, bei der es sich gewissermaßen um

00:18:50,679 --> 00:18:54,710
Zahlen in gewissem Sinne.

00:18:54,710 --> 00:18:58,350
Aber das ist nichts, womit sich der Programmierer
befassen muss, oder dem Programmierer

00:18:58,350 --> 00:19:02,629
überhaupt bewusst sein sollte, denn das würde nur
zu Missbrauch führen.

00:19:02,629 --> 00:19:09,359
Das ist etwas, was man bedenken muss, dass diese
keine Strings sind und es findet kein String-Vergleich

00:19:09,359 --> 00:19:12,220
statt.

00:19:12,220 --> 00:19:21,980
Und eine weitere Sache, die man im Auge behalten sollte,
nämlich, dass es sich um unterschiedliche Entitäten handelt.

00:19:21,980 --> 00:19:26,609
Was also auf der linken Seite einer solchen Definition erscheint
hier steht, steht nicht auf der rechten Seite.

00:19:26,609 --> 00:19:33,210
Es sind völlig unterschiedliche Dinge, auch
in Bezug auf ihre Rolle in der Sprache.

00:19:33,210 --> 00:19:36,519
Das, was hier links auftaucht, heißt also
ein Typ-Konstruktor.

00:19:36,519 --> 00:19:40,490
Wir konstruieren einen neuen Typ, wenn wir eine
Definition wie diese einführen.

00:19:40,490 --> 00:19:44,690
Und was wir auf der rechten Seite haben, nennt man Daten
Konstruktoren.

00:19:44,690 --> 00:19:50,049
Sie konstruieren Daten, sie konstruieren Werte
die einen Typ haben, in diesem Fall den Typ, der

00:19:50,049 --> 00:19:51,049
hier konstruiert wird.

00:19:51,049 --> 00:19:54,859
Es sind also verschiedene Entitäten: Typkonstruktoren,
Datenkonstrukteure.

00:19:54,859 --> 00:19:57,539
Sie leben zufällig in verschiedenen Namensräumen.

00:19:57,539 --> 00:20:05,570
Es gibt also keine Verwirrung, wenn Sie denselben
Bezeichner für den Typkonstruktor und den

00:20:05,570 --> 00:20:06,570
Datenkonstruktor verwenden.

00:20:06,570 --> 00:20:07,990
Sie müssen also in Großbuchstaben geschrieben werden, wie wir bereits
hier sehen.

00:20:07,990 --> 00:20:10,370
Diese Bezeichner müssen also in Großbuchstaben geschrieben werden.

00:20:10,370 --> 00:20:14,830
Das unterscheidet sie z.B. von,
Funktionsnamen, die kleingeschrieben werden müssen.

00:20:14,830 --> 00:20:21,989
Theoretisch könnte man aber denselben Bezeichner in Großbuchstaben
sowohl als Typname als auch als Wert

00:20:21,989 --> 00:20:22,989
Namen verwenden.

00:20:22,989 --> 00:20:27,330
Dies wird normalerweise nicht empfohlen, es sei denn
es gibt besondere Gründe dafür.

00:20:27,330 --> 00:20:34,630
Wir werden in der Vorlesung davon absehen, dies zu tun,
aber Sie sollten sich bewusst sein, dass theoretisch

00:20:34,630 --> 00:20:42,229
derselbe Name hier und hier verwendet werden könnte, oder
sogar hier als Name eines Datenkonstruktors

00:20:42,229 --> 00:20:43,450
in einem anderen Typ.

00:20:43,450 --> 00:20:47,320
Das kann natürlich zu Verwirrung führen.

00:20:47,320 --> 00:20:54,029
Wir werden das normalerweise nicht tun, aber der
Compiler wird sich nicht darüber beschweren, weil

00:20:54,029 --> 00:21:04,499
es in der Sprache zulässig ist, denselben
Bezeichner an einer solchen Stelle und an einer solchen Stelle zu verwenden.

133 # slide
00:21:04,499 --> 00:21:11,210
Auf der vorherigen Folie habe ich dieses Beispiel erwähnt
mit dem 12. Tag, der natürlich als Wochentag

00:21:11,210 --> 00:21:19,940
betrachtet wird, und dank der Einführung
dieses neuen Typs wurde diese absurde Eingabe ausgeschlossen.

00:21:19,940 --> 00:21:21,889
Das war eine schöne statische Garantie.

00:21:21,889 --> 00:21:29,460
Und es gibt noch weitere Vorteile der Verwendung
dieses expliziten Typansatzes anstelle von einfachen

00:21:29,460 --> 00:21:30,460
Zahlencodes.

00:21:30,460 --> 00:21:34,940
Zum Beispiel erhalten wir auch mehr Vollständigkeit
und Redundanzprüfung.

00:21:34,940 --> 00:21:39,999
Das ist etwas, worüber wir gesprochen haben, als wir
über die Fallunterscheidung in Haskell

00:21:39,999 --> 00:21:40,999
Code gesprochen haben.

00:21:40,999 --> 00:21:47,720
Lassen Sie uns also darüber nachdenken, und zwar
dem Level-Beispiel, das wir in den Übungen hatten.

00:21:47,720 --> 00:21:49,360
Erinnern Sie sich, da war diese Funktion.

00:21:49,360 --> 00:21:53,379
Sie wurde als eine Beschreibung einer Ebene interpretiert.

00:21:53,379 --> 00:21:56,960
Anhand einiger Koordinaten gab sie also eine
Ganzzahl zurück.

00:21:56,960 --> 00:22:01,220
Und dieser Integer-Code wurde als Block, Wasser,
Perle, usw.

00:22:01,220 --> 00:22:09,789
Wir haben diese aTile-Funktion, die diese
Zahlencodes auf tatsächliche Bilder abbildet.

00:22:09,789 --> 00:22:11,889
Das birgt natürlich schon eine gewisse Gefahr.

00:22:11,889 --> 00:22:14,360
Wir können hier leicht Dinge verwechseln.

00:22:14,360 --> 00:22:19,229
Also, wenn jemand die Level-Funktion schreibt,
ist es vielleicht nicht immer klar / er hat vielleicht

00:22:19,229 --> 00:22:22,299
nicht immer im Kopf haben, was genau
wofür steht.

00:22:22,299 --> 00:22:27,330
Manchmal schreiben sie vielleicht 3 statt 2
weil 2 und 3 einfach nur Zahlen sind.

00:22:27,330 --> 00:22:30,450
Sie sind keine wirklich schönen deklarativen Namen
für Dinge.

00:22:30,450 --> 00:22:32,019
"level" hat keine "2".

00:22:32,019 --> 00:22:33,539
"level" hat "water" oder "pearl"
oder was auch immer.

00:22:33,539 --> 00:22:40,950
In diesem Sinne ist das schon etwas unglücklich,
was wir bis jetzt gemacht haben, entspricht der

00:22:40,950 --> 00:22:43,859
Darstellung der Wochentage durch 1,2,3,...

00:22:43,859 --> 00:22:48,429
Natürlich kann man sich an dieser Stelle schon
vorstellen, dass es wahrscheinlich eine gute Idee wäre

00:22:48,429 --> 00:22:53,169
auch hier einen Aufzählungstyp zu verwenden, ähnlich wie
bei den Wochentagen.

00:22:53,169 --> 00:22:59,359
Aber eigentlich gibt es noch einen weiteren Grund
zur Sorge bei einer Funktion wie dieser, nämlich,

00:22:59,359 --> 00:23:00,359
Erweiterbarkeit.

00:23:00,359 --> 00:23:03,830
Nehmen wir also an, wir wollen unsere
Levels reicher machen.

00:23:03,830 --> 00:23:11,269
Wir haben eine neue Idee für unser Spiel, und wir
führen eine neue Art von Spielstein ein, vielleicht einen Spike,

00:23:11,269 --> 00:23:12,659
der irgendwo sein kann.

00:23:12,659 --> 00:23:17,710
Wir werden also den Wert 5 dafür verwenden
denn 5 scheint noch nicht verwendet zu werden.

00:23:17,710 --> 00:23:23,210
Also schreiben wir jetzt level-Funktionen, die
irgendwo eine 5 zurückgegeben werden, die für

00:23:23,210 --> 00:23:28,260
"spike" stehen soll, aber eigentlich
vergessen wir diesen zusätzlichen Fall in der aTile

00:23:28,260 --> 00:23:32,769
Funktion hinzuzufügen, oder vielleicht hat jemand in unserem Team, der
dafür verantwortlich ist, vergisst einfach, hier

00:23:32,769 --> 00:23:34,359
einen neuen Fall hinzuzufügen.

00:23:34,359 --> 00:23:35,710
Was würde dann passieren?

00:23:35,710 --> 00:23:37,399
Der Compiler würde uns nicht davor warnen.

00:23:37,399 --> 00:23:41,109
Wir möchten vom Compiler gewarnt werden, wenn
mögliche Fehler in unserem Code.

00:23:41,109 --> 00:23:47,840
Aber wenn ich hier 5 produziere, aber auch vergesse
die Funktion aTile anzupassen, dann hat der Compiler

00:23:47,840 --> 00:23:49,690
keine Chance, mich zu warnen.

00:23:49,690 --> 00:23:50,690
Warum nicht?

00:23:50,690 --> 00:23:55,409
Weil die 5 in diesen letzten Fall hineinlaufen wird.

00:23:55,409 --> 00:24:00,799
Also, obwohl ich meine 5 in meiner
Level-Funktion hinzufüge, wird der Zeichencode einfach,

00:24:00,799 --> 00:24:06,419
nichts für diese Positionen zeichnen, weil
wir hier auf diesen "blank" Fall stoßen.

00:24:06,419 --> 00:24:08,820
Dieser "leere" Fall machte vorher Sinn, richtig?

00:24:08,820 --> 00:24:14,030
Denn in unseren Beispielen in der Übung waren die
hatten wir nur die Zahlencodes 0 bis 4, und

00:24:14,030 --> 00:24:19,659
0 sollte für "nichts" stehen,
also würde die 0 natürlich auf diesen letzten Fall treffen,

00:24:19,659 --> 00:24:21,070
dann würde "blank" genommen werden.

00:24:21,070 --> 00:24:27,330
Wenn wir nun aber die Level-Funktion erweitern
und vergessen diese Änderung in der aTile

00:24:27,330 --> 00:24:30,759
Funktion, dann haben wir plötzlich auch "blank"
für unsere neue Stelle, an der wir eigentlich

00:24:30,759 --> 00:24:31,759
Spikes haben wollen.

00:24:31,759 --> 00:24:38,639
Nun könnte man sagen: Das ist der Fehler in unserem
ursprünglichen Entwurf für die aTile-Funktion.

00:24:38,639 --> 00:24:42,809
Wir hätten den "_" (Unterstrich) nicht schreiben sollen,
wir hätten hier 0 schreiben sollen, dann würde der Compiler

00:24:42,809 --> 00:24:44,090
würde das sicherlich erkennen...

00:24:44,090 --> 00:24:50,549
Zumindest zur Laufzeit würde er nicht leer zeichnen
denn 5 würde auf keinen dieser Fälle passen.

00:24:50,549 --> 00:24:54,879
Also würde man zumindest zur Laufzeit einen
Fehler statt dieses seltsamen leeren Bildes bekommen.

00:24:54,879 --> 00:25:01,169
Dies könnte man erreichen, indem man
hier in der ursprünglichen Version einfach eine "0" schreibt.

00:25:01,169 --> 00:25:04,269
Aber das hat natürlich auch seine Nachteile
denn dann würde sich der Compiler darüber beschweren

00:25:04,269 --> 00:25:05,929
dass dies keine erschöpfende Funktion ist.

00:25:05,929 --> 00:25:11,080
Und der Compiler hätte recht, denn
wenn man nur sagt, die Funktion aTile geht von

00:25:11,080 --> 00:25:15,789
Integer nach Picture, und dann gibt man nur
Fälle für 0,1,2,3,4, dann haben wir keine

00:25:15,789 --> 00:25:17,880
Funktion im mathematischen Sinne geschrieben.

00:25:17,880 --> 00:25:19,090
Und warum ist das so?

00:25:19,090 --> 00:25:21,929
Weil die Integer-Größe viel zu groß ist.

00:25:21,929 --> 00:25:24,950
Der Level gibt keinen 'Integer' an, er gibt
eine Kachel.

00:25:24,950 --> 00:25:30,529
Wir sollten also einen beschreibenderen, einen aussagekräftigeren
Typ verwenden.

00:25:30,529 --> 00:25:31,529
Und was könnte das sein?

00:25:31,529 --> 00:25:32,879
Ein Zahlentyp kann es nicht sein.

00:25:32,879 --> 00:25:41,409
Es sollte eine Aufzählung sein oder ein algebraischer
Datentyp sein.

134 # slide
00:25:41,409 --> 00:25:48,450
So könnte es also aussehen, wenn Sie
einen neuen Typ namens Tile einführt, und wir führen

00:25:48,450 --> 00:25:55,279
einige Konstanten dieses Typs einführen, und wir führen
genau eine Konstante für jede Art von Kachel

00:25:55,279 --> 00:25:59,980
die wir haben wollen: Blank (nichts), Block, Pearl, Water,
Luft.

00:25:59,980 --> 00:26:01,649
Dies hat einen klaren Dokumentationswert.

00:26:01,649 --> 00:26:09,019
Außerdem kann es von nun an keine Verwirrung mehr geben
in Bezug auf Zahlencodes geben, also, was ist was?

00:26:09,019 --> 00:26:10,019
Ist die 2 die Perle?

00:26:10,019 --> 00:26:11,019
oder ist die 3 die Perle?

00:26:11,019 --> 00:26:14,119
Es gibt also keine Nummerncodes mehr, wir
haben diese beschreibenden Namen.

00:26:14,119 --> 00:26:17,419
Und die werden in allen unseren Funktionen verwendet.

00:26:17,419 --> 00:26:20,009
Das bedeutet auch, dass die Reihenfolge nicht relevant ist.

00:26:20,009 --> 00:26:26,000
Die Reihenfolge ist auch nicht relevant, wenn wir diese Dinge
hier auflisten, denn es sind keine Zahlen

00:26:26,000 --> 00:26:32,009
beteiligt und die Reihenfolge ist auch nicht relevant, wenn
wir Fälle für diese Konstanten in unseren

00:26:32,009 --> 00:26:33,309
Funktionsdefinitionen schreiben.

00:26:33,309 --> 00:26:38,769
Sagen wir also, wir verwenden diesen Typ, dann
hätte unsere level-Funktion natürlich diesen

00:26:38,769 --> 00:26:39,769
Typ.

00:26:39,769 --> 00:26:42,210
Sie geht nicht von (Integer, Integer) nach
Integer, sondern eher von (Integer, Integer)

00:26:42,210 --> 00:26:43,210
zu Tile.

00:26:43,210 --> 00:26:44,470
Das macht die Rollen auch viel klarer.

00:26:44,470 --> 00:26:48,720
Es handelt sich also weiterhin um Integer, da es sich um
Koordinaten sind, aber was dabei herauskommt, ist nicht nur

00:26:48,720 --> 00:26:49,720
eine Zahl.

00:26:49,720 --> 00:26:55,330
Es ist ein Tile, denn das ist es, was die Ebene
ist: Bei Positionen gibt sie uns eine Beschreibung

00:26:55,330 --> 00:26:58,190
dessen, was sich an dieser Position befindet.

00:26:58,190 --> 00:27:06,659
Es ist also der Typ unserer level-Funktion,
und eine Tile-Funktion sieht dann so aus.

00:27:06,659 --> 00:27:09,309
Sie geht nicht von 'Integer' zu Picture, sondern
von Tile zu Picture.

00:27:09,309 --> 00:27:11,870
Und natürlich ist die Zuweisung hier sehr einfach.

00:27:11,870 --> 00:27:18,369
Außerdem brauchen wir keinen Catch-All-Fall, weil
wir genau fünf Werte vom Typ Tile haben.

00:27:18,369 --> 00:27:25,129
Wenn Sie also eine Definition, eine Zeile, für
jede dieser Konstanten angeben, dann ist dies eine vollständige

00:27:25,129 --> 00:27:29,890
Definition und der Compiler
wird herausfinden, dass dies eine Nicht-Redundanz ist,

00:27:29,890 --> 00:27:33,450
sondern eine vollständige Definition von Funktionen des
dieses Typs ist.

00:27:33,450 --> 00:27:38,159
Es besteht also keine Notwendigkeit für einen Auffangtatbestand
wie im vorigen Fall, wo dies tatsächlich

00:27:38,159 --> 00:27:47,460
zu Problemen führte, als wir unsere
Unterstützung/Spektrum der Dinge, die Fliesen sein können, erweitern wollten.

00:27:47,460 --> 00:27:51,690
Was würde nun passieren, wenn wir Folgendes einführen wollten
eine neue Kachel einführen wollen, wie die Spike-Sache?

00:27:51,690 --> 00:27:53,850
Dann müssten wir sie zu diesem Typ hinzufügen.

00:27:53,850 --> 00:27:57,809
Andernfalls wäre es nicht möglich, sie
im Level zurückzugeben.

00:27:57,809 --> 00:28:01,950
Wir können also nichts bei der level-Funktion zurückgeben,
was nicht zu diesem Typ gehört.

00:28:01,950 --> 00:28:06,769
Wenn wir also Spikes haben wollen, dann führen wir
einen neuen Fall von Spikes hier ein, dann können wir

00:28:06,769 --> 00:28:14,879
in der Level-Funktion verwenden
und es kann uns nicht passieren, dass wir vergessen zu deklarieren oder zu beschreiben

00:28:14,879 --> 00:28:17,240
wie das in der aTile-Funktion zu behandeln ist.

00:28:17,240 --> 00:28:18,240
Warum?

00:28:18,240 --> 00:28:23,309
Weil, wenn ich Spike zu diesem Typ hinzufüge, aber ich
aber vergesse, in der aTile-Funktion auch einen Fall für ihn hinzuzufügen,

00:28:23,309 --> 00:28:25,450
dann wird sich der Compiler beschweren.

00:28:25,450 --> 00:28:26,450
Der Compiler wird mir helfen.

00:28:26,450 --> 00:28:29,309
Er wird warnen, wenn wir einen neuen Wert vergessen.

00:28:29,309 --> 00:28:34,341
Also, alles muss passen: Wenn ich
hier verwenden will, muss ich es zum

00:28:34,341 --> 00:28:36,019
Typ hinzufügen, dann kann ich es hier verwenden.

00:28:36,019 --> 00:28:40,190
Aber dann kann ich auch nicht vergessen, es hier zu behandeln
denn der Compiler würde sich darüber

00:28:40,190 --> 00:28:41,190
beschweren.

00:28:41,190 --> 00:28:48,299
Das ist der Wert dieser
Art der Überprüfung.

00:28:48,299 --> 00:28:51,639
Und diese Prüfungen, die jetzt möglich sind: sowohl
auf Vollständigkeit und auf Redundanz mögen

00:28:51,639 --> 00:28:57,049
in einer einfachen Funktion wie dieser trivial erscheinen,
aber im großen Maßstab, in größeren Programmen, in größeren

00:28:57,049 --> 00:29:02,480
Bibliotheken mit vielen Funktionen mit komplizierten
Invarianten, kann dies sehr wichtig sein.

00:29:02,480 --> 00:29:08,999
Also, alles was wir tun können, damit der
Compiler bei der Erkennung von Inkonsistenzen zu helfen

00:29:08,999 --> 00:29:10,140
ist wertvoll.

00:29:10,140 --> 00:29:15,869
Und die Definition unserer eigenen Typen und ihre Verwendung
in sinnvoller Weise in unseren Funktionen, sowohl

00:29:15,869 --> 00:29:20,799
für Ausgaben als auch für Eingaben, ist ein Weg, dies
zu erreichen.

00:29:20,799 --> 00:29:26,059
Nun könnten Sie sich bei diesem sehr einfachen Beispiel
vielleicht auch Fragen: Wozu das Ganze?

00:29:26,059 --> 00:29:31,090
Es sieht sehr trivial aus, wenn man "Blank"
mit "blank", "Block" mit "block",

00:29:31,090 --> 00:29:32,090
usw...

00:29:32,090 --> 00:29:35,580
Warum lassen wir nicht einfach unsere level-Funktion
stattdessen Bilder zurückgeben?

00:29:35,580 --> 00:29:39,071
Dann können wir die ganze Sache vergessen, und die
Level-Funktion würde einfach sagen: bei zwei

00:29:39,071 --> 00:29:45,059
Integer, ich gebe dir ein Bild, und dann,
anstatt den konstanten Großbuchstaben

00:29:45,059 --> 00:29:47,779
Block zurückzugeben, würde sie einfach den Picture
Block zurückgeben.

00:29:47,779 --> 00:29:53,529
Das wäre ein vernünftiger Entwurf, könnte man meinen.
denken, aber es würde eine Menge Potenzial

00:29:53,529 --> 00:29:56,960
für Manipulationen verlieren, weil Sie auch
diese level-Funktion als Daten verwenden wollen.

00:29:56,960 --> 00:29:57,960
Sie haben das schon gesehen.

00:29:57,960 --> 00:30:03,269
Wir hatten diese Übungsaufgabe, bei der Sie
zwei level-Funktionen und Sie sollten entscheiden

00:30:03,269 --> 00:30:08,859
welche davon kleiner oder dichter besiedelt ist.
bevölkert ist.

00:30:08,859 --> 00:30:10,109
Und was haben Sie da gemacht?

00:30:10,109 --> 00:30:15,779
Ihr habt diese level-Funktionen auf einige
Koordinaten angewendet und ihre Ergebnisse verglichen.

00:30:15,779 --> 00:30:21,039
Nun, das ist auch mit Zahlen möglich, aber Zahlen
haben aber einen Nachteil, wie auf der vorherigen Folie

00:30:21,039 --> 00:30:23,549
erklärt wurde und hier noch einmal besprochen wird.

00:30:23,549 --> 00:30:27,620
Wenn Sie hier Bilder verwenden, können Sie sie nicht
vergleichen.

00:30:27,620 --> 00:30:31,960
Wenn also zwei beliebige Bilder gegeben werden, gibt
es keine Möglichkeit, sie wirklich vernünftig zu vergleichen.

00:30:31,960 --> 00:30:35,999
Man braucht hier also Daten... etwas, das
inspiziert werden kann.

00:30:35,999 --> 00:30:38,710
Und nun... Konstanten wie diese haben diese
Eigenschaft.

00:30:38,710 --> 00:30:45,979
Wenn wir also von Zahlen zu diesem neuen Typ wechseln, können wir
eine sinnvolle Zeichenfunktion zu haben,

00:30:45,979 --> 00:30:51,100
aber auch diese Ebene als Daten zu behandeln, wo
wir uns das Ergebnis für eine bestimmte Position ansehen

00:30:51,100 --> 00:30:55,539
und damit rechnen können, wie
einen Block mit einer Perle vergleichen, etc...

00:30:55,539 --> 00:30:57,440
Vergleichen im Sinne von: ist das eine ein Block
und der andere eine Perle?

00:30:57,440 --> 00:31:03,980
Oder das eine ist Wasser und das andere ist eine Perle,
usw., nicht Vergleiche im Sinne von Zahlen.

00:31:03,980 --> 00:31:07,960
Deshalb wollen wir etwas haben, das
kein Bild ist, etwas, mit dem wir arbeiten

00:31:07,960 --> 00:31:13,570
können, wie diese Konstanten, die wir
anschauen können, und dann brauchen wir so etwas wie diese

00:31:13,570 --> 00:31:15,200
Funktion.

00:31:15,200 --> 00:31:20,190
Aber dank dieses Aufzählungstyps kann eine
solche Funktion sicher in einem

00:31:20,190 --> 00:31:29,159
nicht redundanten, aber auch erschöpfenden Weise implementiert werden,
was vom Compiler überprüft wird.

135 # slide
00:31:29,159 --> 00:31:33,019
Dies waren einfache Aufzählungstypen.

00:31:33,019 --> 00:31:35,479
Lassen Sie uns nun darüber hinausgehen.

00:31:35,479 --> 00:31:43,190
Wir bewegen uns in einem Bereich, in dem es nicht nur um
nur Namenskonstanten geht, die wir leicht

00:31:43,190 --> 00:31:45,799
mit Zahlen simulieren können wie in C oder ähnlichem.

00:31:45,799 --> 00:31:50,229
Lassen Sie uns allgemeinere algebraische Datentypen verwenden.

00:31:50,229 --> 00:31:54,210
Inwiefern werden sie allgemeiner sein?

00:31:54,210 --> 00:31:57,749
Nun, sie können zusätzliche Werte kapseln
in diesen Alternativen kapseln.

00:31:57,749 --> 00:32:05,320
Bislang hatten wir zum Beispiel: Ein Tag kann Montag sein,
Dienstag, etc. sein, oder eine Kachel kann Wasser, Perle,

00:32:05,320 --> 00:32:07,470
Block und Blank oder was auch immer.

00:32:07,470 --> 00:32:13,710
Dies sind die Alternativen, die wir mit diesem
logischen Balken "|". Nun, jede dieser Alternativen

00:32:13,710 --> 00:32:23,669
kann zusätzliche Werte im Sinne eines
Datensatzes annehmen, also einige zusätzliche Daten enthalten.

00:32:23,669 --> 00:32:24,669
Was bedeutet das?

00:32:24,669 --> 00:32:27,499
Die Datenkonstruktoren können jetzt Argumente annehmen.

00:32:27,499 --> 00:32:31,049
Sie sind nicht nur Konstanten, sondern jetzt
Funktionen, die Argumente annehmen.

00:32:31,049 --> 00:32:37,559
Syntaktisch bedeutet dies eine Bereicherung dessen, was
wir in diese Datendefinitionen schreiben können.

00:32:37,559 --> 00:32:44,059
Lassen Sie mich also drei Datendefinitionen zeigen
die miteinander in Beziehung stehen/voneinander abhängen

00:32:44,059 --> 00:32:46,340
voneinander abhängen, nämlich das, was wir hier sehen.

00:32:46,340 --> 00:32:51,899
Ich habe einen neuen Typ Datum definiert und er hat nur
eine Alternative.

00:32:51,899 --> 00:32:55,039
Es gibt hier also keinen vertikalen Balken für andere
Aufzählungsoptionen.

00:32:55,039 --> 00:33:01,499
Es gibt nur eine Option, und zwar: Tag ist
ein Datenkonstruktor, und dann gibt es drei

00:33:01,499 --> 00:33:05,730
Argumente, und die Typen werden hier geschrieben,
weil dies eine Typdefinition ist.

00:33:05,730 --> 00:33:13,370
Einige Dinge sind zu beachten: Erstens, hier verwende ich Day
als Datenkonstruktor, während ich ihn vor ein paar Folien

00:33:13,370 --> 00:33:15,960
als Typkonstruktor verwendet habe.

00:33:15,960 --> 00:33:18,330
Ich sagte, dass ich das normalerweise nicht tun würde.

00:33:18,330 --> 00:33:21,799
Stellen Sie sich also vor, dass dies ein Beispiel ist, das
von dem vorherigen Beispiel getrennt ist.

00:33:21,799 --> 00:33:26,879
Ich würde also diese und die andere Definition nicht verwenden
der Daten Tag (als Montag, Dienstag usw.) im

00:33:26,879 --> 00:33:27,879
demselben Programm verwenden.

00:33:27,879 --> 00:33:33,269
Sagen wir also, es ist ein separates Programm,
damit ich diese Verwirrung vermeiden kann.

00:33:33,269 --> 00:33:40,809
Ich definiere einen neuen Typ: Datum, der nur eine
Alternative hat, nämlich: Day (als Datenkonstruktor),

00:33:40,809 --> 00:33:45,519
aber Day ist nicht konstant, es hat drei Argumente
vom Typ Integer, wobei die Idee natürlich ist

00:33:45,519 --> 00:33:52,049
dass ich den Tag des Monats speichere, die
Nummer des Monats...

00:33:52,049 --> 00:33:58,480
Man könnte sagen: Ich sollte hier eigentlich Januar,
Februar, usw. verwenden, anstatt Zahlen, aber

00:33:58,480 --> 00:34:02,340
normalerweise werden Daten als Nummer, Nummer,
Nummer.

00:34:02,340 --> 00:34:06,889
Lassen Sie mich das also auch hier tun.

00:34:06,889 --> 00:34:09,320
Dann habe ich einen weiteren Typ, nämlich Zeit.

00:34:09,320 --> 00:34:15,210
Ich habe beschlossen, dass ich für meine Zeit nur
die Stunden speichern möchte.

00:34:15,210 --> 00:34:21,070
Time wird also einfach konstruiert, indem ich sage:
Die Stunden sind so-und-so.

00:34:21,070 --> 00:34:26,929
Wir können 11 Uhr morgens oder etwas Ähnliches speichern.

00:34:26,929 --> 00:34:32,460
Was mich eigentlich interessiert, ist der neue
Typ Connection, der auf diesen benutzerdefinierten

00:34:32,460 --> 00:34:33,460
Typen basiert.

00:34:33,460 --> 00:34:34,460
Also, was ist eine Verbindung?

00:34:34,460 --> 00:34:38,110
Ich möchte in der Lage sein, sowohl über Zug
und Flugverbindungen sprechen können.

00:34:38,110 --> 00:34:42,600
Dies wären also meine Alternativen: Zug
oder Flug, wie Montag und Dienstag, aber eigentlich

00:34:42,600 --> 00:34:48,060
Zug und Flug sind nicht einfach Konstanten
wie Montag und Dienstag, sondern sie

00:34:48,060 --> 00:34:49,150
tragen einige Daten.

00:34:49,150 --> 00:34:50,260
Und sie tragen unterschiedliche Daten.

00:34:50,260 --> 00:34:53,690
Daher hat jeder von ihnen seinen eigenen Satz von Konstruktor
Argumenten.

00:34:53,690 --> 00:35:01,420
So möchte ich zum Beispiel für einen Zug Folgendes speichern
das Datum und zwei Zeiten, nämlich die Abfahrts- und

00:35:01,420 --> 00:35:03,260
Zeit und die Ankunftszeit.

00:35:03,260 --> 00:35:04,850
Das kann ich hier sagen.

00:35:04,850 --> 00:35:12,480
Und natürlich werden die Werte Day und Time und Time
in der Art und Weise konstruiert werden, wie diese

00:35:12,480 --> 00:35:15,090
zwei Definitionen hier erklären.

00:35:15,090 --> 00:35:17,901
Außerdem gibt es Flugverbindungen.

00:35:17,901 --> 00:35:18,970
Und für Flüge speichere ich etwas anderes.

00:35:18,970 --> 00:35:23,270
Ich speichere die Fluggesellschaft, und sagen wir, diese wird
als 'String' gespeichert.

00:35:23,270 --> 00:35:30,080
Und dann speichere ich auch das Datum, an dem diese
Flugverbindung stattfindet, und zwei Zeiten

00:35:30,080 --> 00:35:33,260
für Abflug und Ankunft.

00:35:33,260 --> 00:35:39,800
Wie Sie sehen, können diese Definitionen
voneinander abhängen können, so wie ich einen selbst definierten

00:35:39,800 --> 00:35:42,480
Typ in einem anderen selbst definierten Typ verwenden kann.

00:35:42,480 --> 00:35:44,470
Auch die Reihenfolge ist hier nicht relevant.

00:35:44,470 --> 00:35:48,630
So ist es auch bei Funktionsdefinitionen,
Ich muss diese Typen nicht definieren, bevor

00:35:48,630 --> 00:35:50,350
ich diese Typen definiere oder so etwas in der Art.

00:35:50,350 --> 00:35:53,100
Es kann also eine gegenseitige Abhängigkeit bestehen.

00:35:53,100 --> 00:35:57,220
In diesem Fall ist das nicht der Fall, aber es könnte
im Allgemeinen sein.

00:35:57,220 --> 00:36:00,270
Schauen wir uns nun ein Beispiel an.

00:36:00,270 --> 00:36:04,160
Was möchte ich zum Beispiel wissen, wenn ich einen Wert von
dem Typ Verbindung.

00:36:04,160 --> 00:36:08,701
Natürlich wird es jetzt etwas komplizierter
diese Werte zu konstruieren, weil sie

00:36:08,701 --> 00:36:11,660
nur Konstanten wie Montag, Dienstag usw. sind.

00:36:11,660 --> 00:36:15,540
Ein Wert dieses Typs wäre entweder ein Zug
oder ein Flug.

00:36:15,540 --> 00:36:19,270
Nehmen wir also an, wir wollen einen Wert für
Zug.

00:36:19,270 --> 00:36:26,010
Dann wäre Train der Name, der erscheint...
der Name des Konstruktors (nur Montag, Dienstag)

00:36:26,010 --> 00:36:28,130
was wir als Konstante verwenden.

00:36:28,130 --> 00:36:29,230
Und jetzt ist dies natürlich eine Funktion.

00:36:29,230 --> 00:36:30,960
Sie benötigt also drei Argumente.

00:36:30,960 --> 00:36:33,890
Das erste Argument ist ein Datum, das
so aufgebaut ist.

00:36:33,890 --> 00:36:40,050
Es wird also etwas mit dem Konstruktor
Day und dann drei Zahlen, dann zwei Times,

00:36:40,050 --> 00:36:44,700
und zwar von der Form Stunde und einer Zahl (Integer).

00:36:44,700 --> 00:36:49,540
Ein möglicher Wert dieses Verbindungstyps könnte
wie folgt aussehen.

00:36:49,540 --> 00:36:51,550
Dies folgt diesem Schema.

00:36:51,550 --> 00:36:57,120
Es ist Train... und dass ich Train verwendet habe, sagt
mir, dass ich hier drei Argumente brauche.

00:36:57,120 --> 00:37:00,280
Und wie sähen die Typen aus, wenn ich stattdessen geschrieben hätte
Flug hier stattdessen geschrieben hätte?

00:37:00,280 --> 00:37:04,670
Dann bräuchten wir drei Argumente und es
sollte hier zusätzlich ein String stehen.

00:37:04,670 --> 00:37:06,250
Aber für Train habe ich drei Argumente.

00:37:06,250 --> 00:37:07,990
Das erste ist ein Datum.

00:37:07,990 --> 00:37:11,540
Und ein Datum ist ein Tag mit drei Zahlen, wie
wir hier sehen.

00:37:11,540 --> 00:37:15,960
Und die beiden Times sind Dinge der Form Hour
und eine Zahl (Integer).

00:37:15,960 --> 00:37:17,880
Und jetzt kann das natürlich verschachtelt werden.

00:37:17,880 --> 00:37:19,560
Und das entspricht den Bäumen.

00:37:19,560 --> 00:37:24,890
Und ich werde dies auf dem Whiteboard in der
Whiteboard-App zeichnen, um das zu veranschaulichen.

00:37:24,890 --> 00:37:31,480
Aber geschrieben als Wert im Interpreter,
zum Beispiel, oder im Code, wäre das einfach

00:37:31,480 --> 00:37:40,000
so, wenn man sie als Funktionen auf Argumenten betrachtet.

136 # slide
00:37:40,000 --> 00:37:45,480
Wie können wir dann mit solchen Werten rechnen... Werte
dieser Art, die wir gerade gesehen haben?

00:37:45,480 --> 00:37:47,490
Durch etwas, das man Pattern-Matching nennt.

00:37:47,490 --> 00:37:52,420
Das ist das Konzept, das hier zugrunde liegt.

00:37:52,420 --> 00:37:55,860
Und das ist etwas, das wir schon oft gesehen haben,
aber wir haben es nur auf

00:37:55,860 --> 00:38:01,310
Werte ... wie dieses aTile von Block ist
gleich etwas.

00:38:01,310 --> 00:38:02,700
Es war bereits ein Pattern-Match.

00:38:02,700 --> 00:38:09,630
Es wurde mit einem konstanten Pattern abgeglichen: Block
oder Perle, usw. wie bei Wochentagen und auch

00:38:09,630 --> 00:38:11,000
für Zahlen, vorher.

00:38:11,000 --> 00:38:16,950
Jetzt wird dieses Konzept des Pattern-Matchings
ein möglicherweise tief verschachteltes Konzept.

00:38:16,950 --> 00:38:22,261
Wenn Sie also definieren wollen, was die Reisezeit
für eine Verbindung ist, könnten wir sagen: Was

00:38:22,261 --> 00:38:23,261
ist eine Verbindung?

00:38:23,261 --> 00:38:25,080
Eine Verbindung ist entweder ein Zug oder ein Flug.

00:38:25,080 --> 00:38:28,100
Das besagt die vorherige Definition von
der vorigen Folie besagt.

00:38:28,100 --> 00:38:34,300
Sie wissen auch, dass ein Zug
drei Argumente hat: ein Datum, das wir vielleicht

00:38:34,300 --> 00:38:37,280
ignorieren wollen, wenn wir berechnen wollen, wie lange
die Reise dauert.

00:38:37,280 --> 00:38:41,830
Es hängt nicht wirklich von dem Datum ab,
an dem die Fahrt stattfindet, sondern von

00:38:41,830 --> 00:38:43,450
den Abfahrts- und Ankunftszeiten ab.

00:38:43,450 --> 00:38:47,250
Wir könnten also etwas sagen wie: travelTime
einer Zugverbindung, unabhängig von dem

00:38:47,250 --> 00:38:52,460
Datum ist, an dem sie stattfindet, wenn wir
die Abfahrt als "d" und die Ankunft als

00:38:52,460 --> 00:38:57,410
"a", dann ist die travelTime die Ankunftsstunde
minus der Abfahrtsstunde, plus eins, denn

00:38:57,410 --> 00:39:01,020
man braucht etwas Zeit, um zum Bahnhof zu kommen
oder etwas Ähnliches.

00:39:01,020 --> 00:39:06,670
Dies ist also eine Alternative, denn Connection
hat eine Alternative: es könnte ein Zug sein, und

00:39:06,670 --> 00:39:07,770
es könnte auch ein Flug sein.

00:39:07,770 --> 00:39:09,850
Wir sollten also noch einen weiteren Fall schreiben.

00:39:09,850 --> 00:39:12,850
Also einen Fall für die travelTime-Funktion für Flug
Verbindungen.

00:39:12,850 --> 00:39:19,080
Und die Beschreibung/Definition dieses
Datenkonstruktors sagt uns, wie viele Argumente

00:39:19,080 --> 00:39:20,080
er hat.

00:39:20,080 --> 00:39:25,530
Er hat ein String-Argument für die Fluggesellschaft,
aber wir nehmen an, dass die Reisezeit nicht

00:39:25,530 --> 00:39:26,530
davon abhängt.

00:39:26,530 --> 00:39:28,380
Auch das Datum sollte nicht relevant sein.

00:39:28,380 --> 00:39:34,550
Wir haben Abflug- und Ankunftszeiten, aber für
einen Flug müssen wir zwei Stunden für die Anreise zum

00:39:34,550 --> 00:39:37,310
Flughafen und zum Einchecken usw.

00:39:37,310 --> 00:39:44,390
Dies könnte also eine anschauliche Erklärung dafür sein
wie travelTime ins Spiel kommt / definiert wird

00:39:44,390 --> 00:39:47,370
bei Zügen und Flügen.

00:39:47,370 --> 00:39:48,480
Ist dies eine vollständige Fallunterscheidung?

00:39:48,480 --> 00:39:53,030
Ja, das ist sie, denn der Typ Verbindung hat
genau diese beiden Alternativen.

00:39:53,030 --> 00:39:57,880
Und der Compiler wird dafür sorgen, dass wir hier
nichts vergessen.

00:39:57,880 --> 00:40:02,430
Wenn Sie also nur die erste Zeile geschrieben hätten,
dann könnte der Compiler warnen und fragen: Sie

00:40:02,430 --> 00:40:07,320
sagen, Sie haben eine Funktion 'travelTime' definiert
von Connection nach 'Integer' definiert, aber Sie haben sie nur

00:40:07,320 --> 00:40:12,650
für einige Pattern definiert, nämlich für Train,
nicht für Flug.

00:40:12,650 --> 00:40:15,230
An dieser Stelle kommt der Beschreibungswert ins
Spiel.

00:40:15,230 --> 00:40:16,640
Auch überlappende Pattern.

00:40:16,640 --> 00:40:22,650
Wenn wir also zwei Möglichkeiten haben, etwas zu definieren/zu sagen
etwas über Zug, was aus irgendeinem Grund

00:40:22,650 --> 00:40:27,060
relevant sein könnte, denn wenn vielleicht die Stunde
12 ist, also wenn man mittags anfängt, aus irgendeinem

00:40:27,060 --> 00:40:29,630
Grund, dann muss dieser Summand anders sein,
oder was auch immer.

00:40:29,630 --> 00:40:32,550
Man könnte sich hier also weitere Fälle ausdenken.

00:40:32,550 --> 00:40:38,000
Und dann könnte der Compiler prüfen, dass wir
keine Redundanz haben, wir haben nicht irgendeinen

00:40:38,000 --> 00:40:44,380
Fall, der von zwei verschiedenen
Zeilen abgedeckt wird, und es ergibt keinen Sinn, eine

00:40:44,380 --> 00:40:51,080
solche Definition zu haben, dank dieser präzisen
Definition einer Verbindung auf der vorherigen

00:40:51,080 --> 00:40:52,080
Folie.

00:40:52,080 --> 00:41:01,700
Ich werde dies auch in der Whiteboard-Applikation zeigen
um zu verdeutlichen, wie diese tiefe Verschachtelung

00:41:01,700 --> 00:41:06,770
funktioniert, wie wir die Werte für "d" und
"a", zum Beispiel bei einem Beispiel wie

00:41:06,770 --> 00:41:08,010
auf der vorherigen Folie.

00:41:08,010 --> 00:41:14,340
Ich werde zeigen, wie das im Grunde genommen bedeutet
die Auswahl von Teilen des Baums, wenn wir einen Wert

00:41:14,340 --> 00:41:19,840
mit einem Wert.

00:41:19,840 --> 00:41:26,050
Und zur gleichen Zeit, abgesehen von der
Rolle der Datenkonstrukteure, die als Namen dienen

00:41:26,050 --> 00:41:30,460
bei diesem Pattern-Matching, sind sie auch noch
Funktionen, wie ich bereits sagte.

00:41:30,460 --> 00:41:33,950
Diese Datenkonstruktoren haben diese doppelte Rolle:
Sie sind Dinge, die wir mit

00:41:33,950 --> 00:41:38,140
in einer Definition wie dieser, aber sie sind auch
Konstrukteure von Daten.

00:41:38,140 --> 00:41:40,010
Sie sind normale Funktionen.

00:41:40,010 --> 00:41:41,520
Hier sind ihre Typen.

00:41:41,520 --> 00:41:50,440
Wie ich bereits sagte, wird ein Datum immer konstruiert
von Day mit drei Argumenten, nämlich drei

00:41:50,440 --> 00:41:51,440
Ganzzahlen.

00:41:51,440 --> 00:41:56,480
Das bedeutet, dass Day eine Funktion ist, die
drei Integers nimmt und ein Datum zurückgibt.

00:41:56,480 --> 00:42:03,700
Etwas wie Day 4 4 2012 ist ein Datum, weil
es das Ergebnis dieser Funktion ist, die

00:42:03,700 --> 00:42:05,170
auf diese drei Argumente.

00:42:05,170 --> 00:42:07,590
Genauso sind Train und Flight Funktionen.

00:42:07,590 --> 00:42:11,990
So gibt es zum Beispiel zwei verschiedene Möglichkeiten
um Verbindungen zu konstruieren.

00:42:11,990 --> 00:42:14,260
Eine davon ist der Train-Konstruktor.

00:42:14,260 --> 00:42:19,750
Und die Typdefinition für Connection sagt
uns, dass Train drei Argumente hat: Datum, Zeit,

00:42:19,750 --> 00:42:20,900
Zeit.

00:42:20,900 --> 00:42:25,170
Also ist Train eigentlich eine Funktion dieses
Typs.

00:42:25,170 --> 00:42:31,040
Sie kann verwendet werden, um Werte des Typs
Verbindung zu konstruieren, aber sie kann auch auf jede

00:42:31,040 --> 00:42:32,890
andere Art und Weise, wie Funktionen verwendet werden können.

00:42:32,890 --> 00:42:38,480
Wenn wir also an die Funktionen höherer Ordnung zurückdenken
von letzter Woche, diese Konstruktoren Day und

00:42:38,480 --> 00:42:44,860
Train, sie könnten auch Argumente für Funktionen höherer Ordnung sein,
wenn wir etwas haben, das

00:42:44,860 --> 00:42:50,130
entweder polymorph oder mit konkreten Typen
etwas von dieser Form mit drei Argumenten

00:42:50,130 --> 00:42:51,130
und einem Ergebnis.

00:42:51,130 --> 00:42:56,350
Sie haben also alle Rechte, die eine normale Funktion
hat, auch wenn wir sie nicht mit

00:42:56,350 --> 00:42:57,350
Funktionsdefinitionen.

00:42:57,350 --> 00:43:02,100
Diese Funktionen Day und Train werden also
eingeführt, wenn der Typ Verbindung oder der

00:43:02,100 --> 00:43:03,280
Typ Datum definiert wird.

00:43:03,280 --> 00:43:07,950
Sie sind keine nutzerdefinierten Funktionen, per se,
wie es Funktionen wie diese sind.

00:43:07,950 --> 00:43:12,940
Aber sie sind einfach Funktionen, die verwendet werden können
auf jede Art und Weise verwendet werden können, die Haskell für eine Funktion

00:43:12,940 --> 00:43:14,230
verwendet werden kann.

00:43:14,230 --> 00:43:21,070
Und das ist wichtig für die Strukturierung von Programmen
und um alle Möglichkeiten, die wir haben, sinnvoll zu nutzen

00:43:21,070 --> 00:43:21,670
die wir haben.
