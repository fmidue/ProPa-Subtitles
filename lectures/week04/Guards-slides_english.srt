55 # slide
00:00:01,430 --> 00:00:06,260
Let us also discuss a bit more syntax today.

00:00:06,260 --> 00:00:11,980
And essentially, this will be more stuff
on programming by case distinction.

00:00:11,980 --> 00:00:16,170
So, this is, of course, an important
aspect for defining functions.

00:00:16,170 --> 00:00:19,550
We have seen this before, and
we have used it in exercises.

00:00:19,550 --> 00:00:24,030
And so far, this has been by
"if-then-else" expressions.

00:00:24,030 --> 00:00:30,140
You might even have had reasons in your exercise
submissions to nest if-then-else expressions.

00:00:30,140 --> 00:00:33,620
And once you start doing that,
this becomes a bit cumbersome.

00:00:33,620 --> 00:00:40,700
So, there are other options, and some of them
will be discussed now (more ways of doing

00:00:40,700 --> 00:00:42,030
case distinction).

00:00:42,030 --> 00:00:44,730
Actually, this will not be finished today.

00:00:44,730 --> 00:00:52,230
In particular, pattern-matching (which is
also a way of programming by case distinction

00:00:52,230 --> 00:00:53,560
in Haskell) will be handled in a different
week.

00:00:53,560 --> 00:00:58,191
But let's first look at the situation with
if-then-else again and what we can do if this

00:00:58,191 --> 00:01:05,059
takes too much nesting.

56 # slide
00:01:05,059 --> 00:01:07,240
First, remember how an if-then-else looks.

00:01:07,240 --> 00:01:11,000
So, that was an example that I used last week.

00:01:11,000 --> 00:01:15,159
And you have done similar
things in the exercises.

00:01:15,159 --> 00:01:19,810
So, in a function definition on the right-hand
side (as an expression), we can use if-then-else.

00:01:19,810 --> 00:01:23,520
There must be a condition
and then two expressions.

00:01:23,520 --> 00:01:26,840
They must be of the same type;
otherwise, it wouldn't make sense.

00:01:26,840 --> 00:01:28,260
And they must always be there.

00:01:28,260 --> 00:01:33,759
So, we cannot, for example, omit the "else",
because then this wouldn't evaluate to some

00:01:33,759 --> 00:01:35,880
reasonable value or some value at all.

00:01:35,880 --> 00:01:43,580
This was the Haskell syntax, and I explained
this corresponding to this mathematical syntax.

00:01:43,580 --> 00:01:45,900
So far, so good.

00:01:45,900 --> 00:01:50,840
Now, as I just mentioned, as soon as you have
more than one condition, or you have more

00:01:50,840 --> 00:01:55,560
complex conditions, then on this side you
would have to nest an if-then-else expression.

00:01:55,560 --> 00:01:58,960
So, maybe in the "then" branch, you will have
to have another "if-then-else" to check the

00:01:58,960 --> 00:02:00,040
second condition.

00:02:00,040 --> 00:02:02,920
And this quickly becomes not so nice.

00:02:02,920 --> 00:02:04,960
Of course, in mathematics,
there is a different approach.

00:02:04,960 --> 00:02:09,679
In mathematics, in an expression like this,
people tend to write more than two cases.

00:02:09,679 --> 00:02:12,950
So, we have one case, another case, and
another case, ..., and then the "else" case.

00:02:12,950 --> 00:02:17,819
So, mathematicians don't nest these kinds of
expressions; they simply give a longer list

00:02:17,819 --> 00:02:25,299
of conditions and expressions here.

57 # slide
00:02:25,299 --> 00:02:29,669
Something like this can be
mirrored in Haskell as well.

00:02:29,669 --> 00:02:31,760
That could look like this.

00:02:31,760 --> 00:02:38,529
You probably haven't seen this definition
kind before, except if you have used HLint

00:02:38,529 --> 00:02:41,670
and it has suggested it, which it
tends to do for nested if-then-else.

00:02:41,670 --> 00:02:48,480
So, this could be an example we are viewing
again: compute some "scene" from a time parameter.

00:02:48,480 --> 00:02:53,841
And maybe there are more complex conditions
than simply, if t is smaller than this, then

00:02:53,841 --> 00:02:56,290
... else ..., or maybe there are more conditions.

00:02:56,290 --> 00:02:57,680
So, we could have something like this.

00:02:57,680 --> 00:03:01,430
And actually, if you just read this,
you probably know what is meant here.

00:03:01,430 --> 00:03:07,199
So, under the condition that t is smaller
or equal to pi, we should do something.

00:03:07,199 --> 00:03:13,389
Under the condition that that is not the case, but
t is actually greater than pi but less or equal

00:03:13,389 --> 00:03:16,629
to the double of pi, then we
should have something else.

00:03:16,629 --> 00:03:24,530
And under a third condition, namely that t is
actually greater than 2 * pi, then yet another

00:03:24,530 --> 00:03:26,599
expression should be evaluated.

00:03:26,599 --> 00:03:33,879
So, this is also a way of expressing conditional
behavior, and it very directly corresponds

00:03:33,879 --> 00:03:37,109
to what mathematicians like to write.

00:03:37,109 --> 00:03:46,249
Here is a function definition f(x) = ..., and then
maybe also three mutually exclusive conditions

00:03:46,249 --> 00:03:49,010
on the x value.

00:03:49,010 --> 00:03:55,839
And depending on what we have
here, we get different expressions.

00:03:55,839 --> 00:04:02,219
Now, just as here, we could write any Boolean
condition: anything that can be evaluated

00:04:02,219 --> 00:04:04,180
or checked in mathematics.

00:04:04,180 --> 00:04:07,569
Here we can write anything
that is of Boolean type.

00:04:07,569 --> 00:04:12,519
Often, of course, these will be comparisons
like here, or combinations of comparisons.

00:04:12,519 --> 00:04:13,869
But that need not be the case.

00:04:13,869 --> 00:04:17,440
You could have written any expression
which evaluates to a Boolean.

00:04:17,440 --> 00:04:23,259
It doesn't have to be arithmetic comparisons
combined with "and" and "or", etc.

00:04:23,259 --> 00:04:30,419
You can write anything here, any predicate,
anything which evaluates to a Boolean value.

00:04:30,419 --> 00:04:34,330
And as I already mentioned, once you start
writing nested if-then-else expressions, then

00:04:34,330 --> 00:04:38,050
HLint will suggest writing things like this.

00:04:38,050 --> 00:04:40,880
This HLint is a component inside Autotool.

00:04:40,880 --> 00:04:46,860
So, you will benefit from these suggestions
also in Autotool without using HLint as a

00:04:46,860 --> 00:04:52,770
separate tool.

58 # slide
00:04:52,770 --> 00:05:00,650
Let us discuss some more details, in particular
about, for example, the order in which we

00:05:00,650 --> 00:05:02,130
write conditions like this.

00:05:02,130 --> 00:05:03,800
So, these conditions are called guards.

00:05:03,800 --> 00:05:06,260
This is expressing a function with guards.

00:05:06,260 --> 00:05:10,139
And a guard is this kind of Boolean
expression that can be written here.

00:05:10,139 --> 00:05:14,580
In if-then-else, it's clear what happens: You
have "if" and then you either do the left

00:05:14,580 --> 00:05:16,110
or the right, the "then" or the "else".

00:05:16,110 --> 00:05:19,740
So, there is no question of order because
the "then" and the "else" are clear about

00:05:19,740 --> 00:05:26,790
in which cases they execute (or the
corresponding expression is evaluated).

00:05:26,790 --> 00:05:31,940
Here, we now of course at least have to ask
what happens if, for example, these guards

00:05:31,940 --> 00:05:33,069
overlap.

00:05:33,069 --> 00:05:36,069
Or does it matter in which
order you write them down?

00:05:36,069 --> 00:05:41,820
I will discuss this on the factorial example,
which is also a very simple example for recursion,

00:05:41,820 --> 00:05:42,850
of course.

00:05:42,850 --> 00:05:46,719
So, the factorial function
as defined in mathematics.

00:05:46,719 --> 00:05:53,090
It could be written via an if-then-else, of
course, but more mathematically looking, you

00:05:53,090 --> 00:05:54,090
would write:

00:05:54,090 --> 00:06:00,080
The factorial of an integer is 1 if the
integer is zero (that is the starting of the

00:06:00,080 --> 00:06:04,789
factorial function), and if the argument is
greater than zero, then you want to compute

00:06:04,789 --> 00:06:09,990
n times the factorial of the predecessor.

00:06:09,990 --> 00:06:14,310
That looks reasonable.

00:06:14,310 --> 00:06:15,969
Now what about the order of the clauses?

00:06:15,969 --> 00:06:20,819
So, does it matter in which
order I write these things down?

00:06:20,819 --> 00:06:22,919
Well, it depends on the conditions.

00:06:22,919 --> 00:06:26,789
In this case here, these two
conditions are mutually exclusive:

00:06:26,789 --> 00:06:33,060
There is no input n possible that would
be both zero and greater than zero.

00:06:33,060 --> 00:06:39,999
And since that is the case, the following
variant, where I simply switch the two lines

00:06:39,999 --> 00:06:42,639
here, is equivalent.

00:06:42,639 --> 00:06:47,060
Because simply the value of n will decide
which of them is taken, and the order in which

00:06:47,060 --> 00:06:51,229
these are written down does not matter.

00:06:51,229 --> 00:06:55,219
Now I will consider further examples
where I change the guards, etc.

00:06:55,219 --> 00:07:00,009
And what I would have done in the past is
to have a separate window open, in which I

00:07:00,009 --> 00:07:05,360
have this program in Haskell and edit the
program, and let it run to see the effects

00:07:05,360 --> 00:07:09,330
of changing the order of things and
changing conditions in the guards, etc.

00:07:09,330 --> 00:07:13,749
I don't want to do this now, because that
would be too much stopping and restarting

00:07:13,749 --> 00:07:15,199
my video recording.

00:07:15,199 --> 00:07:20,360
So, what I suggest, if you want to follow the
arguments here, is that you do this yourself.

00:07:20,360 --> 00:07:26,639
You can stop the video and copy the code into
an editor window and then run this in GHCi,

00:07:26,639 --> 00:07:30,409
all the versions of the code that I discuss.

00:07:30,409 --> 00:07:35,120
So, here I will simply say what happens and
you can check yourself (if you have copied

00:07:35,120 --> 00:07:36,120
the code).

00:07:36,120 --> 00:07:39,150
But I will not actually demonstrate
this here for all the versions.

00:07:39,150 --> 00:07:40,340
I will simply talk about this.

00:07:40,340 --> 00:07:47,150
So, probably this will be a bit shorter than
if it was like I have done in the past.

00:07:47,150 --> 00:07:48,539
In this example, we will see:

00:07:48,539 --> 00:07:53,689
No matter which of these two versions we see
here is taken, if you run it on something

00:07:53,689 --> 00:07:59,289
like 12 or whatever, some nice non-negative
number (here you see already that negative

00:07:59,289 --> 00:08:06,419
numbers might be a problem, but let's only
call "factorial" on non-negative inputs now),

00:08:06,419 --> 00:08:16,319
then these two versions that we
see here and here behave the same.

59 # slide
00:08:16,319 --> 00:08:18,180
What if the guard conditions overlap?

00:08:18,180 --> 00:08:23,580
So, if you don't have that simply the input
value is uniquely determining which of the

00:08:23,580 --> 00:08:28,159
two lines is taken?

00:08:28,159 --> 00:08:33,920
This could correspond to changing that greater
(>) from the previous slide to greater-equal

00:08:33,920 --> 00:08:35,110
(>=).

00:08:35,110 --> 00:08:37,579
Then suddenly there is a difference.

00:08:37,579 --> 00:08:43,409
Suddenly, this version still works
fine, but this one is problematic.

00:08:43,409 --> 00:08:49,970
Maybe you can already guess what would happen,
or you can check on the side what happens

00:08:49,970 --> 00:08:58,050
if you take this code and run
it again maybe with input 12.

00:08:58,050 --> 00:09:09,070
What you should see is a runtime error.

00:09:09,070 --> 00:09:12,910
Why is that?

00:09:12,910 --> 00:09:18,350
If you run this and you start with 12, then
12 is greater-equal 0; then you will have

00:09:18,350 --> 00:09:21,990
12 * factorial 11.

00:09:21,990 --> 00:09:23,470
And then 11 is again in this case.

00:09:23,470 --> 00:09:25,810
So, it is 11 * factorial 10.

00:09:25,810 --> 00:09:28,650
This goes down, down, down,
... until factorial 0.

00:09:28,650 --> 00:09:34,300
Then what happens is that factorial
0 would match the second case.

00:09:34,300 --> 00:09:38,100
But actually, Haskell will
evaluate these from top to bottom.

00:09:38,100 --> 00:09:41,760
So, it will first check whether
the first guard is satisfied.

00:09:41,760 --> 00:09:47,380
And for the input n = 0, actually, this first
guard is satisfied, because 0 is greater-equal

00:09:47,380 --> 00:09:48,380
0.

00:09:48,380 --> 00:09:52,820
So, what will happen is: 0 * factorial (-1).

00:09:52,820 --> 00:09:58,360
And actually, Haskell will not somehow magically
say: "Well, 0 * something is irrelevant."

00:09:58,360 --> 00:10:03,310
Instead, it will actually try
to compute factorial of -1.

00:10:03,310 --> 00:10:09,750
And then for factorial of -1, if you go again
into the recursion, then we have -1, and -1

00:10:09,750 --> 00:10:13,610
is not greater or equal to 0.

00:10:13,610 --> 00:10:15,380
So, what is factorial (-1)?

00:10:15,380 --> 00:10:16,380
We don't know.

00:10:16,380 --> 00:10:17,380
The compiler doesn't know.

00:10:17,380 --> 00:10:18,380
The runtime system doesn’t know.

00:10:18,380 --> 00:10:19,380
So, there will be a runtime error.

00:10:19,380 --> 00:10:20,380
This doesn't happen here.

00:10:20,380 --> 00:10:21,380
Why not?

00:10:21,380 --> 00:10:27,490
Because here it is not the case that once
we have factorial of zero, we again make a

00:10:27,490 --> 00:10:28,960
recursive call.

00:10:28,960 --> 00:10:34,259
Because evaluating/checking from top to bottom,
factorial of zero will match the first case.

00:10:34,259 --> 00:10:36,279
So, the output will be 1.

00:10:36,279 --> 00:10:37,279
And then the recursion stops.

00:10:37,279 --> 00:10:44,480
So, if you have a base case like here, then this
base case should be first in such a sequence

00:10:44,480 --> 00:10:48,540
of checks.

00:10:48,540 --> 00:10:57,340
Sometimes, the compiler will be able to warn
about cases like this because, essentially,

00:10:57,340 --> 00:11:01,160
the runtime error that we get from
this is that this is not fully defined.

00:11:01,160 --> 00:11:05,890
Integers contain negative numbers, but for
negative numbers we don't give a case.

00:11:05,890 --> 00:11:11,279
Sometimes, the compiler will
be able to warn about this.

60 # slide
00:11:11,279 --> 00:11:18,940
Okay, but let's say we don't make this mistake.

00:11:18,940 --> 00:11:23,690
Let's say we stay with the correct order.

00:11:23,690 --> 00:11:27,779
What is the problem, then?

00:11:27,779 --> 00:11:34,190
We don't have the problem that if we start
with 12, we get to zero and then
0 * factorial (-1).

00:11:34,190 --> 00:11:35,250
We don't get this problem.

00:11:35,250 --> 00:11:41,010
But if we, right away, call this function
with -1, we again have a runtime error.

00:11:41,010 --> 00:11:46,920
So, if we call with -1, then neither the
base case matches nor the recursive case.

00:11:46,920 --> 00:11:51,560
So, we get a runtime error.

61 # slide
00:11:51,560 --> 00:11:58,199
As mentioned before, with appropriate
settings, the compiler can warn us about this.

00:11:58,199 --> 00:12:05,230
And in Autotool, we will henceforth enable
these warnings, so that if you program with

00:12:05,230 --> 00:12:13,630
guards, for example, and you are not careful
to make sure that there's always a case that

00:12:13,630 --> 00:12:15,380
matches, then the compiler will complain.

00:12:15,380 --> 00:12:18,800
The compiler, of course, cannot know for
sure whether you have matched all cases.

00:12:18,800 --> 00:12:21,250
So, the compiler will be overcautious.

00:12:21,250 --> 00:12:26,440
So, it might warn you even though actually,
with some mathematical insight, one can see

00:12:26,440 --> 00:12:28,880
that your code is covering all cases.

00:12:28,880 --> 00:12:34,500
The compiler tries to warn you about cases
where it doesn't know, because it can't tell,

00:12:34,500 --> 00:12:37,880
that you have covered all cases.

00:12:37,880 --> 00:12:43,079
One way to make sure that you cover all
cases, and also to let the compiler be certain

00:12:43,079 --> 00:12:47,160
that you've covered all cases, is that you
have something like a catch-all clause.

00:12:47,160 --> 00:12:53,410
In the example from before, instead of having
two conditions, one being n==0 and the other

00:12:53,410 --> 00:12:58,230
being something like n>0 or
n>=0, you could say "otherwise".

00:12:58,230 --> 00:13:05,399
Then, checking from top to bottom, for every
input that is not zero this last line will

00:13:05,399 --> 00:13:06,399
be taken.

00:13:06,399 --> 00:13:13,000
At least then we won't have a runtime error,
in the sense that for some input, the factorial

00:13:13,000 --> 00:13:15,540
function doesn't know what to compute.

00:13:15,540 --> 00:13:21,320
So, now in GHCi, this wouldn't
lead to a runtime error.

00:13:21,320 --> 00:13:25,670
Of course, it could still be a problem if
you call with negative values, but then not

00:13:25,670 --> 00:13:31,190
because of a runtime error (of a missing
case), but actually because of non-termination.

00:13:31,190 --> 00:13:36,860
Because then, you will run (if you call this
with negative inputs) into an infinite recursion.

00:13:36,860 --> 00:13:39,050
Because you never stop for negative values.

00:13:39,050 --> 00:13:40,300
But that is a separate problem.

00:13:40,300 --> 00:13:46,779
And of course, a problem that no compiler
can, in general, catch; simply because of

00:13:46,779 --> 00:13:52,910
the "halting problem".

62 # slide
00:13:52,910 --> 00:13:53,910
That was this observation.

00:13:53,910 --> 00:13:56,660
In this case, negative inputs would be a problem.

00:13:56,660 --> 00:14:00,389
We could also fix this in some sense by saying:

00:14:00,389 --> 00:14:05,700
We take the base case whenever we have a non-positive
value; not only for zero, but also for negative

00:14:05,700 --> 00:14:06,700
values.

00:14:06,700 --> 00:14:10,579
Now this would be something that passes the
compiler, because the compiler can tell that

00:14:10,579 --> 00:14:12,820
we have covered all cases.

00:14:12,820 --> 00:14:18,170
It also never has a problem at runtime in terms
of not knowing which case to take, precisely

00:14:18,170 --> 00:14:19,430
because of this last case.

00:14:19,430 --> 00:14:20,920
So, the compiler guarantees this.

00:14:20,920 --> 00:14:26,639
Then it's true that you never run out of cases
to consider, so to speak, because the "otherwise"

00:14:26,639 --> 00:14:28,070
case always applies.

00:14:28,070 --> 00:14:36,620
And it also doesn't have a non-termination
problem, simply because at some point after

00:14:36,620 --> 00:14:42,629
reducing this many times, or right away if
called with a negative value, we will always

00:14:42,629 --> 00:14:49,519
reach this case (either immediately
or after a finite number of steps).

00:14:49,519 --> 00:14:53,760
So, some lessons here:

00:14:53,760 --> 00:14:58,649
The order matters in
selecting which line to take.

00:14:58,649 --> 00:15:03,470
The semantics will consider the order.

00:15:03,470 --> 00:15:06,009
That also means that we can exploit this order.

00:15:06,009 --> 00:15:08,350
So, we can maybe simplify some later conditions.

00:15:08,350 --> 00:15:12,040
We will see this in an example in a moment.

00:15:12,040 --> 00:15:23,029
We can simplify some later conditions since
we know that the preceding guards have already

00:15:23,029 --> 00:15:24,089
been checked.

00:15:24,089 --> 00:15:29,459
Exhaustiveness matters because
we want to avoid runtime errors.

63 # slide
00:15:29,459 --> 00:15:37,350
Now, some further remarks.

00:15:37,350 --> 00:15:40,610
The compiler checks ahead of time
are nice, but they are not perfect.

00:15:40,610 --> 00:15:44,230
They can't be perfect because of,
for example, "the halting problem".

00:15:44,230 --> 00:15:48,560
So, it's impossible in general to detect infinite
recursion, for example, but also some other

00:15:48,560 --> 00:15:50,339
problems that a program might have.

00:15:50,339 --> 00:16:00,920
Haskell does a pretty good job of preventing
preventable errors, but it can't fix all problems.

00:16:00,920 --> 00:16:06,860
Even the simpler checks that are not aiming
for perfection are not as powerful as one

00:16:06,860 --> 00:16:08,220
might sometimes hope.

00:16:08,220 --> 00:16:13,149
Sometimes, from some mathematical insight into
your problem, you might think the compiler

00:16:13,149 --> 00:16:17,019
should be able to tell that a
certain definition is exhaustive.

00:16:17,019 --> 00:16:19,519
But sometimes that's not
happening, and for a good reason.

00:16:19,519 --> 00:16:20,550
Here is an example.

00:16:20,550 --> 00:16:26,930
It will warn you against trying to rely on certain
properties, about relations from mathematics,

00:16:26,930 --> 00:16:27,930
for example.

00:16:27,930 --> 00:16:33,680
You might think that if you write a condition
like this, f x y is: if x and y are equal,

00:16:33,680 --> 00:16:39,629
then something, and if x and y are not equal,
then something else; you might assume that

00:16:39,629 --> 00:16:41,810
this would be statically safe.

00:16:41,810 --> 00:16:45,490
Well, the compiler won't be able to tell that
this is safe because "basically, these two

00:16:45,490 --> 00:16:50,480
things are opposites of each other, so only
and exactly one of them will be true".

00:16:50,480 --> 00:16:54,360
That is a reasonable thing to
assume, but actually not so simple.

00:16:54,360 --> 00:17:00,110
There is a good reason why this is not
considered safe in general by the compiler.

00:17:00,110 --> 00:17:06,830
And the reason is that certainly this is true
(that in these two things, always one of them

00:17:06,830 --> 00:17:13,250
will be true) for base types like numbers,
characters, or strings; but actually, in Haskell

00:17:13,250 --> 00:17:18,760
you can overload equality and inequality for
your own types, and nobody can prevent you

00:17:18,760 --> 00:17:24,371
as a programmer from writing a new type with
equality and inequality checks, where there

00:17:24,371 --> 00:17:29,050
are some pairs of values x and y where
neither of these two conditions is true.

00:17:29,050 --> 00:17:32,410
And then the compiler cannot promise
that one of them will always be true.

00:17:32,410 --> 00:17:34,930
Maybe it's not even the case for your own
type.

00:17:34,930 --> 00:17:40,440
So, in that sense, it's better to, again,
replace the second condition with "otherwise",

00:17:40,440 --> 00:17:53,590
because then also the compiler can say that
definitely one of the two cases will be applicable.

64 # slide
00:17:53,590 --> 00:18:01,790
Also, in an ideal world, we wouldn't depend
so much on massaging our guard conditions.

00:18:01,790 --> 00:18:06,790
So, let's return to this issue, where
we had problems with negative inputs.

00:18:06,790 --> 00:18:13,190
And the fix was to switch from n == 0 to n ≤ 0
in the first case, because then we would have

00:18:13,190 --> 00:18:20,850
covered all cases and also didn't run into
infinite recursion for negative inputs.

00:18:20,850 --> 00:18:26,040
One might argue that this is not what one
wants: that this factorial function returns

00:18:26,040 --> 00:18:29,400
one for all negative numbers,
if you change to "n≤0" here.

00:18:29,400 --> 00:18:35,240
So, the real fix (the conceptually most appealing
fix) would be to use the type system to even

00:18:35,240 --> 00:18:37,500
prevent that you get negative inputs here.

00:18:37,500 --> 00:18:44,630
So, the Integer type contains negative numbers,
but one could use a more expressive type system,

00:18:44,630 --> 00:18:49,220
which actually can guarantee that the factorial
function will, in a given program, never be

00:18:49,220 --> 00:18:50,910
called on negative numbers.

00:18:50,910 --> 00:18:56,400
That is possible, but it is really
a topic for another lecture, and

00:18:56,400 --> 00:18:57,770
maybe not even for this course.

00:18:57,770 --> 00:19:03,741
It is actually for another course or seminar
or an advanced lecture, not necessarily this

00:19:03,741 --> 00:19:04,741
semester.

00:19:04,741 --> 00:19:16,760
I just wanted to mention that such
a more static fix is also possible.

65 # slide
00:19:16,760 --> 00:19:18,000
But let's not go in this direction.

00:19:18,000 --> 00:19:24,270
For now, let's apply our insights we gained
from discussing the factorial example to the

00:19:24,270 --> 00:19:25,690
situation we considered earlier.

00:19:25,690 --> 00:19:27,480
We had the 'scene' function.

00:19:27,480 --> 00:19:29,890
And mathematically, I wrote it like this:

00:19:29,890 --> 00:19:36,550
I check whether t is less than or equal to pi,
then I check the next period from pi to 2 * pi,

00:19:36,550 --> 00:19:40,260
and then above 2 * pi (this could be
something that I want to express).

00:19:40,260 --> 00:19:46,180
Now given what we know about the order of
checking such guards, and what we know about

00:19:46,180 --> 00:19:52,310
exhaustiveness, we can revise this a bit.

00:19:52,310 --> 00:19:58,990
So, the ideal way to write this would be something
like this, which is both shorter and has some

00:19:58,990 --> 00:20:02,680
additional benefits like
predictable exhaustiveness.

00:20:02,680 --> 00:20:04,130
What is the difference here?

00:20:04,130 --> 00:20:06,300
The first condition is still as above.

00:20:06,300 --> 00:20:13,870
In the second condition, it isn't required
to check that t is greater than pi, because

00:20:13,870 --> 00:20:18,760
we know the second line will only be
checked if this first line didn't hold.

00:20:18,760 --> 00:20:24,090
So, we will only reach the second line
if the first condition wasn't true.

00:20:24,090 --> 00:20:30,300
And since these are floating-point numbers, we
really know that if t is not less than or equal

00:20:30,300 --> 00:20:32,590
to pi, then t will be greater than pi.

00:20:32,590 --> 00:20:36,830
So, actually, in this guard here,
this check is redundant in that sense.

00:20:36,830 --> 00:20:43,460
That is because, anyway, we reach the second
line only if this first one was not valid.

00:20:43,460 --> 00:20:50,380
And somewhat similarly, we can argue that in
the last line we don't have to check this,

00:20:50,380 --> 00:20:55,680
because if this wouldn't be true, then we
would have already taken the case before that.

00:20:55,680 --> 00:21:01,530
So, by writing "otherwise" here, we express
the same conditions, and we help the compiler

00:21:01,530 --> 00:21:08,010
to know that this is a valid and full expression.

00:21:08,010 --> 00:21:16,070
So, we avoided syntactic repetition, we avoided
redundant checks by exploiting the order and

00:21:16,070 --> 00:21:20,220
what we know about exhaustiveness.

00:21:20,220 --> 00:21:26,330
And in some way, I would argue that we
also made the definition more readable.

00:21:26,330 --> 00:21:31,520
So, you might try to apply strategies like
this in your next exercise tasks, when you

00:21:31,520 --> 00:21:37,420
have complex conditions like above.

66 # slide
00:21:37,420 --> 00:21:43,290
Let us look at a few more examples and
different ways of writing definitions.

00:21:43,290 --> 00:21:49,570
So far, we have always considered the case
that we basically have one "function head",

00:21:49,570 --> 00:21:52,230
if you want, and then possibly several guards.

00:21:52,230 --> 00:21:56,680
Actually, we can also write several
lines for a function definition.

00:21:56,680 --> 00:22:02,100
So, instead of having "factorial n" and then
this guard and this guard, we could also have

00:22:02,100 --> 00:22:03,320
this head several times.

00:22:03,320 --> 00:22:09,490
So, saying: factorial n under the condition
that n equals zero is one, and factorial n

00:22:09,490 --> 00:22:14,530
under the condition "otherwise"
(which isn't really a condition,

00:22:14,530 --> 00:22:16,640
because it is always true),
computes n * factorial (n – 1).

00:22:16,640 --> 00:22:19,890
So, this would be equivalent to
the versions we have seen before.

00:22:19,890 --> 00:22:24,790
Why would we even do this (to
write this several times)?

00:22:24,790 --> 00:22:30,750
Well, thanks to the top-down evaluation
order, regarding selecting cases, we can then,

00:22:30,750 --> 00:22:33,240
for example, write it also like this.

00:22:33,240 --> 00:22:38,860
Which might be more appealing, to say: factorial
n under some condition is one, and factorial

00:22:38,860 --> 00:22:42,160
n without any condition is this.

00:22:42,160 --> 00:22:46,730
And since this evaluates from top to bottom,
it has the same semantics as what we have

00:22:46,730 --> 00:22:49,420
written up here.

00:22:49,420 --> 00:22:54,920
It's also, of course again,
vulnerable to changes of the order.

00:22:54,920 --> 00:22:59,750
So, if we change orders here, then that might
completely change what is computed, or whether

00:22:59,750 --> 00:23:01,630
it terminates.

00:23:01,630 --> 00:23:09,540
Another syntactic option is something like a
check like this: factorial n under the condition

00:23:09,540 --> 00:23:11,880
that n equals zero, is something.

00:23:11,880 --> 00:23:15,060
This condition "n == 0" in mathematics,
you would write differently.

00:23:15,060 --> 00:23:17,270
You would simply say: factorial of zero is
one.

00:23:17,270 --> 00:23:21,130
Instead of saying: factorial of
n, if that equals zero, is one.

00:23:21,130 --> 00:23:24,210
Then we can write the first line also like
this.

00:23:24,210 --> 00:23:28,740
And then, it really pays off that we write
several lines instead of relying on guards.

00:23:28,740 --> 00:23:34,470
Here, we say: factorial of zero is
one, and factorial of n is this.

00:23:34,470 --> 00:23:41,460
And since we check from top to bottom, actually
the last line means factorial for any non-zero

00:23:41,460 --> 00:23:44,240
n, because zero is already dealt with here.

00:23:44,240 --> 00:23:49,760
And this is now again something that you would
also find similarly written in a textbook

00:23:49,760 --> 00:23:52,520
definition (in mathematics)
of the factorial function.

00:23:52,520 --> 00:23:57,750
It says: factorial 0 is this and factorial
of n (in the background: for any other thing

00:23:57,750 --> 00:24:00,750
than zero) is this expression.

00:24:00,750 --> 00:24:05,510
You can mix these styles and find, for your
function that you want to express, what is

00:24:05,510 --> 00:24:12,280
the nicest way to express the case distinctions
that you need for solving your problem.

00:24:12,280 --> 00:24:13,490
This can be mixed.

00:24:13,490 --> 00:24:19,080
So, let's look at another example, where we
have several input values and then we also

00:24:19,080 --> 00:24:28,650
mix this kind of guard style and
matching-against-constants style.

67 # slide
00:24:28,650 --> 00:24:29,830
This is such an example.

00:24:29,830 --> 00:24:37,930
This is the Ackermann function that you might
know from your lecture on complexity theory.

00:24:37,930 --> 00:24:40,000
And even if you don't, it
is not really important.

00:24:40,000 --> 00:24:43,530
It's a function that has some
interesting and complex conditions.

00:24:43,530 --> 00:24:45,220
So, it has different base cases.

00:24:45,220 --> 00:24:50,680
Either the first or the second input is zero,
but there are also some conditions on the

00:24:50,680 --> 00:24:53,540
other input in each case.

00:24:53,540 --> 00:24:58,520
You can express both, the matching against the
constant, but also the additional condition

00:24:58,520 --> 00:25:00,450
on the other input.

00:25:00,450 --> 00:25:01,960
And here it is the other way around.

00:25:01,960 --> 00:25:07,610
We have the condition by a constant match
on the second argument, and some explicitly

00:25:07,610 --> 00:25:11,510
formulated constraints on the first input.

00:25:11,510 --> 00:25:18,480
And there is also a case where we
have numeric checks on both inputs.

00:25:18,480 --> 00:25:22,600
Then in each case, we have some
expression that needs to be computed.

00:25:22,600 --> 00:25:26,200
It doesn't really matter what the function
exactly does; the point is, we have this way

00:25:26,200 --> 00:25:29,120
of expressing our conditions.

00:25:29,120 --> 00:25:31,880
And again, this is matched from top to bottom.

00:25:31,880 --> 00:25:36,740
So, if the first input is zero and the second
one is a non-negative number, then the first

00:25:36,740 --> 00:25:38,940
base case will be taken.

00:25:38,940 --> 00:25:44,720
And if you try this with GHC, then you will
get some non-exhaustiveness warnings because

00:25:44,720 --> 00:25:51,510
the compiler, here again, will try to find
out whether you have matched all cases or

00:25:51,510 --> 00:25:52,510
not.

00:25:52,510 --> 00:25:57,390
You might want to take a look at the warnings
and try to interpret them to see how far

00:25:57,390 --> 00:26:03,370
the compiler has managed to analyze this
program and the different cases that occur here.

68 # slide
00:26:03,370 --> 00:26:08,440
That was just an example.

00:26:08,440 --> 00:26:11,350
Let us actually return to some general remarks.

00:26:11,350 --> 00:26:16,290
And this will be almost the end of this video.

00:26:16,290 --> 00:26:21,810
So, let's recap what the general
rules for function definitions are.

00:26:21,810 --> 00:26:23,110
We can have one or more equations.

00:26:23,110 --> 00:26:24,110
We started with one.

00:26:24,110 --> 00:26:27,580
But now we have seen that we can have
several equations for one function.

00:26:27,580 --> 00:26:29,910
And they will be checked from top to bottom.

00:26:29,910 --> 00:26:39,080
And these equations can have guards, but they
don't have to, as we have just seen with the

00:26:39,080 --> 00:26:40,580
factorial function.

00:26:40,580 --> 00:26:43,810
There can be one or more arguments.

00:26:43,810 --> 00:26:49,290
So far, these arguments will be variable names on
which maybe you want to express some conditions

00:26:49,290 --> 00:26:55,990
via guards, or they can be constants like
zero or one that we have seen in some of the

00:26:55,990 --> 00:26:56,990
examples.

00:26:56,990 --> 00:26:58,370
The variable names can be anonymous.

00:26:58,370 --> 00:27:05,550
That means, as you will see in an example
shortly on the last slide for today, we can

00:27:05,550 --> 00:27:09,630
have cases where we can match against a variable,
but we will never use this variable again.

00:27:09,630 --> 00:27:13,560
And then, in order not to have the compiler
complain that we named a variable that we

00:27:13,560 --> 00:27:18,510
are not using, we can use the "_" as
a variable that we will never use.

00:27:18,510 --> 00:27:25,300
This will be useful, as you
will see on the next slide.

00:27:25,300 --> 00:27:28,200
Inside one equation, the variable
names have to be unique.

00:27:28,200 --> 00:27:33,390
So, as we saw a few slides back, we can have
two equations for factorial with the same

00:27:33,390 --> 00:27:35,870
variable name, but these are different equations.

00:27:35,870 --> 00:27:39,300
In one equation, we can't have
TWICE THE SAME variable name.

00:27:39,300 --> 00:27:42,420
We can't have ackermann of
n and n (ackermann n n).

00:27:42,420 --> 00:27:46,630
We can have ackermann of n and
m, but not ackermann of n and n.

00:27:46,630 --> 00:27:50,260
Because in one line, in one equation,
the variable names must be unique.

00:27:50,260 --> 00:27:53,290
This does not apply to anonymous variables.

00:27:53,290 --> 00:28:00,480
We can have several anonymous variables in
one line, and this does not somehow pose a

00:28:00,480 --> 00:28:01,480
danger.

00:28:01,480 --> 00:28:07,170
And finally, this is maybe not something that
you would try, but in case you would (because

00:28:07,170 --> 00:28:13,500
maybe you have seen mathematical definitions
that use a feature like "solving conditions

00:28:13,500 --> 00:28:20,750
on inputs via mathematical expressions"):

00:28:20,750 --> 00:28:27,220
Something like a function definition in mathematics
which says, for example, f(2*n)= ... (something

00:28:27,220 --> 00:28:33,460
which involves "f(n)"); this is a definition
kind that people sometimes write in mathematics

00:28:33,460 --> 00:28:39,140
(because maybe they want to define a function
for all even integers, so they say: f(2*n)=

00:28:39,140 --> 00:28:41,400
...); but this is not something
that Haskell would accept.

00:28:41,400 --> 00:28:46,520
Because then, Haskell would have to work out
from some given input like 12 whether this

00:28:46,520 --> 00:28:47,740
matches 2 * n or not.

00:28:47,740 --> 00:28:53,820
So, Haskell would actually have to solve arithmetic
equations in a way that is not as generally

00:28:53,820 --> 00:28:56,020
possible as one would want in a compiler.

00:28:56,020 --> 00:28:57,270
So, it is not possible.

00:28:57,270 --> 00:29:03,000
So, in these argument positions, we can have
simple things, like constants, variable names,

00:29:03,000 --> 00:29:09,070
later also some patterns over datatypes, but
not something like an arithmetic expression

00:29:09,070 --> 00:29:12,080
of arbitrary kind, like 2 * n.

00:29:12,080 --> 00:29:21,200
Because that would require "solving" equations,
just for deciding which function definition

00:29:21,200 --> 00:29:25,530
to take for a certain input situation.

00:29:25,530 --> 00:29:28,830
This is just a side remark.

00:29:28,830 --> 00:29:33,350
Let me actually finish by, mainly,
showing an example for this.

00:29:33,350 --> 00:29:35,100
What do I mean by anonymous variables?

00:29:35,100 --> 00:29:38,000
And why are they useful?

69 # slide
00:29:38,000 --> 00:29:42,020
Well, let's consider this example.

00:29:42,020 --> 00:29:50,720
So, let's say we want to define the
logic operations on the Boolean type.

00:29:50,720 --> 00:29:53,410
We could say "not True = False"
and "not False = True".

00:29:53,410 --> 00:29:58,860
But actually, in the second line, we don't
have to write "not False = True", because

00:29:58,860 --> 00:30:04,040
the only thing that can be here would be
"False", because "True" is already handled.

00:30:04,040 --> 00:30:10,220
Then we could say: Well, let's write
"not x = True", so using a variable named x here.

00:30:10,220 --> 00:30:14,610
But this also would not be so nice, because
then the x is unused on the right-hand side.

00:30:14,610 --> 00:30:18,800
And with certain settings, the compiler would
even complain that you introduce a variable

00:30:18,800 --> 00:30:22,520
x, but then in the scope you
don't even make use of the x.

00:30:22,520 --> 00:30:25,600
And then the solution is "_", which
basically says "I don't care".

00:30:25,600 --> 00:30:30,860
So, "not" of "True" is "False", and "not" of
whatever is "True", which, given the order

00:30:30,860 --> 00:30:34,140
in which it is evaluated,
is a perfect definition.

00:30:34,140 --> 00:30:37,450
And it's also very intuitively written.

00:30:37,450 --> 00:30:41,200
And similarly, you could proceed
for other logical operations.

00:30:41,200 --> 00:30:46,790
So, let's say, for example, we want to
implement the conjunction of Boolean values.

00:30:46,790 --> 00:30:51,380
Then we could say: "True and True is True",
and we could write three cases like "True

00:30:51,380 --> 00:30:55,150
and False is False", "False and True is
False", and "False and False is False".

00:30:55,150 --> 00:30:59,970
But why should we do this if we can also
say: "whatever and whatever is False", given

00:30:59,970 --> 00:31:03,060
that "True and True" has already
been checked by the first line?

00:31:03,060 --> 00:31:09,070
Then this very compactly
defines how conjunction works.

00:31:09,070 --> 00:31:14,490
And similarly, we could use a different style.

00:31:14,490 --> 00:31:20,040
We could say: "b and True is b" and
"whatever and whatever is False".

00:31:20,040 --> 00:31:23,040
Then we would handle two cases in the first
line.

00:31:23,040 --> 00:31:32,260
It is maybe a matter of taste, a bit,
which of these two versions to choose.

00:31:32,260 --> 00:31:35,660
It's not really important
for your exercise tasks.

00:31:35,660 --> 00:31:41,820
In reality, there is a slight difference between
these two versions of the function, in particular

00:31:41,820 --> 00:31:47,780
if you combine it with expensive computations
like the Ackermann function in one of the

00:31:47,780 --> 00:31:48,970
argument positions.

00:31:48,970 --> 00:31:57,620
But these will be cases that won't appear
in the ways you, for example, want to use

00:31:57,620 --> 00:31:59,760
conjunction and combining conditions.

00:31:59,760 --> 00:32:03,710
So, I will not talk further about this part.
