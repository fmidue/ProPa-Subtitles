49 # slide
00:00:01,370 --> 00:00:06,620
Zunächst einmal muss ich
mich ein wenig korrigieren:

00:00:06,620 --> 00:00:15,370
Ich habe im vorigen Video gesagt, dass ich die
letzte Vorlesungswoche mit der Folie zum Verschieben

00:00:15,370 --> 00:00:22,420
von if-then-else-Ausdrücken in und aus
Funktionsargumentpositionen abgeschlossen habe.

00:00:22,420 --> 00:00:23,610
Das war eigentlich nicht richtig.

00:00:23,610 --> 00:00:27,420
Das war Folie 43, während die Vorlesung
der letzten Woche mit Folie 48 endete.

00:00:27,420 --> 00:00:33,340
Es gab also noch etwas anderes Material
danach, nämlich über die Syntax zu sprechen.

00:00:33,340 --> 00:00:42,210
Ich möchte hier noch eine weitere
Beobachtung aus den Übungen machen.

00:00:42,210 --> 00:00:49,039
Eigentlich ist das nicht genau aus den diesjährigen
Übungsaufgaben, sondern aus einer Aufgabe, die dem

00:00:49,039 --> 00:00:52,170
Beispiel "bewegte Sonne"
vom letzten Jahr ähnelt.

00:00:52,170 --> 00:00:55,699
Es gab eine Beobachtung, die ich hier noch einmal
machen möchte, auch wenn es nicht genau das

00:00:55,699 --> 00:01:01,660
Beispiel ist, das in den
diesjährigen Übungen verwendet wurde.

00:01:01,660 --> 00:01:04,680
Es geht um gemeinsame Unterausdrücke.

00:01:04,680 --> 00:01:08,571
So taucht es hier im Fall eines if-then-else
auf, aber das ist nicht der Hauptpunkt.

00:01:08,571 --> 00:01:11,550
Es geht um gemeinsame Unterausdrücke.

00:01:11,550 --> 00:01:19,870
Auch Marcellus und Oliver haben darüber in ihren
Videos gesprochen, über das Verschieben von

00:01:19,870 --> 00:01:25,390
Ausdrücken, die wiederholt vorkommen,
in irgendwie benannte Entitäten.

00:01:25,390 --> 00:01:29,530
Und das wurde dort für das Gras, für
die Sonne, für Äste usw. verwendet.

00:01:29,530 --> 00:01:32,130
Also im Grunde für konstante Ausdrücke.

00:01:32,130 --> 00:01:37,630
Aber das Konzept der Eliminierung gemeinsamer Unterausdrücke
gilt auch für Ausdrücke, die Variablen enthalten.

00:01:37,630 --> 00:01:39,570
Und das wird
hier sehr schön illustriert.

00:01:39,570 --> 00:01:41,240
Betrachten wir dieses Beispiel.

00:01:41,240 --> 00:01:45,910
Es gab eine "scene"-Berechnung und irgendwie hatte sie
etwas mit Rotation oder dem Verschieben von Dingen

00:01:45,910 --> 00:01:46,910
zu tun.

00:01:46,910 --> 00:01:58,210
Es gab also eine Bedingung: wenn 8 * sin t > 0,
dann mache etwas (wobei sin und cos verwendet

00:01:58,210 --> 00:02:00,010
werden), und sonst mache etwas anderes.

00:02:00,010 --> 00:02:01,810
Das ist aber nicht wirklich wichtig.

00:02:01,810 --> 00:02:03,220
Vielleicht war das hier "blank".

00:02:03,220 --> 00:02:04,400
Vielleicht auch etwas anderes.

00:02:04,400 --> 00:02:07,930
Wichtig ist, dass hier eine
Neuberechnung stattgefunden hat.

00:02:07,930 --> 00:02:13,489
Also wird dieser Wert hier berechnet, und dann,
zumindest wenn er positiv ist, wird der "then"-Zweig

00:02:13,489 --> 00:02:16,150
genommen, und es wird wieder berechnet.

00:02:16,150 --> 00:02:19,430
Es ist keine sehr teure Berechnung.

00:02:19,430 --> 00:02:24,780
Ja, nur den Sinus zu berechnen, ist vielleicht
nicht der problematischste Fall, aber es wäre sowohl

00:02:24,780 --> 00:02:29,769
effizienter als auch klarer zu sagen:
Lasst uns diesen Dingen Namen geben.

00:02:29,769 --> 00:02:35,849
Wir können einfach Dinge benennen, die keine anderen
Variablen enthalten, aber wir können natürlich auch

00:02:35,849 --> 00:02:40,420
die Unterausdrücke "8 * cos
t" und "8 * sin t" benennen.

00:02:40,420 --> 00:02:44,959
Und dann wird es klarer, denn dann können wir sehen,
dass wir tatsächlich prüfen, ob die y-Koordinate

00:02:44,959 --> 00:02:52,249
größer als null ist, dann verschieben wir das, was
wir hier hatten, an die x- und y-Position, ansonsten

00:02:52,249 --> 00:02:53,349
machen wir etwas anderes.

00:02:53,349 --> 00:02:58,060
Das ist also sowohl klarer (die zweite
Version) als auch etwas effizienter.

00:02:58,060 --> 00:03:06,390
Denn wir berechnen nicht zweimal
denselben mathematischen Ausdruck.

00:03:06,390 --> 00:03:10,920
Es gibt eine Befürchtung, die manchmal an dieser Stelle
auftaucht, vielleicht auch der Grund, warum der Student,

00:03:10,920 --> 00:03:17,569
der diesen Code ursprünglich geschrieben hatte,
diese Umbenennung nicht vorgenommen hat, nämlich dass

00:03:17,569 --> 00:03:23,219
wir im "else"-Zweig vielleicht den
Kosinus (den x-Wert) nicht brauchen.

00:03:23,219 --> 00:03:27,180
Also, hier sagen wir: Wenn diese Bedingung wahr
ist, dann berechnen wir das, und dann müssen wir

00:03:27,180 --> 00:03:28,920
das ein zweites Mal berechnen.

00:03:28,920 --> 00:03:31,840
Aber wenn diese Bedingung falsch ist,
dann gehen wir in den "else"-Zweig.

00:03:31,840 --> 00:03:34,900
Und vielleicht haben wir im "else"-Zweig
nicht den Kosinus oder den Sinus.

00:03:34,900 --> 00:03:36,569
Vielleicht ist der
"else"-Zweig wirklich "blank".

00:03:36,569 --> 00:03:41,529
Dann könnte man argumentieren, dass wir hier zwar
das x und das y berechnen, und dann prüfen, ob

00:03:41,529 --> 00:03:46,139
das y positiv ist (wenn ja, dann verwenden wir
natürlich das x und das y), und ansonsten tun wir

00:03:46,139 --> 00:03:50,540
nichts (wir haben das "blank"); warum
haben wir dann die Berechnung von x?

00:03:50,540 --> 00:03:54,939
Das ist eine Sorge, die Studierende an
dieser Stelle haben könnten oder hatten.

00:03:54,939 --> 00:03:57,669
Und nun, diese Sorge ist unbegründet.

00:03:57,669 --> 00:03:58,669
Warum?

00:03:58,669 --> 00:03:59,709
Weil wir uns nicht in einer
imperativen Sprache befinden.

00:03:59,709 --> 00:04:03,349
Es ist also gar nicht wahr, dass wir
an dieser Stelle x und y berechnen.

00:04:03,349 --> 00:04:04,530
Es handelt sich
nicht um eine Variablenzuweisung.

00:04:04,530 --> 00:04:09,590
Es ist nicht so, dass Sie durch dieses Stück
Code gehen und diesen Wert berechnen, ihn

00:04:09,590 --> 00:04:15,620
x zuweisen, diesen Wert berechnen, ihn y zuweisen, die
Prüfung durchführen. Und wenn wir im "else"-Zweig landen,

00:04:15,620 --> 00:04:21,430
und ein "blank" haben, dann haben
wir das x umsonst berechnet.

00:04:21,430 --> 00:04:25,949
Das ist nicht das, was hier passiert, denn
dies ist kein sequentieller Code, mit dem wir

00:04:25,949 --> 00:04:27,949
dies und das und das berechnen.

00:04:27,949 --> 00:04:29,520
Das sind nur mathematische Definitionen.

00:04:29,520 --> 00:04:37,919
Das heißt also, dass x, wenn Sie es
später brauchen, mit diesem Ausdruck

00:04:37,919 --> 00:04:39,840
ausgewertet wird.

00:04:39,840 --> 00:04:46,199
Es wird also noch gar nicht das x berechnet, sondern nur
deklariert: Wenn x zu irgendeinem Zeitpunkt relevant ist, dann

00:04:46,199 --> 00:04:48,850
ist das der Wert, den es annehmen würde.

00:04:48,850 --> 00:04:49,850
Und das Gleiche gilt für y.

00:04:49,850 --> 00:04:52,250
Dann prüfen wir natürlich das y.

00:04:52,250 --> 00:04:56,340
Das y wird in der Tat berechnet, aber es wird nicht zu
diesem Zeitpunkt berechnet, wenn es deklariert wird.

00:04:56,340 --> 00:04:57,930
Es wird berechnet, wenn
diese Prüfung stattfindet.

00:04:57,930 --> 00:05:01,590
Und natürlich brauchen wir den Wert von y,
um diesen Vergleich durchführen zu können.

00:05:01,590 --> 00:05:05,280
Also wird y berechnet, wenn
wir diese Prüfung durchführen.

00:05:05,280 --> 00:05:08,840
Wenn diese Prüfung positiv ist, dann werden wir
das tun, und dann brauchen wir natürlich das

00:05:08,840 --> 00:05:09,840
x.

00:05:09,840 --> 00:05:10,919
Und dann würde das x berechnet werden.

00:05:10,919 --> 00:05:16,470
Dann wird hier also der cos t berechnet.

00:05:16,470 --> 00:05:21,110
Wenn aber das y nicht positiv
ist, landen wir im "else"-Zweig.

00:05:21,110 --> 00:05:23,030
Der "else"-Zweig ist zum Beispiel "leer".

00:05:23,030 --> 00:05:25,240
Es wird also nicht einmal x erwähnt.

00:05:25,240 --> 00:05:27,990
Dann wird x nie berechnet werden.

00:05:27,990 --> 00:05:33,070
Man muss sich also vom sequenziellen Denken
befreien, wo man, wenn man das sieht, denkt:

00:05:33,070 --> 00:05:38,180
Jetzt berechne ich das teure x, und jetzt berechne
ich das teure y, und dann mache ich etwas mit

00:05:38,180 --> 00:05:39,180
diesen Werten.

00:05:39,180 --> 00:05:42,440
Das ist nicht das, was hier passiert,
denn das ist kein sequentieller Code.

00:05:42,440 --> 00:05:45,930
Es sind mathematische Deklarationen.

00:05:45,930 --> 00:05:51,639
Und wenn das x nicht benötigt wird, weil wir
im "else"-Zweig "blank" haben, dann wird das

00:05:51,639 --> 00:05:55,650
x nie berechnet werden.

50 # slide
00:05:56,650 --> 00:06:00,310
Lassen Sie uns ein
wenig über Typen sprechen.

00:06:00,310 --> 00:06:03,110
Und zunächst einmal über Zahlentypen.

00:06:03,110 --> 00:06:07,940
Das ist auch etwas, was jetzt
vermehrt in den Übungen auftaucht.

00:06:07,940 --> 00:06:11,889
In den ersten Beispielen in CodeWorld ging
es natürlich um Doubles, weil das die

00:06:11,889 --> 00:06:15,520
Einheit ist, in der
in CodeWorld gemessen wird.

00:06:15,520 --> 00:06:22,099
Dann, in der letzten Übungsaufgabe, über die
Liste der natürlichen Zahlen, gab es schon

00:06:22,099 --> 00:06:25,930
diesen 'Integer'-Typ für
nicht-gebrochene Werte (Ganzzahlen).

00:06:25,930 --> 00:06:32,389
Und tatsächlich haben einige Studierende in dieser
Übung bereits Fließkomma- und Ganzzahl-Typen gemischt.

00:06:32,389 --> 00:06:33,389
Das war nicht nötig.

00:06:33,389 --> 00:06:36,050
Es gab eine Möglichkeit, dies nur
mit ganzen Zahlen zu berechnen.

00:06:36,050 --> 00:06:41,130
Aber einige Studierende versuchten, die Konvertierung zu
verwenden, um die Anzahl der Ziffern einer Zahl zu ermitteln.

00:06:41,130 --> 00:06:43,970
Anstatt mit Division und Rundung
von Werten etc. zu arbeiten.

00:06:43,970 --> 00:06:51,490
Sie haben also bereits mit Funktionen gearbeitet,
die zwischen Fließkomma- und Ganzzahlwerten wechseln.

00:06:51,490 --> 00:06:56,320
Sie werden an manchen Stellen beides
brauchen und auch deren Zusammenspiel.

00:06:56,320 --> 00:06:58,020
Wir müssen also darüber sprechen.

00:06:58,020 --> 00:07:02,909
Und es dient auch als erster Einblick in
einige Aspekte der Typen in Haskell, anders

00:07:02,909 --> 00:07:06,070
als das, was Sie bisher an
Funktionstypen gesehen haben.

00:07:06,070 --> 00:07:09,990
Zunächst einmal, von außen betrachtet,
hat Haskell verschiedene Zahlentypen.

00:07:09,990 --> 00:07:14,569
Wie in den meisten Programmiersprachen gibt
es Integer-Typen unterschiedlicher Größe und

00:07:14,569 --> 00:07:17,150
es gibt
Fließkomma-Typen unterschiedlicher Größe.

00:07:17,150 --> 00:07:18,949
Sie sehen hier also Float und Double.

00:07:18,949 --> 00:07:26,270
Die entsprechen in etwa dem, was Sie in
anderen Sprachen mit diesen Typnamen finden.

00:07:26,270 --> 00:07:29,300
Der Typ 'Rational' ist vielleicht nicht
so häufig in anderen Sprachen zu finden.

00:07:29,300 --> 00:07:33,319
Es ist eigentlich ein Typ der rationalen
Zahlen mit beliebiger Genauigkeit.

00:07:33,319 --> 00:07:35,169
Dies sind keine Fließkommazahlen.

00:07:35,169 --> 00:07:39,009
Eigentlich ist jede rationale Zahl
exakt in diesem Typ darstellbar.

00:07:39,009 --> 00:07:43,930
Es gibt also keinen Präzisionsverlust,
wenn man z.B. rationale Zahlen addiert.

00:07:43,930 --> 00:07:47,759
Und auch bei den ganzen Zahlen gibt es diese
interessante Unterscheidung zwischen Int und Integer.

00:07:47,759 --> 00:07:52,729
Und die Art, wie man darüber nachdenkt, ist, dass
Int im Grunde die Maschinen-Ganzzahl ist, also

00:07:52,729 --> 00:07:56,190
etwas, das eine feste Bitlänge
wie 32 oder 64 Bit hat.

00:07:56,190 --> 00:08:04,270
Es gibt also einen endlichen Bereich von
Integer-Zahlen, die in Int dargestellt werden können.

00:08:04,270 --> 00:08:06,650
Integer hingegen ist der
mathematische 'Integer'-Typ.

00:08:06,650 --> 00:08:12,360
Das sind also wirklich beliebig große Integer-Zahlen,
mit einer beliebigen Anzahl von Stellen.

00:08:12,360 --> 00:08:15,939
Und ohne Verlust an Genauigkeit.

00:08:15,939 --> 00:08:18,889
Wir haben also diese verschiedenen Typen.

00:08:18,889 --> 00:08:24,759
Und natürlich können wir unsere Zahlenliterale mit
verschiedenen Typen verwenden, genau wie in anderen Sprachen.

00:08:24,759 --> 00:08:31,760
So kann die Zahl Drei, einfach eine Konstante, die
mit 3 geschrieben wird, ein Int, ein Float, ein

00:08:31,760 --> 00:08:34,580
Integer oder ein Rational
sein, oder viele andere Typen.

00:08:34,580 --> 00:08:39,070
Man sieht also bei einer Zahl nicht,
wie gegeben, welcher Typ sie ist.

00:08:39,070 --> 00:08:41,310
Das ist im
Grunde polymorph oder überladen.

00:08:41,310 --> 00:08:45,880
Es gibt auch Konstanten, die
nicht alle Zahlentypen haben.

00:08:45,880 --> 00:08:51,050
Wenn Sie also 3.5 schreiben, dann weiß der Compiler
(und auch wir), dass es weder ein Int noch ein

00:08:51,050 --> 00:08:52,050
Integer ist.

00:08:52,050 --> 00:08:55,889
3.5 könnte also z. B. ein Float oder
ein Double sein, aber kein Integer.

00:08:55,889 --> 00:08:58,630
Dagegen kann 3 sowohl ein
Integer als auch ein Float sein.

00:08:58,630 --> 00:09:03,570
Das ist auch in anderen
Sprachen eine gängige Praxis.

00:09:03,570 --> 00:09:07,510
Außerdem gibt es, wie in gewissem Sinne
erwartet, Konvertierungsfunktionen.

00:09:07,510 --> 00:09:13,500
Aber wir werden auf der nächsten Folie sehen, dass
sie in manchen Situationen eine etwas andere Rolle

00:09:13,500 --> 00:09:14,500
spielen.

00:09:14,500 --> 00:09:19,730
Aber wenn wir zwischen einigen dieser Zahlentypen
konvertieren müssen, dann können wir das tun.

00:09:19,730 --> 00:09:23,740
Es gibt also Konvertierungsfunktionen,
die nicht an Präzision verlieren.

00:09:23,740 --> 00:09:30,839
Das sind Funktionen, die von Int nach Integer oder anderen
Nicht-Fließkomma-Typen zu einem beliebigen Zahlentyp

00:09:30,839 --> 00:09:31,839
gehen.

00:09:31,839 --> 00:09:35,350
Wenn Sie z. B. von Maschinen-Integer zu diesem
'Integer'-Typ mit beliebiger Genauigkeit gehen wollen,

00:09:35,350 --> 00:09:37,230
dann können Sie die Funktion
"fromIntegral" verwenden.

00:09:37,230 --> 00:09:39,851
Es heißt nicht
"fromInteger" oder so ähnlich.

00:09:39,851 --> 00:09:40,993
Das ist etwas, was Studierende
manchmal verwechseln.

00:09:40,993 --> 00:09:47,370
Denn es gibt auch ältere Versionen von Haskell, in denen
es zwar noch existiert, aber nicht wirklich benutzt

00:09:47,370 --> 00:09:49,110
wird, beziehungsweise größtenteils veraltet ist.

00:09:49,110 --> 00:09:52,840
Es gibt auch eine fromInteger-Funktion.

00:09:52,840 --> 00:09:53,930
Die sollten Sie aber nicht verwenden.

00:09:53,930 --> 00:09:57,370
Sie sollten
die fromIntegral-Funktion verwenden.

00:09:57,370 --> 00:09:58,380
Sie hat viele verschiedene Typen.

00:09:58,380 --> 00:09:59,700
Sie ist auch überladen.

00:09:59,700 --> 00:10:05,790
Sie kann also einen Int in einen Integer, einen Integer
in einen Int, einen Int in eine Rationale und einen Int

00:10:05,790 --> 00:10:09,029
in eine Fließkommazahl/Rationale/Double
konvertieren, wie ich bereits erwähnt habe.

00:10:09,029 --> 00:10:15,670
Es handelt sich also im Grunde um Konvertierungen von einem
'Integer'-Typ in einen anderen Zahlentyp, unabhängig davon, ob

00:10:15,670 --> 00:10:17,320
dieser Zahlentyp ein
'Integer'-Typ ist oder nicht.

00:10:17,320 --> 00:10:18,820
Und hier gibt es
keinen Verlust an Genauigkeit.

00:10:18,820 --> 00:10:21,570
Nun, im Fall von "von Integer zu Int" gibt es
natürlich einen gewissen Verlust an Präzision.

00:10:21,570 --> 00:10:26,850
Den muss es geben, wegen der
eingeschränkten Ausdruckskraft.

00:10:26,850 --> 00:10:31,260
Aber es gibt keinen Präzisionsverlust
in Form von Rundungsfehlern aufgrund

00:10:31,260 --> 00:10:35,560
von Nachkommastellen oder ähnlichem.

00:10:35,560 --> 00:10:38,970
Denn das geht nur von Integer
und ähnlichen Typen aus.

00:10:38,970 --> 00:10:43,760
In der Gegenrichtung gibt es in gewisser Weise Funktionen,
die wirklich einen Rundungsfehler / eine Rundungsdiskrepanz

00:10:43,760 --> 00:10:46,840
haben.

00:10:46,840 --> 00:10:52,410
Denn wenn Sie 3.5 haben und eine Ganzzahl wollen,
dann müssen Sie auf 3 oder 4 gehen, also müssen Sie

00:10:52,410 --> 00:10:53,560
eine Änderung vornehmen.

00:10:53,560 --> 00:10:56,670
Sie können aufrunden, Sie können
abrunden, Sie können abschneiden.

00:10:56,670 --> 00:11:00,800
Und im Grunde gibt es für all diese
verschiedenen Modi Funktionen in Haskell.

00:11:00,800 --> 00:11:07,730
So würde "truncate" von 3.5 auf 3 gehen,
während "round" von 3.5 auf 4 gehen

00:11:07,730 --> 00:11:08,730
würde, wegen des Aufrundens.

00:11:08,730 --> 00:11:13,560
Und "ceiling" und "floor" sind ähnlich wie "truncate",
verhalten sich aber unterschiedlich, je nachdem, ob

00:11:13,560 --> 00:11:18,029
sie negative oder
positive Zahlen erhalten.

00:11:18,029 --> 00:11:23,210
Welche Typen haben diese präzisionsverlierenden
Konvertierungsfunktionen?

00:11:23,210 --> 00:11:26,529
Sie können z. B. von einem
Float zu einem Int konvertieren.

00:11:26,529 --> 00:11:30,860
Denn die Eingabe wäre eine Fließkommazahl,
weil wir etwas wie 3.5 haben.

00:11:30,860 --> 00:11:35,420
Das Ergebnis wird, wieder, ein ganzzahliger
Typ wie 'Int' oder 'Integer' sein.

00:11:35,420 --> 00:11:38,550
Denn nachdem Sie "abgeschnitten" ("truncate"
angewendet) haben, haben Sie eine 3 oder eine 4.

00:11:38,550 --> 00:11:41,459
Sie brauchen also
keine Fließkommazahl mehr.

00:11:41,459 --> 00:11:53,010
Sie können mit diesen Funktionen von diesem
zu einem 'Integer' oder 'Int'-Typ wechseln.

51 # slide
00:11:53,010 --> 00:11:59,890
Neben den Konstanten, die überladen sind, sind
auch die meisten mathematischen Operatoren

00:11:59,890 --> 00:12:00,890
überladen.

00:12:00,890 --> 00:12:07,070
Denn es wäre sehr umständlich und unpraktisch (ist
aber in manchen Sprachen tatsächlich der Fall),

00:12:07,070 --> 00:12:12,399
dass Sie unterschiedliche mathematische
Operatoren benötigen, je nachdem, ob Sie z. B.

00:12:12,399 --> 00:12:14,540
mit Fließkommazahlen oder
Integer-Zahlen arbeiten.

00:12:14,540 --> 00:12:18,730
Es gibt zwar bestimmte Varianten wie eine
spezielle Funktion für Ganzzahldivision in Haskell,

00:12:18,730 --> 00:12:21,060
aber die meisten
der Operatoren sind überladen.

00:12:21,060 --> 00:12:30,360
Wenn Sie also etwas haben wie f x =
2 × x + 3.5, dann müssen Sie nicht

00:12:30,360 --> 00:12:37,040
irgendwie eine eigene Unterscheidung treffen, ob
3.5 eine Fließkommazahl ist oder eine Integer-Zahl.

00:12:37,040 --> 00:12:41,800
In dem Sinne, dass dies vielleicht eine Integer-Multiplikation
ist, dann aber eine Fließkomma-Addition, sodass

00:12:41,800 --> 00:12:43,709
vielleicht eine
Konvertierung nötig wäre.

00:12:43,709 --> 00:12:46,910
Nein, denn diese
Operatoren sind überladen.

00:12:46,910 --> 00:12:49,529
Sie arbeiten mit den richtigen Typen.

00:12:49,529 --> 00:12:54,490
In 3 + 4.5 weiß das "+" also, dass es eine
Fließkomma-Addition sein muss, weil wir

00:12:54,490 --> 00:12:55,490
hier eine Fließkommazahl haben.

00:12:55,490 --> 00:12:59,510
Es weiß auch, dass diese 3, obwohl sie auch
eine Ganzzahl sein könnte, tatsächlich als

00:12:59,510 --> 00:13:02,139
Fließkommazahl 3 genommen wird.

00:13:02,139 --> 00:13:03,990
Und das ist auch der Grund,
warum das funktioniert.

00:13:03,990 --> 00:13:08,360
Und ein passender Typ für f wird vom
Compiler gewählt, wenn Sie so etwas machen.

00:13:08,360 --> 00:13:11,370
Er wird herausfinden, dass das x auch eine
Fließkommazahl sein muss, denn sonst könnten

00:13:11,370 --> 00:13:16,399
Sie es nicht verdoppeln und dann mit
einer Fließkomma-Addition addieren.

00:13:16,399 --> 00:13:22,361
Ähnlich verhält es sich, wenn Sie eine andere Funktion
haben, die f verwendet. Dann wissen wir wiederum

00:13:22,361 --> 00:13:28,399
aus dem, was ich gerade gesagt habe, dass x (das Argument
von f) eine Fließkommazahl sein muss, wegen dieses

00:13:28,399 --> 00:13:29,399
Ausdrucks.

00:13:29,399 --> 00:13:33,600
Und das klappt ganz gut, weil die 4 auch
als Fließkommawert angesehen werden kann.

00:13:33,600 --> 00:13:36,839
Dann wird das Ergebnis von f
auch eine Fließkommazahl sein.

00:13:36,839 --> 00:13:41,699
Das g wird also wissen, dass diese Division
eine Fließkomma-Division sein muss, also muss y

00:13:41,699 --> 00:13:42,699
auch eine Fließkommazahl sein.

00:13:42,699 --> 00:13:48,319
Wenn Sie also so etwas schreiben, dann brauchen
wir nicht zu konvertieren, weil die Sprache sowohl

00:13:48,319 --> 00:13:52,230
die Konstanten als auch die
mathematischen Operationen überlädt.

00:13:52,230 --> 00:13:57,470
Das ist hier der Fall, denn wir überlassen
dem Compiler die Wahl, welche Typen wir

00:13:57,470 --> 00:13:58,470
x und y zuweisen.

00:13:58,470 --> 00:14:03,769
Wir haben keine Typen für f und g aufgeschrieben und
keine Einschränkungen für x und y gemacht, auch nicht

00:14:03,769 --> 00:14:04,880
für das Ergebnis dieser Funktionen.

00:14:04,880 --> 00:14:10,000
Der Compiler kann also durch Überladen
geeignete Zahlentypen für x und y wählen.

00:14:10,000 --> 00:14:14,220
In diesem Fall wird er Fließkommatypen wählen,
aufgrund dessen, was ich gerade erklärt habe.

00:14:14,220 --> 00:14:21,079
Wenn wir hingegen explizite Funktionstypen
schreiben und diese auch die Ein- und

00:14:21,079 --> 00:14:27,380
Ausgabetypen einschränken, zum Beispiel auf
Ganzzahlen, dann müssen wir konvertieren.

00:14:27,380 --> 00:14:32,570
Um dies zu verdeutlichen, schauen
wir uns ein ähnliches Beispiel an.

00:14:32,570 --> 00:14:36,800
Schauen wir uns zunächst das hier an.

00:14:36,800 --> 00:14:40,339
Nehmen wir an, ich möchte, dass f eine
Funktion von Integer nach Float ist.

00:14:40,339 --> 00:14:48,970
Wenn ich dann den gleichen Ausdruck wie hier verwenden
möchte, muss ich tatsächlich sicherstellen, dass

00:14:48,970 --> 00:14:51,589
dieser Wert an dieser Stelle
ein Fließkommawert ist.

00:14:51,589 --> 00:14:54,130
Und das ist er nicht.

00:14:54,130 --> 00:14:58,250
Wenn ich sage, f geht von Integer
zu Float, dann wäre x ein Integer.

00:14:58,250 --> 00:15:01,860
Um es dann für eine Fließkomma-Multiplikation
zu verwenden, was ich tun muss, weil

00:15:01,860 --> 00:15:06,410
ich anschließend eine Fließkomma-Addition
machen will, dann muss ich dieses x von Int in

00:15:06,410 --> 00:15:07,889
eine Fließkommazahl umwandeln.

00:15:07,889 --> 00:15:12,029
Und das kann "fromIntegral" tun, denn wie ich
auf der vorherigen Folie sagte, kann dieses

00:15:12,029 --> 00:15:15,110
"fromIntegral" von Typen wie Int oder Integer
zu jedem geeigneten anderen Typ gehen.

00:15:15,110 --> 00:15:16,870
Es könnte also zu Float gehen.

00:15:16,870 --> 00:15:19,019
Das wird also funktionieren.

00:15:19,019 --> 00:15:21,550
Und das ist dann
eine Art von Konvertierung.

00:15:21,550 --> 00:15:25,279
Ja, es ist keine syntaktische
Konvertierung, wie sie in C vorkommt.

00:15:25,279 --> 00:15:27,600
Es ist eine Funktion, die
diese Konvertierung durchführt.

00:15:27,600 --> 00:15:33,149
Es ist also nicht irgendwie ein
eingebautes extra syntaktisches Konstrukt.

00:15:33,149 --> 00:15:35,839
Und ähnlich ist es, wenn ich
etwa ein Beispiel wie oben mache:

00:15:35,839 --> 00:15:43,000
Das f x ist also wieder frei in der Wahl
seines Typs, aber irgendwie möchte ich

00:15:43,000 --> 00:15:50,040
in der zweiten Funktion statt des Wertes 4
hier die Länge der Zeichenkette "abcd" haben.

00:15:50,040 --> 00:15:54,850
Nun müsste ich wissen, dass die Längen-Funktion in
Haskell eine Funktion ist, die in diesem Fall einen

00:15:54,850 --> 00:15:56,970
String nimmt und
eine natürliche Zahl liefert.

00:15:56,970 --> 00:16:00,680
Sie liefert keine Fließkommazahl, weil "length"
bei einem ganzzahligen Ergebnis mehr Sinn macht.

00:16:00,680 --> 00:16:01,680

00:16:01,680 --> 00:16:06,690
Wenn ich also so etwas schreibe (ich ersetze
also die 4 durch die Länge von "abcd"), dann

00:16:06,690 --> 00:16:07,690
muss ich wieder konvertieren.

00:16:07,690 --> 00:16:08,690
Und warum?

00:16:08,690 --> 00:16:12,050
Weil hier die 4 keinen Typ hatte, also hat
der Compiler per Überladung entschieden:

00:16:12,050 --> 00:16:14,399
"Also, ich betrachte diese
4 als eine Fließkommazahl."

00:16:14,399 --> 00:16:17,070
Das geht hier nicht, wenn ich sage, es
ist das Ergebnis der length-Funktion.

00:16:17,070 --> 00:16:20,279
Die length-Funktion gibt
immer eine ganze Zahl zurück.

00:16:20,279 --> 00:16:25,220
Wenn ich sie dann als Argument für f verwenden
will, und der Compiler hat für f aufgrund

00:16:25,220 --> 00:16:30,810
dieses Zusatzes hier abgeleitet, dass das
Argument eine Fließkommazahl sein muss, dann muss

00:16:30,810 --> 00:16:35,029
ich dafür sorgen, dass ich meine Ganzzahl
(die aus der length-Funktion kommt) in diesen

00:16:35,029 --> 00:16:36,029
Fließkomma-Typ einbette.

00:16:36,029 --> 00:16:37,889
Und das kann ich wiederum
mit "fromIntegral" machen.

00:16:37,889 --> 00:16:42,449
Ich bräuchte hier
also wieder eine Konvertierung.

00:16:42,449 --> 00:16:44,279
An dieser Stelle
fragen nun manchmal Studierende:

00:16:44,279 --> 00:16:48,759
"Warum muss ich hier diese expliziten Konvertierungen
machen, während sie hier irgendwie versteckt sind?

00:16:48,759 --> 00:16:52,600
Vielleicht führt der Compiler
hier stille Konvertierungen ein."

00:16:52,600 --> 00:16:54,380
Aber so sollte man das nicht sehen.

00:16:54,380 --> 00:16:59,220
Es ist nicht so, dass wir hier explizite
Konvertierungen haben, und hier irgendwie versteckte

00:16:59,220 --> 00:17:00,220
Konvertierungen.

00:17:00,220 --> 00:17:01,220
Nein.

00:17:01,220 --> 00:17:02,220
Was tatsächlich passiert, ist:

00:17:02,220 --> 00:17:06,130
Hier brauchen wir Konvertierungen, hier
brauchen wir keine Konvertierungen.

00:17:06,130 --> 00:17:07,900
Es gibt also
keine versteckten Konvertierungen.

00:17:07,900 --> 00:17:11,740
Indem wir einfach keine Typen für f und g angeben,
überlassen wir dem Compiler die Wahl der Typen.

00:17:11,740 --> 00:17:15,959
Und der Compiler kann in diesem Fall die
Typen so wählen, dass keine Konvertierungen

00:17:15,959 --> 00:17:16,959
notwendig sind.

00:17:16,959 --> 00:17:19,319
Denn der Compiler entscheidet
einfach, dass x ein Float ist.

00:17:19,319 --> 00:17:21,970
Dann ist eine Konvertierung nicht nötig.

00:17:21,970 --> 00:17:25,559
Wenn wir sagen "Nein, das x ist ein Integer",
dann ist eine Konvertierung notwendig.

00:17:25,559 --> 00:17:28,100
Und der Compiler führt die
Konvertierung nicht von sich aus ein.

00:17:28,100 --> 00:17:29,340
Wir müssen sie schreiben.

00:17:29,340 --> 00:17:42,850
Andernfalls würde sie die Typendisziplin in
Haskell (auch für Zahlentypen) unterlaufen.

52 # slide
00:17:42,850 --> 00:17:47,669
Nur der Vollständigkeit halber: Es gibt tatsächlich
einige Operatoren, die nicht vollständig überladen

00:17:47,669 --> 00:17:48,669
sind.

00:17:48,669 --> 00:17:50,920
Sie sind also nicht
bei allen Typen verfügbar.

00:17:50,920 --> 00:17:52,299
Und die Division
ist eines dieser Beispiele.

00:17:52,299 --> 00:18:01,190
Das Divisionssymbol, wie Sie es wahrscheinlich
in vielen Sprachen gewohnt sind, ist bei

00:18:01,190 --> 00:18:03,160
ganzzahligen Typen nicht verfügbar.

00:18:03,160 --> 00:18:05,450
Es ist eine Operation im
Stil der Fließkommazahlen.

00:18:05,450 --> 00:18:10,770
Sie funktioniert zwar auf den rationalen
Zahlen, aber nicht auf Integer-Typen.

00:18:10,770 --> 00:18:12,170
Was haben wir stattdessen?

00:18:12,170 --> 00:18:15,000
Wir haben
eine spezielle Divisionsfunktion.

00:18:15,000 --> 00:18:17,960
Dieser Operator "div" ist auch
aus anderen Sprachen bekannt.

00:18:17,960 --> 00:18:23,210
Er operiert auf Int oder Integer,
aber z. B. nicht auf Fließkommazahlen.

00:18:23,210 --> 00:18:27,650
Es ist also wirklich eine andere Operation, ein
anderes Symbol als das Schrägstrich-Symbol für

00:18:27,650 --> 00:18:30,340
die Division auf Fließkommazahlen.

00:18:30,340 --> 00:18:40,429
Ein netter syntaktischer Trick ist, dass binäre Funktionen
wie "div", aber auch alle nicht-arithmetischen Funktionen,

00:18:40,429 --> 00:18:41,600
wie Operatoren verwendet werden können.

00:18:41,600 --> 00:18:46,250
Während es also in Haskell keinen Schrägstrich-Operator für
Division gibt, kann diese Funktion als Operator verwendet werden,

00:18:46,250 --> 00:18:50,860
indem man sie einfach infix und
mit diesen Backticks schreibt.

00:18:50,860 --> 00:18:52,539
Aber das ist nur syntaktischer Zucker.

00:18:52,539 --> 00:18:59,880
Für "17 `div` 3", so geschrieben, weiß der Compiler
also, dass es dasselbe ist, wie die Anwendung

00:18:59,880 --> 00:19:04,620
der binären Funktion "div" auf 17
und 3 als ihre beiden Argumente.

00:19:04,620 --> 00:19:08,980
Es ist nur eine
andere Art, es zu schreiben.

00:19:08,980 --> 00:19:12,580
Es handelt sich nicht um einen
neuen Operator oder Ähnliches.

00:19:12,580 --> 00:19:15,490
Und eine weitere nützliche Sache ist natürlich, dass es
viele weitere mathematische Konstanten und Funktionen

00:19:15,490 --> 00:19:16,490
gibt.

00:19:16,490 --> 00:19:17,490
Einige von ihnen
haben wir bereits gesehen.

00:19:17,490 --> 00:19:18,490
Ich habe die mathematische
Konstante pi verwendet.

00:19:18,490 --> 00:19:19,490
Ich habe diese Sinusfunktion benutzt.

00:19:19,490 --> 00:19:24,110
Es gibt auch diese Funktion für die Quadratwurzel;
Minimum- und Maximum-Funktionen auf ganzen Zahlen

00:19:24,110 --> 00:19:25,320
und anderen Typen.

00:19:25,320 --> 00:19:33,919
Es gibt also eine Menge Funktionen, und sie haben die
erwarteten Namen, ähnlich wie die mathematischen Bibliotheken in

00:19:33,919 --> 00:19:35,090
anderen Sprachen.

00:19:35,090 --> 00:19:38,010
Ich werde sie nicht alle vorstellen, sie
werden einfach in Beispielen auftauchen.

00:19:38,010 --> 00:19:44,730
Wenn Sie also einen Bedarf haben, dann schauen Sie vielleicht
in irgendeiner Haskell-Bibliothek oder der Standardbibliothek

00:19:44,730 --> 00:19:47,300
nach, welche Funktion Sie für
einen bestimmten Zweck benötigen.

00:19:47,300 --> 00:19:54,450
Ich werde also keine vollständige
Liste oder Ähnliches geben.

00:19:54,450 --> 00:19:57,909
Das sollte nicht nötig sein.

53 # slide
00:19:57,909 --> 00:20:04,120
Lassen Sie mich noch im Zusammenhang mit Zahlentypen
eine Beobachtung machen, die auf den Übungen der letzten

00:20:04,120 --> 00:20:05,120
Jahre basiert.

00:20:05,120 --> 00:20:10,620
Also, das ist auch etwas, was jetzt wahrscheinlich
wieder in Übungsaufgaben auftauchen wird.

00:20:10,620 --> 00:20:14,140
Ich erwähnte die
Notwendigkeit der Umrechnung.

00:20:14,140 --> 00:20:19,260
Und die allgemeine Strategie, um damit in Ihren nächsten
Übungsaufgaben umzugehen, in denen Sie vielleicht

00:20:19,260 --> 00:20:25,940
sowohl Integer- als auch Fließkommatypen
antreffen, ist, dass es normalerweise nicht

00:20:25,940 --> 00:20:27,790
schadet, einige
"fromIntegral"-Aufrufe hinzuzufügen.

00:20:27,790 --> 00:20:29,140
Warum ist das so?

00:20:29,140 --> 00:20:31,510
Sie können viele
verschiedene Typen haben.

00:20:31,510 --> 00:20:34,620
So haben sie unter anderem
Typen wie "Int → Int".

00:20:34,620 --> 00:20:40,250
Wenn Sie also etwas haben, das vielleicht in einer
List Comprehension aus einer Generatorliste zieht,

00:20:40,250 --> 00:20:41,720
0 bis 10 oder so ähnlich:

00:20:41,720 --> 00:20:45,020
Es wäre ein Int, aber vielleicht
müssen Sie es als Double verwenden.

00:20:45,020 --> 00:20:49,590
Dann schadet es nicht, ein "fromIntegral" auf
die Variable zu setzen, die Sie aus dieser "0

00:20:49,590 --> 00:20:50,789
bis 10"-Liste ziehen.

00:20:50,789 --> 00:20:53,830
Denn entweder wird sie als Int verwendet,
und das ist in Ordnung, denn "fromIntegral"

00:20:53,830 --> 00:20:57,900
verwandelt Int in Int (es hat sich nichts geändert),
oder sie wird als Double verwendet, und dann ist

00:20:57,900 --> 00:21:01,290
auch alles in Ordnung, denn Sie haben diesen
"fromIntegral"-Aufruf hinzugefügt, der den Integer

00:21:01,290 --> 00:21:03,470
tatsächlich in einen Double
verwandelt, zum Beispiel.

00:21:03,470 --> 00:21:07,910
In diesem Sinne ist "fromIntegral"
im schlimmsten Fall eine No-Op.

00:21:07,910 --> 00:21:12,460
Es schadet also nicht wirklich, ihn an bestimmten Stellen
hinzuzufügen, insbesondere, wenn Sie Fehlermeldungen

00:21:12,460 --> 00:21:16,500
über Int vs. Double erhalten.

00:21:16,500 --> 00:21:22,549
Auch wenn Sie redundante fromIntegral-Aufrufe hinzufügen,
wird der Compiler / das Autotool Sie eigentlich

00:21:22,549 --> 00:21:23,549
davor warnen.

00:21:23,549 --> 00:21:25,710
In diesem Sinne schadet es also nicht.

00:21:25,710 --> 00:21:27,010
Es ist ähnlich wie mit den Klammern.

00:21:27,010 --> 00:21:32,279
Am Anfang, wenn Sie Haskell-Programme schreiben, neigen Sie
dazu, zu viele Klammern hinzuzufügen. Und vielleicht ist es

00:21:32,279 --> 00:21:36,740
sogar eine gute Strategie, am Anfang ein paar mehr Klammern
hinzuzufügen, nur um auf der sicheren Seite zu sein, und

00:21:36,740 --> 00:21:42,230
dann den Compiler oder das Autotool oder welches Tool
auch immer Sie verwenden, sagen zu lassen, welche Klammern

00:21:42,230 --> 00:21:43,230
redundant sind.

00:21:43,230 --> 00:21:47,919
In ähnlicher Weise könnten Sie dieses fromIntegral verwenden,
es dort hinzufügen, wo Sie den Verdacht haben, dass Sie

00:21:47,919 --> 00:21:53,770
es brauchen könnten, und wenn sich in Ihrem endgültigen Programm
herausstellt, dass es nicht benötigt wird, dann können Sie

00:21:53,770 --> 00:21:58,580
sich vom Compiler oder Autotool sagen lassen, wo Sie einige
dieser "fromIntegral"-Aufrufe wieder entfernen können.

00:21:58,580 --> 00:22:01,650
Das ist dann eine sichere Strategie.

00:22:01,650 --> 00:22:04,110
Das war die eine Bemerkung.

00:22:04,110 --> 00:22:09,870
Eine andere Bemerkung gilt generell für alle Funktionen, aber
speziell (wegen dieser ganzen Konvertierungsprobleme) für Typen,

00:22:09,870 --> 00:22:13,090
die mit Zahlen zu tun haben.

00:22:13,090 --> 00:22:18,789
Es ist gute Praxis und wirklich hilfreich, die
Typsignatur zumindest für die Top-Level-Funktionen

00:22:18,789 --> 00:22:19,789
aufzuschreiben.

00:22:19,789 --> 00:22:24,530
Das hat Vorteile, wie z.B. dass der Compiler besser
in der Lage ist, Ihnen bei Typfehlern zu helfen.

00:22:24,530 --> 00:22:29,419
Aber unter anderem erspart es Ihnen auch den
Umgang mit bestimmten kompliziert aussehenden

00:22:29,419 --> 00:22:30,460
Typen wie dem hier.

00:22:30,460 --> 00:22:36,651
Wenn Sie also eine Funktion auf Zahlen schreiben, und Sie
nicht sagen "Ich möchte, dass dies eine Funktion von Float nach

00:22:36,651 --> 00:22:37,651
Float ist",

00:22:37,651 --> 00:22:40,140
dann wird der
Compiler irgendeinen Typ ableiten.

00:22:40,140 --> 00:22:46,360
Er könnte etwas ableiten, das abschreckend
aussieht wie dieses "Floating a" und "Ord a",

00:22:46,360 --> 00:22:51,880
und dann diesen seltsamen Pfeil, der kein
Funktionspfeil ist, und dann "a → a".

00:22:51,880 --> 00:22:56,230
Es wird im Moment nicht
erwartet, dass Sie das verstehen.

00:22:56,230 --> 00:23:01,000
Wenn Sie eine Ahnung davon haben wollen, was hier
passiert: Es ist etwas ähnlich wie bei Java-Interfaces,

00:23:01,000 --> 00:23:10,320
wo "Floating" und "Ord" im Grunde genommen komplett
abstrakte Klassen sind (in Java würde man sie mittels

00:23:10,320 --> 00:23:11,700
"interface" deklarieren).

00:23:11,700 --> 00:23:13,940
Aber das brauchen Sie
an dieser Stelle nicht.

00:23:13,940 --> 00:23:20,470
Und Sie können solche Konzepte in Haskell
vermeiden, indem Sie expliziter sind.

00:23:20,470 --> 00:23:25,409
Wenn Sie also aufschreiben, dass Ihr "fun" eine
Funktion von Int nach Int ist, dann wird Ihnen

00:23:25,409 --> 00:23:26,520
der Compiler glauben.

00:23:26,520 --> 00:23:31,030
Nun, er wird Ihnen nicht einfach
glauben, er wird es überprüfen.

00:23:31,030 --> 00:23:37,150
Und Sie müssen sich nicht auf die Inferenz verlassen,
die zu so kompliziert aussehenden Typen führen kann.

00:23:37,150 --> 00:23:40,030
Dies ist also ein Kommentar
speziell zu Zahlentypen.

00:23:40,030 --> 00:23:44,210
Aber auch ganz allgemein sollten zumindest
Top-Level-Funktionen in Ihren Übungsvorlagen mit

00:23:44,210 --> 00:23:45,230
Typsignaturen versehen werden.

00:23:45,230 --> 00:23:49,309
Sie müssen das nicht für alle lokalen Definitionen
tun, wie ich es im Beispiel vorhin mit den

00:23:49,309 --> 00:23:52,770
lokalen Funktionen x und y getan habe.

00:23:52,770 --> 00:23:56,779
Sie müssen nicht alle Typsignaturen für solche Dinge
schreiben, aber für Funktionen der obersten Ebene

00:23:56,779 --> 00:24:02,160
sollten Sie es lieber tun.

54 # slide
00:24:03,160 --> 00:24:06,870
Natürlich gibt es nicht nur Zahlentypen.

00:24:06,870 --> 00:24:09,960
Es gibt alle Arten von Typen in Haskell.

00:24:09,960 --> 00:24:17,520
Und ich werde auf dieser Folie einige Grundtypen
durchsprechen und wahrscheinlich anschließend ein kleines

00:24:17,520 --> 00:24:24,429
Video mit dem Whiteboard machen, um einige
Beispielwerte, insbesondere für zusammengesetzte Typen,

00:24:24,429 --> 00:24:25,429
anzuschauen.

00:24:25,429 --> 00:24:29,440
Gehen wir also schnell die bereits
existierenden Typen durch, abgesehen von Zahlen.

00:24:29,440 --> 00:24:32,030
Es gibt also einen
Typ von Booleschen Werten.

00:24:32,030 --> 00:24:35,180
Und eigentlich sind die einzigen
Bewohner dieses Typs "True" und "False".

00:24:35,180 --> 00:24:40,500
Und auf diesen Werten haben Sie Operatoren
wie "&&" (und), "||" (oder), "not" (nicht).

00:24:40,500 --> 00:24:42,830
Also, die logischen Operatoren
auf dem Booleschen Typ.

00:24:42,830 --> 00:24:43,980
Es ist wirklich ein eigener Typ.

00:24:43,980 --> 00:24:49,830
Es ist nicht wie in C, wo irgendwie 0 und 1 eines
Integer-Typs auch als Boolesche Werte fungieren.

00:24:49,830 --> 00:24:54,690
Das ist wirklich ein eigener Typ:
True und False, und Operatoren darauf.

00:24:54,690 --> 00:25:00,370
Und natürlich ist dieser Typ eigentlich auch der Typ
von Bedingungen, die Sie in "if-then-else" verwenden.

00:25:00,370 --> 00:25:03,770
Die Bedingung muss etwas sein, das
zu einem "Bool" ausgewertet wird.

00:25:03,770 --> 00:25:08,000
Und natürlich können Sie diese Booleschen
Operatoren auch an diesen Stellen verwenden.

00:25:08,000 --> 00:25:11,480
Das ist also die eine Sache.

00:25:11,480 --> 00:25:14,290
Und dann gibt es noch einen
Typ von Zeichenwerten.

00:25:14,290 --> 00:25:16,570
Er wird "Char" genannt.

00:25:16,570 --> 00:25:25,919
Er hat die erwarteten Werte, wie alle Buchstaben,
die Sie haben können, auch Sonderzeichen

00:25:25,919 --> 00:25:27,870
wie "eine neue Zeile" ('\n'), usw.

00:25:27,870 --> 00:25:37,270
Es gibt Operationen wie das Vorwärts- oder
Rückwärtsbewegen in der ASCII-Tabelle, in gewisser Weise.

00:25:37,270 --> 00:25:42,120
Der Nachfolger von 'a' ist 'b', und der
Vorgänger von 'b' als Zeichen ist 'a'.

00:25:42,120 --> 00:25:47,340
Sie können Zeichen auch mit den üblichen
Vergleichsoperationen vergleichen, die Sie auch auf

00:25:47,340 --> 00:25:48,340
Zahlen anwenden würden.

00:25:48,340 --> 00:25:49,340
Diese sind also ebenfalls überladen.

00:25:49,340 --> 00:25:53,669
Noch interessanter ist die
Konstruktion von Listentypen.

00:25:53,669 --> 00:25:58,020
Wir haben schon einige Listen gesehen, nämlich
bei den List Comprehensions: Listen von Bildern.

00:25:58,020 --> 00:26:01,809
Aber diese Konstruktion kann
beliebig verwendet werden.

00:26:01,809 --> 00:26:03,010
Sie können also eine
Liste von irgendetwas haben.

00:26:03,010 --> 00:26:04,070
Sie können eine
Liste von Integern haben.

00:26:04,070 --> 00:26:05,200
Sie können eine Liste von Bools haben.

00:26:05,200 --> 00:26:07,890
Sie können eine Liste von
Listen mit ganzen Zahlen haben.

00:26:07,890 --> 00:26:10,110
Und es gibt
viele vordefinierte Funktionen.

00:26:10,110 --> 00:26:14,990
Sie werden einige davon später
sehen, oder vielleicht nächste Woche.

00:26:14,990 --> 00:26:23,230
Aber wie auch immer, es gibt eine Menge verfügbarer Maschinerie,
um mit Listen zu arbeiten, wie etwa die List Comprehensions, aber

00:26:23,230 --> 00:26:26,010
auch die Definition von
Funktionen und Operatoren.

00:26:26,010 --> 00:26:30,470
So haben Sie zum Beispiel die Funktion "reverse",
die eine Liste nimmt und die Reihenfolge umkehrt.

00:26:30,470 --> 00:26:36,380
Oder Funktionen, um bestimmte Teile einer Liste
auszuwählen, einen Präfix oder Suffix, oder was auch immer.

00:26:36,380 --> 00:26:38,560
Und: Listen sind homogen.

00:26:38,560 --> 00:26:43,170
Wenn Sie also eine Liste von Ints (ganzen Zahlen) haben,
dann können Sie in dieser Liste nur Int (ganze Zahlen)

00:26:43,170 --> 00:26:44,170
haben.

00:26:44,170 --> 00:26:47,610
Man kann keine Liste haben, in der einige der
Werte Integer sind und einige davon Boolesche Werte

00:26:47,610 --> 00:26:48,610
sind.

00:26:48,610 --> 00:26:49,640
Sie haben einen
Typ von Integer (Int)-Listen.

00:26:49,640 --> 00:26:51,429
Sie haben einen
Typ von Boolean (Bool)-Listen.

00:26:51,429 --> 00:26:55,520
Aber Sie haben keinen Typ von "einige dieser Werte
sind Ganzzahlen und einige sind Boolesche Werte".

00:26:55,520 --> 00:26:59,390
Dieser muss also homogen sein.

00:26:59,390 --> 00:27:05,370
Dann gibt es einen Typ von Zeichenfolgen, und
der heißt wie in anderen Sprachen 'String'.

00:27:05,370 --> 00:27:07,919
Aber es ist eine Liste von Zeichen.

00:27:07,919 --> 00:27:14,590
Ja, wir können eine spezielle Notation schreiben
("abc"), aber was es unter der Haube wirklich ist, ist

00:27:14,590 --> 00:27:19,539
eine normale Liste, bei der der
Elementtyp der Zeichentyp (Char) ist.

00:27:19,539 --> 00:27:23,260
Also ist "abc" eigentlich die Liste
dieser drei Zeichen 'a', 'b' und 'c'.

00:27:23,260 --> 00:27:27,890
So etwas wie die eben erwähnte reverse-Funktion
ist also auch auf Strings anwendbar,

00:27:27,890 --> 00:27:29,480
weil Strings auch nur Listen sind.

00:27:29,480 --> 00:27:34,220
Es ist nur zufällig der Fall, dass es
sich um eine Liste von Zeichen handelt.

00:27:34,220 --> 00:27:42,679
Wichtig in diesem Zusammenhang ist, dass in CodeWorld
dieser 'String'-Typ nicht direkt verwendet wird.

00:27:42,679 --> 00:27:44,730
Also verwendet CodeWorld
einen eigenen 'Text'-Typ.

00:27:44,730 --> 00:27:45,730
Er wird 'Text' genannt.

00:27:45,730 --> 00:27:47,170
Er ist sehr ähnlich zu String.

00:27:47,170 --> 00:27:53,360
Und Sie können auch diese Notation verwenden, aber
Sie müssen auch die Funktion "pack" verwenden.

00:27:53,360 --> 00:27:56,870
Und wenn Sie sich die Beispiele oder die Vorlagen für
die letzte Übung, die wir gegeben haben, angesehen

00:27:56,870 --> 00:27:58,070
haben, können Sie das in Aktion sehen.

00:27:58,070 --> 00:28:02,929
Wenn Sie also Zeichenketten oder Zeichenfolgen in
CodeWorld verwenden wollen, dann machen Sie es

00:28:02,929 --> 00:28:07,440
so, wie es in der letzten
Übungswoche gemacht wurde.

00:28:07,440 --> 00:28:12,980
Verwenden Sie von dort aus die
Beispiele, wie das gemacht wird.

00:28:12,980 --> 00:28:19,960
Und dann gibt es noch eine weitere Möglichkeit, Werte in
einer komplexeren Struktur zu kombinieren oder anzuordnen.

00:28:19,960 --> 00:28:22,049
Neben Listen gibt es auch Tupel-Typen.

00:28:22,049 --> 00:28:26,630
Der Unterschied bei ihnen ist, dass sie
zum einen nicht homogen sein müssen.

00:28:26,630 --> 00:28:31,040
Sie können also ein Paar von Integern oder ein
Tripel von Integern, Strings und Booleans haben.

00:28:31,040 --> 00:28:34,800
Es muss also nicht homogen sein,
aber mit einer festen Länge.

00:28:34,800 --> 00:28:39,080
Wenn Sie einen Tripel-Typ haben, dann
müssen alle Werte des Typs Tripel sein.

00:28:39,080 --> 00:28:44,100
Sie können nicht, wie z.B. bei einem Listentyp,
mehrere Listen mit unterschiedlicher Länge haben.

00:28:44,100 --> 00:28:49,260
Listentypen sind also homogen und ein
Listenwert kann beliebig lang sein.

00:28:49,260 --> 00:28:57,350
Tupel-Typen sind nicht homogen: Sie können Tripel
verschiedener Typen als Bestandteile haben,

00:28:57,350 --> 00:29:00,429
aber jedes Element dieses
Typs muss ein Tripel sein.

00:29:00,429 --> 00:29:05,450
Sie können keinen Typ haben, der z.B.
einige Paare und einige Tripel enthält.

00:29:05,450 --> 00:29:07,970
Und alle diese Konstrukte
können kombiniert werden.

00:29:07,970 --> 00:29:13,700
Sie können also Listen von Paaren, Paare von Listen,
Listen von Paaren von Listen und Paaren haben.

00:29:13,700 --> 00:29:17,419
Sie können Basistypen an
allen Stellen verschachteln.

00:29:17,419 --> 00:29:22,540
Und natürlich können sie später, wenn wir eigene
Datentypen definieren, auch in Listen und Tupeln

00:29:22,540 --> 00:29:23,950
usw. verwendet werden.

00:29:23,950 --> 00:29:34,179
Es gibt also einen kombinatorischen Bereich von
Typkonstruktoren und man kann sie auf viele verschiedene

00:29:34,179 --> 00:29:35,179
Arten kombinieren.

00:29:35,179 --> 00:29:40,299
Und schon mit den grundlegenden Dingen, die Sie auf
dieser Folie sehen, haben Sie eine ganze Reihe von

00:29:40,299 --> 00:29:42,539
Möglichkeiten, Ihre Daten anzuordnen.

00:29:42,539 --> 00:29:49,940
Und um das zu veranschaulichen, werde ich einige Werte
einiger dieser Typen in einem separaten Whiteboard-Video

00:29:49,940 --> 00:29:50,440
zeigen.
