49 # slide
00:00:01,370 --> 00:00:06,620
First of all, I have to slightly correct myself:

00:00:06,620 --> 00:00:15,370
I said in the previous video that I finished
last lecture week with the slide on moving

00:00:15,370 --> 00:00:22,420
if-then-else expressions in and out of function
argument positions.

00:00:22,420 --> 00:00:23,610
That wasn't actually true.

00:00:23,610 --> 00:00:27,420
That was slide 43, whereas last week's lectures
ended with slide 48.

00:00:27,420 --> 00:00:33,340
So, there was some other material afterward,
namely, talking about syntax.

00:00:33,340 --> 00:00:42,210
I want to call out another observation
from the exercises here.

00:00:42,210 --> 00:00:49,039
Actually, this is not exactly from this year's
exercise tasks, but from a task similar to

00:00:49,039 --> 00:00:52,170
the "moving sun" example, from last year.

00:00:52,170 --> 00:00:55,699
There was some observation that I want to
make here again, even though it's not exactly

00:00:55,699 --> 00:01:01,660
the example that was used in this year's exercises.

00:01:01,660 --> 00:01:04,680
It's about common subexpressions.

00:01:04,680 --> 00:01:08,571
So, it appears here in the case of an if-then-else,
but that's not the main point.

00:01:08,571 --> 00:01:11,550
The point is about common subexpressions.

00:01:11,550 --> 00:01:19,870
Also, Marcellus and Oliver talked about this
in their videos, about moving expressions

00:01:19,870 --> 00:01:25,390
that appear repeatedly, to somehow named entities.

00:01:25,390 --> 00:01:29,530
And that was used there for the grass, for
the sun, for branches, etc.

00:01:29,530 --> 00:01:32,130
So, basically for constant expressions.

00:01:32,130 --> 00:01:37,630
But the concept of common subexpression elimination
applies also to expressions that contain variables.

00:01:37,630 --> 00:01:39,570
And this is nicely illustrated here.

00:01:39,570 --> 00:01:41,240
Let's consider this example.

00:01:41,240 --> 00:01:45,910
There was some "scene" computation and somehow
it had something to do with rotation or moving

00:01:45,910 --> 00:01:46,910
stuff around.

00:01:46,910 --> 00:01:58,210
So, there was some condition: if 8 * sin t
> 0 then do something (where sin and cos are

00:01:58,210 --> 00:02:00,010
used), and else do something else.

00:02:00,010 --> 00:02:01,810
This doesn't really matter.

00:02:01,810 --> 00:02:03,220
Maybe this was blank here.

00:02:03,220 --> 00:02:04,400
Maybe something else.

00:02:04,400 --> 00:02:07,930
The important thing here is that there was
a recomputation.

00:02:07,930 --> 00:02:13,489
So, this value is computed here, and then at
least if it is positive, the "then" branch

00:02:13,489 --> 00:02:16,150
is taken, and it is computed again.

00:02:16,150 --> 00:02:19,430
It's not a very expensive computation.

00:02:19,430 --> 00:02:24,780
Yes, just computing the sine may not be the
most problematic case, but it would be both

00:02:24,780 --> 00:02:29,769
more efficient and also clearer to say: Let's
give names to these things.

00:02:29,769 --> 00:02:35,849
We can simply name things that contain no
other variables, but of course, we can also

00:02:35,849 --> 00:02:40,420
name the subexpressions "8 * cos t" and "8
* sin t".

00:02:40,420 --> 00:02:44,959
And then it becomes clearer because then
we can see that we actually check if the y-coordinate

00:02:44,959 --> 00:02:52,249
is greater than zero, then we move whatever
we had here to the x and y position, otherwise

00:02:52,249 --> 00:02:53,349
we do something else.

00:02:53,349 --> 00:02:58,060
So, this is both clearer (the second version),
and also slightly more efficient.

00:02:58,060 --> 00:03:06,390
Because we don't compute this very same mathematical
expression twice.

00:03:06,390 --> 00:03:10,920
There is a concern that sometimes comes up
at this point, maybe also the reason why the

00:03:10,920 --> 00:03:17,569
student originally writing this code didn't
do this renaming, that well, maybe in the

00:03:17,569 --> 00:03:23,219
"else" branch we don't need the cosine (the
x value).

00:03:23,219 --> 00:03:27,180
So, here we say: If this condition is true,
then we compute this, and then we have to

00:03:27,180 --> 00:03:28,920
compute this a second time.

00:03:28,920 --> 00:03:31,840
But if this condition is false, we go to the
"else" branch.

00:03:31,840 --> 00:03:34,900
And maybe in the "else" branch we don't have
the cosine or the sine.

00:03:34,900 --> 00:03:36,569
Maybe the "else" branch is really "blank".

00:03:36,569 --> 00:03:41,529
Then one could argue that while here we compute
the x and the y, and then we check whether

00:03:41,529 --> 00:03:46,139
the y is positive (if so, then of course we
use the x and y), and otherwise we do nothing

00:03:46,139 --> 00:03:50,540
(we have the "blank"); then why do we have
the computation of x?

00:03:50,540 --> 00:03:54,939
That is a concern that students might have
or have had at this point.

00:03:54,939 --> 00:03:57,669
And well, this concern is unfounded.

00:03:57,669 --> 00:03:58,669
Why?

00:03:58,669 --> 00:03:59,709
Because we are not in an imperative language.

00:03:59,709 --> 00:04:03,349
So, it's not even true that at this point we
compute x and y.

00:04:03,349 --> 00:04:04,530
It's not a variable assignment.

00:04:04,530 --> 00:04:09,590
It is not like you go through this piece of
code, and you compute this value, assign it

00:04:09,590 --> 00:04:15,620
to x, compute this value, assign it to y,
do the check, and if we end up in the "else"

00:04:15,620 --> 00:04:21,430
branch, and have a "blank", then we have computed
the x for nothing.

00:04:21,430 --> 00:04:25,949
That's not what's happening here because
this is not sequential code by which we compute

00:04:25,949 --> 00:04:27,949
this, and this, and this.

00:04:27,949 --> 00:04:29,520
These are just mathematical definitions.

00:04:29,520 --> 00:04:37,919
So, what this is saying is that x, if you
happen to need it later on, will be evaluated

00:04:37,919 --> 00:04:39,840
using this expression.

00:04:39,840 --> 00:04:46,199
So, it is not computing the x at all yet, just
declaring: If x is relevant at some point,

00:04:46,199 --> 00:04:48,850
then that's what the value would be.

00:04:48,850 --> 00:04:49,850
And the same goes for y.

00:04:49,850 --> 00:04:52,250
Then, we check the y, of course.

00:04:52,250 --> 00:04:56,340
The y will indeed be computed, but isn't computed
at this point when it is declared.

00:04:56,340 --> 00:04:57,930
It's computed when this check happens.

00:04:57,930 --> 00:05:01,590
And of course, we need the value of y in order
to do this comparison.

00:05:01,590 --> 00:05:05,280
So, the y will be computed when we do this
check.

00:05:05,280 --> 00:05:08,840
If this check is positive, then we will do
this, and then of course, we will need the

00:05:08,840 --> 00:05:09,840
x.

00:05:09,840 --> 00:05:10,919
And that's when the x would be computed.

00:05:10,919 --> 00:05:16,470
So then that's when the cos t will be computed
here.

00:05:16,470 --> 00:05:21,110
If, however, the y turns out to not be positive,
we end up in the "else" branch.

00:05:21,110 --> 00:05:23,030
The "else" branch is "blank", for example.

00:05:23,030 --> 00:05:25,240
So, it doesn't even mention x.

00:05:25,240 --> 00:05:27,990
Then x will never be computed.

00:05:27,990 --> 00:05:33,070
So, you have to free yourself from sequential
thinking, where seeing this, you think: Now

00:05:33,070 --> 00:05:38,180
I compute the expensive x, and now I compute
the expensive y, and then I do something with

00:05:38,180 --> 00:05:39,180
those values.

00:05:39,180 --> 00:05:42,440
That's not what's happening, because this
is not sequential code.

00:05:42,440 --> 00:05:45,930
It's mathematical declarations.

00:05:45,930 --> 00:05:51,639
And if the x is not needed because in the
"else" branch we have "blank", then the x

00:05:51,639 --> 00:05:55,650
will never be computed.

50 # slide
00:05:56,650 --> 00:06:00,310
Let's talk a bit about types.

00:06:00,310 --> 00:06:03,110
And first of all, about number types.

00:06:03,110 --> 00:06:07,940
That is also something that is now increasingly
coming up in the exercises.

00:06:07,940 --> 00:06:11,889
The first examples in CodeWorld, of course,
were all about Doubles, because that's the

00:06:11,889 --> 00:06:15,520
unit in which things are measured in CodeWorld.

00:06:15,520 --> 00:06:22,099
Then, in the last exercise task, about the
list of natural numbers, there was already

00:06:22,099 --> 00:06:25,930
this integer type for non-fractional values (whole numbers).

00:06:25,930 --> 00:06:32,389
And actually, some students already mixed
floating-point and integer types in that exercise.

00:06:32,389 --> 00:06:33,389
It was not needed.

00:06:33,389 --> 00:06:36,050
There was a way to compute this just on integers.

00:06:36,050 --> 00:06:41,130
But some students tried to use conversion
for detecting the number of digits of a number.

00:06:41,130 --> 00:06:43,970
Instead of working with division and rounding
of values, etc.

00:06:43,970 --> 00:06:51,490
So, they already worked with functions that
move between floating-point and integer values.

00:06:51,490 --> 00:06:56,320
You will, at some places, need both and also
their interplay.

00:06:56,320 --> 00:06:58,020
So, we have to talk about this.

00:06:58,020 --> 00:07:02,909
And it also serves as the first view into
some aspects of the types in Haskell, other

00:07:02,909 --> 00:07:06,070
than what you have seen so far in function
types.

00:07:06,070 --> 00:07:09,990
First of all, from the outside, Haskell does
have various number types.

00:07:09,990 --> 00:07:14,569
Like in most programming languages, there
are integer types of different sizes and there

00:07:14,569 --> 00:07:17,150
are floating-point types of different sizes.

00:07:17,150 --> 00:07:18,949
So, you see here Float and Double.

00:07:18,949 --> 00:07:26,270
They correspond roughly to what you find in
other languages with those type names.

00:07:26,270 --> 00:07:29,300
The Rational type is maybe not so common in
other languages.

00:07:29,300 --> 00:07:33,319
It's really a type of the rational numbers
with arbitrary precision.

00:07:33,319 --> 00:07:35,169
These are not floating-point numbers.

00:07:35,169 --> 00:07:39,009
Actually, every rational number is exactly
representable in this type.

00:07:39,009 --> 00:07:43,930
So, there is no loss of precision when, for
example, adding rational numbers.

00:07:43,930 --> 00:07:47,759
And also, for integers there is this interesting
distinction between Int and Integer.

00:07:47,759 --> 00:07:52,729
And the way to think about this is that Int
is basically the machine integer, so something

00:07:52,729 --> 00:07:56,190
which has a fixed bit length like 32 or 64
bits.

00:07:56,190 --> 00:08:04,270
So, there is a finite range of integer numbers
that can be represented in Int.

00:08:04,270 --> 00:08:06,650
Whereas Integer is the mathematical integer
type.

00:08:06,650 --> 00:08:12,360
So, these are really arbitrarily large integer
numbers, with an arbitrary number of positions

00:08:12,360 --> 00:08:15,939
and no loss of precision.

00:08:15,939 --> 00:08:18,889
So, we have these different types.

00:08:18,889 --> 00:08:24,759
And of course, we can use our number literals
with different types, just as in other languages.

00:08:24,759 --> 00:08:31,760
So, the number three, just a constant written
3, can be an Int, can be a Float, can be an

00:08:31,760 --> 00:08:34,580
Integer, or can be a Rational, or many other
types.

00:08:34,580 --> 00:08:39,070
So for a number you don't see, as given, which
type it is.

00:08:39,070 --> 00:08:41,310
That is basically polymorphic or overloaded.

00:08:41,310 --> 00:08:45,880
There are also constants that don't have all
the number types.

00:08:45,880 --> 00:08:51,050
So if you write 3.5, then the compiler knows
(and also we do) that it's not an Int, nor

00:08:51,050 --> 00:08:52,050
an Integer.

00:08:52,050 --> 00:08:55,889
So, 3.5 could be a Float or a Double, but it
couldn't be an Integer, for example.

00:08:55,889 --> 00:08:58,630
Whereas 3 can be both an Integer and a Float.

00:08:58,630 --> 00:09:03,570
That's a common practice in other languages
as well.

00:09:03,570 --> 00:09:07,510
Also, as expected in some sense, there are
conversion functions.

00:09:07,510 --> 00:09:13,500
But we will see that they play a slightly
different role in some situations on the next

00:09:13,500 --> 00:09:14,500
slide.

00:09:14,500 --> 00:09:19,730
But if we need to convert between some of
these number types, then we can do so.

00:09:19,730 --> 00:09:23,740
So, there are conversion functions that don't
lose precision.

00:09:23,740 --> 00:09:30,839
These are functions that go from Int to Integer,
or other non-floating-point types to any number

00:09:30,839 --> 00:09:31,839
type.

00:09:31,839 --> 00:09:35,350
For example, if you want to go from machine
integers to this arbitrary precision integer

00:09:35,350 --> 00:09:37,230
type, then you can use the function "fromIntegral".

00:09:37,230 --> 00:09:39,851
It is not "fromInteger" or something like
that.

00:09:39,851 --> 00:09:40,993
That is something students sometimes mix up.

00:09:40,993 --> 00:09:47,370
Because there are also older versions of Haskell
where it is still existing, but not really

00:09:47,370 --> 00:09:49,110
used, or mainly deprecated.

00:09:49,110 --> 00:09:52,840
There is a "fromInteger" function as well.

00:09:52,840 --> 00:09:53,930
It's not something that you should use.

00:09:53,930 --> 00:09:57,370
You should use the "fromIntegral" function.

00:09:57,370 --> 00:09:58,380
It has many different types.

00:09:58,380 --> 00:09:59,700
It is also overloaded.

00:09:59,700 --> 00:10:05,790
So, it can convert an Int to an Integer, an
Integer to an Int, an Int to a Rational, and

00:10:05,790 --> 00:10:09,029
an Int to a Float/Rational/Double, as I mentioned
already.

00:10:09,029 --> 00:10:15,670
So, these are basically from one integer type
into a number type, whether that number type

00:10:15,670 --> 00:10:17,320
is an integer type or not.

00:10:17,320 --> 00:10:18,820
And there is no loss of precision here.

00:10:18,820 --> 00:10:21,570
Well, in the case of "from Integer to Int",
there is some loss of precision, of course.

00:10:21,570 --> 00:10:26,850
There must be, because of the limited expressiveness.

00:10:26,850 --> 00:10:31,260
But there's no loss of precision in terms
of rounding errors because of digits after

00:10:31,260 --> 00:10:35,560
the comma sign or something like that.

00:10:35,560 --> 00:10:38,970
Because this just goes from Integer and similar
types.

00:10:38,970 --> 00:10:43,760
In the opposite direction, in some sense,
there are functions that really have a rounding

00:10:43,760 --> 00:10:46,840
error/discrepancy.

00:10:46,840 --> 00:10:52,410
Because if you have 3.5 and you want an integer,
then you have to go to 3 or 4, so you must

00:10:52,410 --> 00:10:53,560
make a change.

00:10:53,560 --> 00:10:56,670
You can round up, you can round down, you
can truncate.

00:10:56,670 --> 00:11:00,800
And basically, for all these different modes,
there are functions in Haskell.

00:11:00,800 --> 00:11:07,730
So "truncate" would go from 3.5 to 3, whereas
"round" would move from 3.5 to 4, because

00:11:07,730 --> 00:11:08,730
of the rounding up.

00:11:08,730 --> 00:11:13,560
And "ceiling" and "floor" are similar to "truncate",
but behave differently depending on whether

00:11:13,560 --> 00:11:18,029
they get negative or positive numbers.

00:11:18,029 --> 00:11:23,210
Which types do these precision losing conversion
functions have?

00:11:23,210 --> 00:11:26,529
They can move from a Float to an Int, for
example.

00:11:26,529 --> 00:11:30,860
Because the input would be a floating-point
number, because we have something like 3.5.

00:11:30,860 --> 00:11:35,420
The outcome will be, again, an integral type
like Int or Integer.

00:11:35,420 --> 00:11:38,550
That's because after you have "truncated",
you have a 3 or a 4.

00:11:38,550 --> 00:11:41,459
So, you don't need a floating-point number
anymore.

00:11:41,459 --> 00:11:53,010
You can move, with these functions, from this
to an Integer or Int type.

51 # slide
00:11:53,010 --> 00:11:59,890
In addition to the constants that are overloaded,
also most of the mathematical operators are

00:11:59,890 --> 00:12:00,890
overloaded.

00:12:00,890 --> 00:12:07,070
Because it would be very cumbersome and inconvenient
(but actually, it is the case in some languages)

00:12:07,070 --> 00:12:12,399
that you need different mathematical operators
depending on whether you work on floating-point

00:12:12,399 --> 00:12:14,540
numbers or integer numbers, for example.

00:12:14,540 --> 00:12:18,730
There are certain versions like a specific
function for integer division in Haskell,

00:12:18,730 --> 00:12:21,060
but most of the operators are overloaded.

00:12:21,060 --> 00:12:30,360
So if you have something like f x = 2 * x
+ 3.5, then you don't have to somehow make

00:12:30,360 --> 00:12:37,040
your own distinction about 3.5 being a floating-point
number, and about this being an integer number.

00:12:37,040 --> 00:12:41,800
In the sense that this may be an integer multiplication,
but then, floating-point additions, so maybe

00:12:41,800 --> 00:12:43,709
some conversion would be needed.

00:12:43,709 --> 00:12:46,910
No, because these operators are overloaded.

00:12:46,910 --> 00:12:49,529
They work at the correct types.

00:12:49,529 --> 00:12:54,490
So, in 3 + 4.5 the "+" knows that it must be
a floating-point addition, because we have

00:12:54,490 --> 00:12:55,490
a floating-point number here.

00:12:55,490 --> 00:12:59,510
It also knows that this 3, even though it
could also be an integer, will actually be

00:12:59,510 --> 00:13:02,139
taken as a floating-point 3.

00:13:02,139 --> 00:13:03,990
And that's also why this works.

00:13:03,990 --> 00:13:08,360
And an appropriate type for f will be chosen
by the compiler if you do something like this.

00:13:08,360 --> 00:13:11,370
It will work out that the x must also be a
floating-point value, because otherwise you

00:13:11,370 --> 00:13:16,399
couldn't double it and then add it with a
floating-point addition.

00:13:16,399 --> 00:13:22,361
Similarly, if you have some other function
which uses f, then again, we know from what

00:13:22,361 --> 00:13:28,399
I just said that x (the argument of f) must
be a floating-point thing, because of this

00:13:28,399 --> 00:13:29,399
expression.

00:13:29,399 --> 00:13:33,600
And that works out nicely because the 4 can
also be seen as a floating-point value.

00:13:33,600 --> 00:13:36,839
Then the outcome of the f will also be floating-point
values.

00:13:36,839 --> 00:13:41,699
So, the g will actually know that this division
must be a floating-point division, so y must

00:13:41,699 --> 00:13:42,699
also be a floating-point number.

00:13:42,699 --> 00:13:48,319
So if you write something like this, then
we don't have to convert, because the language

00:13:48,319 --> 00:13:52,230
overloads both the constants and the mathematical
operations.

00:13:52,230 --> 00:13:57,470
That's the case here, because we leave the
compiler the choice of what types to assign

00:13:57,470 --> 00:13:58,470
to x and y.

00:13:58,470 --> 00:14:03,769
We haven't written down types for f and g,
and made no constraints on x and y, nor on

00:14:03,769 --> 00:14:04,880
the outcome of these functions.

00:14:04,880 --> 00:14:10,000
So, the compiler can, via overloading, choose
appropriate number types for x and y.

00:14:10,000 --> 00:14:14,220
In this case, it will choose floating-point
types because of what I just explained.

00:14:14,220 --> 00:14:21,079
If, on the other hand, we do write down explicit
function types, and those also constrain the

00:14:21,079 --> 00:14:27,380
input and output types, for example to integers,
then we need to convert.

00:14:27,380 --> 00:14:32,570
To illustrate this, let's look at a similar
example.

00:14:32,570 --> 00:14:36,800
First, let's look at this here.

00:14:36,800 --> 00:14:40,339
Let's say I want f to be a function from integers
to floats.

00:14:40,339 --> 00:14:48,970
Then if I want to use the same expression
as here, I actually have to make sure that

00:14:48,970 --> 00:14:51,589
this value in this position is a floating-point
value.

00:14:51,589 --> 00:14:54,130
And it isn't.

00:14:54,130 --> 00:14:58,250
If I say, f goes from integer to float, then
x would be an integer.

00:14:58,250 --> 00:15:01,860
Then in order to use it for floating-point
multiplication, which I have to do because

00:15:01,860 --> 00:15:06,410
afterwards I want to do a floating-point addition,
then I have to convert this x from Int to

00:15:06,410 --> 00:15:07,889
a floating-point number.

00:15:07,889 --> 00:15:12,029
And that's what "fromIntegral" can do, because
as I said on the previous slide, this "fromIntegral"

00:15:12,029 --> 00:15:15,110
can go from types like Int or Integer to any
suitable other type.

00:15:15,110 --> 00:15:16,870
So, it could go to Float.

00:15:16,870 --> 00:15:19,019
So, this will work.

00:15:19,019 --> 00:15:21,550
And this is then a kind of conversion.

00:15:21,550 --> 00:15:25,279
Yes, it is not a syntactic conversion as happens
in C.

00:15:25,279 --> 00:15:27,600
It's a function which does this conversion.

00:15:27,600 --> 00:15:33,149
So, it is not somehow a built-in extra syntactic
construct.

00:15:33,149 --> 00:15:35,839
And similarly, if for example I do an example
as above:

00:15:35,839 --> 00:15:43,000
So, the f x is again free to choose its type,
but somehow in the second function, instead

00:15:43,000 --> 00:15:50,040
of putting the value 4 here, I want to have
the length of the string "abcd".

00:15:50,040 --> 00:15:54,850
Now I would have to know that the 'length' function
in Haskell is a function which takes, in this

00:15:54,850 --> 00:15:56,970
case, a String, and gives a natural number.

00:15:56,970 --> 00:16:00,680
It doesn't give a floating-point number, because
"length" makes more sense with an integer

00:16:00,680 --> 00:16:01,680
result.

00:16:01,680 --> 00:16:06,690
So if I write something like this (so I replace
the 4 by the length of "abcd"), then again

00:16:06,690 --> 00:16:07,690
I need to convert.

00:16:07,690 --> 00:16:08,690
Why?

00:16:08,690 --> 00:16:12,050
Because here, the 4 didn't have a type, so
the compiler decided, via overloading: "Well,

00:16:12,050 --> 00:16:14,399
I consider this 4 to be a floating-point number".

00:16:14,399 --> 00:16:17,070
This can't be done here if I say it is the
result of the 'length' function.

00:16:17,070 --> 00:16:20,279
The 'length' function always returns an integer.

00:16:20,279 --> 00:16:25,220
If I then want to use it as an argument to
f, and for f the compiler has deduced that

00:16:25,220 --> 00:16:30,810
the argument must be a floating-point value
because of this addition here, then I need

00:16:30,810 --> 00:16:35,029
to make sure that I embed my integer (which
comes out of the 'length' function) into this

00:16:35,029 --> 00:16:36,029
floating-point type.

00:16:36,029 --> 00:16:37,889
And again, I can do this with "fromIntegral".

00:16:37,889 --> 00:16:42,449
So, I would again need a conversion here.

00:16:42,449 --> 00:16:44,279
Now, at this point, students sometimes ask:

00:16:44,279 --> 00:16:48,759
"Why is it that here I have to make these
explicit conversions, whereas here they are

00:16:48,759 --> 00:16:52,600
somehow hidden? Maybe the compiler is introducing
silent conversions here."

00:16:52,600 --> 00:16:54,380
But that's not how to view this.

00:16:54,380 --> 00:16:59,220
It is not the case that here we have explicit
conversions, and here we have somehow hidden.

00:16:59,220 --> 00:17:00,220
conversions.

00:17:00,220 --> 00:17:01,220
No.

00:17:01,220 --> 00:17:02,220
What's actually happening is:

00:17:02,220 --> 00:17:06,130
Here we need conversions, here we don't need
conversions.

00:17:06,130 --> 00:17:07,900
So, there are no hidden conversions.

00:17:07,900 --> 00:17:11,740
Just by not giving types for f and g, we let
the compiler choose what the types are.

00:17:11,740 --> 00:17:15,959
And the compiler can, in this case, choose
the types in such a way that no conversions

00:17:15,959 --> 00:17:16,959
are necessary.

00:17:16,959 --> 00:17:19,319
Because the compiler simply decides that x
is a Float.

00:17:19,319 --> 00:17:21,970
Then there is no need for conversion.

00:17:21,970 --> 00:17:25,559
If we say "No, the x is an integer", then
conversion is necessary.

00:17:25,559 --> 00:17:28,100
And the compiler won't introduce conversion
on its own.

00:17:28,100 --> 00:17:29,340
We have to write it.

00:17:29,340 --> 00:17:42,850
Otherwise, it would defeat the discipline
of types in Haskell (also for number types).

52 # slide
00:17:42,850 --> 00:17:47,669
For the sake of completeness: There actually
are some operators that are not completely

00:17:47,669 --> 00:17:48,669
overloaded.

00:17:48,669 --> 00:17:50,920
So, they are not available at all types.

00:17:50,920 --> 00:17:52,299
And division is one of these examples.

00:17:52,299 --> 00:18:01,190
The division symbol, as you are probably used
to seeing it in many languages, like this, is

00:18:01,190 --> 00:18:03,160
not available on integer types.

00:18:03,160 --> 00:18:05,450
It is a floating-point style operation.

00:18:05,450 --> 00:18:10,770
It does work on the rationals, but not on
integer types.

00:18:10,770 --> 00:18:12,170
What do we have instead?

00:18:12,170 --> 00:18:15,000
We have a dedicated division function.

00:18:15,000 --> 00:18:17,960
This operator "div" is also known from other
languages.

00:18:17,960 --> 00:18:23,210
It operates on Int or Integer, but not on
floating-point numbers, for example.

00:18:23,210 --> 00:18:27,650
So, it is really a different operation, a
different symbol than the slash symbol for

00:18:27,650 --> 00:18:30,340
division on floating-point numbers.

00:18:30,340 --> 00:18:40,429
A nice syntactical trick is that binary functions
like "div", but also all non-arithmetic functions,

00:18:40,429 --> 00:18:41,600
can be used like operators.

00:18:41,600 --> 00:18:46,250
So while there is no slash operator for division
in Haskell, this function can be used as an

00:18:46,250 --> 00:18:50,860
operator by simply writing it infix and with
these backticks.

00:18:50,860 --> 00:18:52,539
But that's just syntactic sugar.

00:18:52,539 --> 00:18:59,880
So for "17 `div` 3", written this way, the
compiler knows that it is the same as applying

00:18:59,880 --> 00:19:04,620
the binary function "div" to 17 and 3 as its
two arguments.

00:19:04,620 --> 00:19:08,980
It is just a different way of writing it.

00:19:08,980 --> 00:19:12,580
It is not a new operator or something like
that.

00:19:12,580 --> 00:19:15,490
And another useful thing, of course, is that
many further mathematical constants and functions

00:19:15,490 --> 00:19:16,490
exist.

00:19:16,490 --> 00:19:17,490
We have seen some of them already.

00:19:17,490 --> 00:19:18,490
I used the mathematical constant pi.

00:19:18,490 --> 00:19:19,490
I used this sine function.

00:19:19,490 --> 00:19:24,110
There also is this function for square root;
minimum and maximum functions on integers

00:19:24,110 --> 00:19:25,320
and other types.

00:19:25,320 --> 00:19:33,919
So, a lot of functions exist and have the expected
names, similar to mathematical libraries in

00:19:33,919 --> 00:19:35,090
other languages.

00:19:35,090 --> 00:19:38,010
I won't introduce all of them, they will simply
come up in examples.

00:19:38,010 --> 00:19:44,730
So if you find a need, then maybe look up
in some Haskell library or the standard library

00:19:44,730 --> 00:19:47,300
what the function is that you need for a certain
purpose.

00:19:47,300 --> 00:19:54,450
So, I will not give a complete list or something
like that.

00:19:54,450 --> 00:19:57,909
That shouldn't be needed.

53 # slide
00:19:57,909 --> 00:20:04,120
Still in the context of number types, let
me also make an observation based on past

00:20:04,120 --> 00:20:05,120
years' exercises.

00:20:05,120 --> 00:20:10,620
So, this is also something that probably will
come up again in exercise tasks now.

00:20:10,620 --> 00:20:14,140
I mentioned the need for conversion.

00:20:14,140 --> 00:20:19,260
And the general strategy to deal with that
in your next exercise tasks, where you might

00:20:19,260 --> 00:20:25,940
encounter both integer and floating-point
types, is that usually it doesn't hurt to

00:20:25,940 --> 00:20:27,790
add some "fromIntegral" calls.

00:20:27,790 --> 00:20:29,140
Why is that?

00:20:29,140 --> 00:20:31,510
They may have many different types.

00:20:31,510 --> 00:20:34,620
So, among others, they have types
like "Int → Int".

00:20:34,620 --> 00:20:40,250
So if you have something which maybe draws
from a generator list in a list comprehension,

00:20:40,250 --> 00:20:41,720
0 to 10 or something like that:

00:20:41,720 --> 00:20:45,020
It would be an Int, but maybe you need to
use it as a Double.

00:20:45,020 --> 00:20:49,590
Then it doesn't hurt to add a "fromIntegral"
on the variable that you draw from that "0

00:20:49,590 --> 00:20:50,789
to 10" list.

00:20:50,789 --> 00:20:53,830
Because either it will be used as an Int,
and that's fine, because "fromIntegral" will

00:20:53,830 --> 00:20:57,900
turn Int into Int (nothing has changed), or
it will be used as a Double, and then you

00:20:57,900 --> 00:21:01,290
are also fine, because you have added this
"fromIntegral" call, which will actually turn

00:21:01,290 --> 00:21:03,470
the integer into a Double, for example.

00:21:03,470 --> 00:21:07,910
In that sense, "fromIntegral" in the worst case
will be a no-op.

00:21:07,910 --> 00:21:12,460
So, it doesn't really hurt to add it at certain
places, in particular, if you get error messages

00:21:12,460 --> 00:21:16,500
about Int vs. Double, for example.

00:21:16,500 --> 00:21:22,549
Also, if you add redundant fromIntegral calls,
actually the compiler/Autotool will warn you

00:21:22,549 --> 00:21:23,549
about this.

00:21:23,549 --> 00:21:25,710
So, in that sense, it doesn't hurt.

00:21:25,710 --> 00:21:27,010
It is similar to the brackets.

00:21:27,010 --> 00:21:32,279
In the beginning, when you write Haskell programs
you tend to add too many brackets, and maybe

00:21:32,279 --> 00:21:36,740
it is even a good strategy at the beginning
to add a few more brackets just to be on the

00:21:36,740 --> 00:21:42,230
safe side, and then let the compiler or Autotool
or whatever tool you use tell you which brackets

00:21:42,230 --> 00:21:43,230
are redundant.

00:21:43,230 --> 00:21:47,919
In a similar way, you could use this fromIntegral,
add it where you are suspicious that you might

00:21:47,919 --> 00:21:53,770
need it, and if in your final program it turns
out it's not needed, then you can have the

00:21:53,770 --> 00:21:58,580
compiler or Autotool tell you where you can
remove some of these "fromIntegral" calls again.

00:21:58,580 --> 00:22:01,650
That's then a safe strategy.

00:22:01,650 --> 00:22:04,110
That was one remark.

00:22:04,110 --> 00:22:09,870
Another remark generally applies to all functions,
but specifically (because of all these conversion

00:22:09,870 --> 00:22:13,090
issues) to types involving numbers.

00:22:13,090 --> 00:22:18,789
It's good practice and really helpful to write
down type signatures, at least for the top-level

00:22:18,789 --> 00:22:19,789
functions.

00:22:19,789 --> 00:22:24,530
This has benefits like the compiler being
better able to help you with type errors.

00:22:24,530 --> 00:22:29,419
But among other things, it saves you from
dealing with certain complicated-looking types

00:22:29,419 --> 00:22:30,460
like the one here.

00:22:30,460 --> 00:22:36,651
So if you write some function on numbers, and
you don't say "I want this to be a function from Float

00:22:36,651 --> 00:22:37,651
to Float",

00:22:37,651 --> 00:22:40,140
then the compiler will infer some type.

00:22:40,140 --> 00:22:46,360
It might infer something which looks somewhat
daunting like this "Floating a" and "Ord a",

00:22:46,360 --> 00:22:51,880
and then this strange arrow which isn't a
function arrow, and then "a → a".

00:22:51,880 --> 00:22:56,230
At the moment, you are not expected to understand
this.

00:22:56,230 --> 00:23:01,000
If you want to have some inkling of what's
happening here: it's a bit similar to Java

00:23:01,000 --> 00:23:10,320
interfaces, where "Floating" and "Ord" are basically
completely abstract classes (in Java, they would be

00:23:10,320 --> 00:23:11,700
declared with "interface").

00:23:11,700 --> 00:23:13,940
But you don't need this at this point.

00:23:13,940 --> 00:23:20,470
And you can avoid such concepts in Haskell
by being more explicit.

00:23:20,470 --> 00:23:25,409
So, if you write down that your "fun" is a
function from Int to Int, then the compiler

00:23:25,409 --> 00:23:26,520
will believe you.

00:23:26,520 --> 00:23:31,030
Well, it will not simply believe you, it will
check it.

00:23:31,030 --> 00:23:37,150
And you don't have to rely on inference which
might lead to such complicated-looking types.

00:23:37,150 --> 00:23:40,030
So, this is a comment specifically about number
types.

00:23:40,030 --> 00:23:44,210
But also more generally, at least top-level
functions in your exercise submissions should

00:23:44,210 --> 00:23:45,230
be given type signatures.

00:23:45,230 --> 00:23:49,309
You don't have to do it for all the local
definitions, like I did in the example earlier

00:23:49,309 --> 00:23:52,770
today with the local functions x and y.

00:23:52,770 --> 00:23:56,779
You don't have to write all the type signatures
for things like this, but for top-level functions

00:23:56,779 --> 00:24:02,160
you should prefer to do it.

54 # slide
00:24:03,160 --> 00:24:06,870
Of course, there are not just number types.

00:24:06,870 --> 00:24:09,960
There are all kinds of types in Haskell.

00:24:09,960 --> 00:24:17,520
And I will talk through some basic types on
this slide and probably afterwards make a

00:24:17,520 --> 00:24:24,429
small video with the whiteboard to look at
some example values, in particular, for compound

00:24:24,429 --> 00:24:25,429
types.

00:24:25,429 --> 00:24:29,440
So, let's go through the preexisting types
quickly, besides numbers.

00:24:29,440 --> 00:24:32,030
So, there is a type of Boolean values.

00:24:32,030 --> 00:24:35,180
And actually the only inhabitants of that
type are "True" and "False".

00:24:35,180 --> 00:24:40,500
And on those values, you have operators like
"&&" (and), "||" (or), "not".

00:24:40,500 --> 00:24:42,830
So, the logical operators on the Boolean type.

00:24:42,830 --> 00:24:43,980
It is really a separate type.

00:24:43,980 --> 00:24:49,830
It is not like in C, where somehow 0 and 1
of an integer type also act as Boolean values.

00:24:49,830 --> 00:24:54,690
That is really a separate type: True and False,
and operators on them.

00:24:54,690 --> 00:25:00,370
And of course, this type is actually also
the type of conditions you use in "if-then-else".

00:25:00,370 --> 00:25:03,770
The condition must be something that evaluates
to a "Bool".

00:25:03,770 --> 00:25:08,000
And also, of course, you can use these Boolean
operators in these places.

00:25:08,000 --> 00:25:11,480
So, this is one thing.

00:25:11,480 --> 00:25:14,290
And then, there is a type of character values.

00:25:14,290 --> 00:25:16,570
It is called "Char".

00:25:16,570 --> 00:25:25,919
It has the expected values, like all the letters
that you can have, also special characters

00:25:25,919 --> 00:25:27,870
like "a new line" ('\n'), etc.

00:25:27,870 --> 00:25:37,270
There are operations like moving forwards
or backwards in the ASCII table, in a sense.

00:25:37,270 --> 00:25:42,120
The successor of 'a' is 'b', and the predecessor
of 'b' as a character is 'a'.

00:25:42,120 --> 00:25:47,340
You can also compare characters with the usual
comparison operations that you would also

00:25:47,340 --> 00:25:48,340
use on numbers.

00:25:48,340 --> 00:25:49,340
So, these are also overloaded.

00:25:49,340 --> 00:25:53,669
More interestingly, there is a construction
of list types.

00:25:53,669 --> 00:25:58,020
We have already seen some lists, namely when
we did list comprehensions: lists of pictures.

00:25:58,020 --> 00:26:01,809
But this construction can be used arbitrarily.

00:26:01,809 --> 00:26:03,010
So, you can have a list of anything.

00:26:03,010 --> 00:26:04,070
You can have a list of integers.

00:26:04,070 --> 00:26:05,200
You can have a list of Bools.

00:26:05,200 --> 00:26:07,890
You can have a list of lists of integers.

00:26:07,890 --> 00:26:10,110
And there are many predefined functions.

00:26:10,110 --> 00:26:14,990
You see some of them later on, or maybe next
week.

00:26:14,990 --> 00:26:23,230
But anyway, there is a lot of available machinery
to work on lists, such as the list comprehensions,

00:26:23,230 --> 00:26:26,010
but also defining functions and operators.

00:26:26,010 --> 00:26:30,470
So, you have, for example, the 'reverse' function
which takes a list, reverses the order.

00:26:30,470 --> 00:26:36,380
Or functions for selecting certain parts of
a list, the prefix or suffix, or whatever.

00:26:36,380 --> 00:26:38,560
And: lists are homogeneous.

00:26:38,560 --> 00:26:43,170
So, if you have a list of Ints (integers),
then in that list you can only have Int (integer)

00:26:43,170 --> 00:26:44,170
numbers.

00:26:44,170 --> 00:26:47,610
We can't have a list where some of the values
are integers and some of them are Boolean

00:26:47,610 --> 00:26:48,610
values.

00:26:48,610 --> 00:26:49,640
You have a type of integer (Int) lists.

00:26:49,640 --> 00:26:51,429
You have a type of Boolean (Bool) lists.

00:26:51,429 --> 00:26:55,520
But you don't have a type of "some of these
values are integers, and some are Booleans".

00:26:55,520 --> 00:26:59,390
So, this has to be homogeneous.

00:26:59,390 --> 00:27:05,370
Then there is a type of character sequences,
and it is called "String" as in other languages.

00:27:05,370 --> 00:27:07,919
But it is a list of characters.

00:27:07,919 --> 00:27:14,590
Yes, we can write a special notation ("abc"),
but what it really is under the hood, it is

00:27:14,590 --> 00:27:19,539
a normal list, where the element type is the
character type (Char).

00:27:19,539 --> 00:27:23,260
So "abc" is actually the list of these three
characters 'a', 'b' and 'c'.

00:27:23,260 --> 00:27:27,890
So, something like the 'reverse' function I
just mentioned is also applicable on strings,

00:27:27,890 --> 00:27:29,480
because strings are also just lists.

00:27:29,480 --> 00:27:34,220
It just happens to be the case that it's a
list of characters.

00:27:34,220 --> 00:27:42,679
Important in this connection is that in CodeWorld,
this String type is not directly used.

00:27:42,679 --> 00:27:44,730
So CodeWorld uses its own text type.

00:27:44,730 --> 00:27:45,730
It is called "Text".

00:27:45,730 --> 00:27:47,170
It's very similar to String.

00:27:47,170 --> 00:27:53,360
And you can also use notation like this, but
you also need to use the 'pack' function.

00:27:53,360 --> 00:27:56,870
And if you have looked at the examples or
the templates for the last exercise we gave,

00:27:56,870 --> 00:27:58,070
you can see this in action.

00:27:58,070 --> 00:28:02,929
So, if you want to use strings or character
sequences in CodeWorld, then do it in the

00:28:02,929 --> 00:28:07,440
same way it was done in the previous exercise
week.

00:28:07,440 --> 00:28:12,980
From there, use the examples for how this
is done.

00:28:12,980 --> 00:28:19,960
And then, there's another way to combine or
arrange values in a more complex structure.

00:28:19,960 --> 00:28:22,049
Besides lists, there are tuple types.

00:28:22,049 --> 00:28:26,630
But the difference with them is that, on the
one hand, they don't have to be homogeneous.

00:28:26,630 --> 00:28:31,040
So, you can have a pair of integers or a triple
of integers, strings, and Booleans.

00:28:31,040 --> 00:28:34,800
So, it doesn't have to be homogeneous, but
with a fixed length.

00:28:34,800 --> 00:28:39,080
If you have a triple type, then all values
of the type must be triples.

00:28:39,080 --> 00:28:44,100
You can't, like in a list type, have several
lists of different lengths, for example.

00:28:44,100 --> 00:28:49,260
So list types are homogeneous, and a list value
can be arbitrarily long.

00:28:49,260 --> 00:28:57,350
Tuple types are not homogeneous: You can have
triples of different types as ingredients,

00:28:57,350 --> 00:29:00,429
but every element of this type has to be a
triple.

00:29:00,429 --> 00:29:05,450
You can't have a type which contains some
pairs and some triples, for example.

00:29:05,450 --> 00:29:07,970
And all these constructs can be combined.

00:29:07,970 --> 00:29:13,700
So, you can have lists of pairs, pairs of lists,
lists of pairs of lists and pairs.

00:29:13,700 --> 00:29:17,419
You can nest basic types at all places.

00:29:17,419 --> 00:29:22,540
And of course, later on, when we define our
own datatypes, they can also be used in lists

00:29:22,540 --> 00:29:23,950
and tuples, etc.

00:29:23,950 --> 00:29:34,179
So, there is a combinatorial domain of type
constructors and you can combine them in many

00:29:34,179 --> 00:29:35,179
different ways.

00:29:35,179 --> 00:29:40,299
And already with the basic things that you
see on this slide, you have quite a few choices

00:29:40,299 --> 00:29:42,539
to arrange your data.

00:29:42,539 --> 00:29:49,940
And to illustrate this, I will show some values
of some of these types in a separate whiteboard

00:29:49,940 --> 00:29:50,440
video.
