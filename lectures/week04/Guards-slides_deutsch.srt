"55 # slide
00:00:01,430 --> 00:00:06,260
Lassen Sie uns heute auch ein
bisschen mehr über die Syntax sprechen.

00:00:06,260 --> 00:00:11,980
Und im Wesentlichen wird es hier
mehr um die Programmierung durch Fallunterscheidung gehen.

00:00:11,980 --> 00:00:16,170
Das ist natürlich ein wichtiger
Aspekt bei der Definition von Funktionen.

00:00:16,170 --> 00:00:19,550
Wir haben das schon einmal
gesehen und in Übungen verwendet.

00:00:19,550 --> 00:00:24,030
Und bisher geschah
dies durch "if-then-else"-Ausdrücke.

00:00:24,030 --> 00:00:30,140
Vielleicht haben Sie sogar in Ihren
Übungsaufgaben Gründe gehabt, if-then-else-Ausdrücke zu verschachteln.

00:00:30,140 --> 00:00:33,620
Und sobald Sie damit anfangen,
wird das etwas umständlich.

00:00:33,620 --> 00:00:40,700
Es gibt also andere Möglichkeiten, und einige
davon werden wir jetzt besprechen (weitere Möglichkeiten

00:00:40,700 --> 00:00:42,030
der Fallunterscheidung).

00:00:42,030 --> 00:00:44,730
Eigentlich wird das heute
noch nicht zu Ende sein.

00:00:44,730 --> 00:00:52,230
Insbesondere das Pattern-Matching (das auch eine
Möglichkeit ist, in Haskell mit Groß-/Kleinschreibung

00:00:52,230 --> 00:00:53,560
zu programmieren) wird in
einer anderen Woche behandelt.

00:00:53,560 --> 00:00:58,191
Aber schauen wir uns zunächst wieder die Situation mit
if-then-else an und was wir tun können, wenn die

00:00:58,191 --> 00:01:05,059
Verschachtelung zu weit geht.

56 # slide
00:01:05,059 --> 00:01:07,240
Erinnern Sie sich zunächst
daran, wie ein if-then-else aussieht.

00:01:07,240 --> 00:01:11,000
Das war also ein Beispiel,
das ich letzte Woche verwendet habe.

00:01:11,000 --> 00:01:15,159
Und Sie haben ähnliche
Dinge in den Übungen gemacht.

00:01:15,159 --> 00:01:19,810
Also, in einer Funktionsdefinition auf der rechten
Seite (als Ausdruck) können wir if-then-else verwenden.

00:01:19,810 --> 00:01:23,520
Es muss eine Bedingung
und dann zwei Ausdrücke geben.

00:01:23,520 --> 00:01:26,840
Sie müssen vom gleichen Typ sein,
sonst würde es keinen Sinn ergeben.

00:01:26,840 --> 00:01:28,260
Und sie müssen immer vorhanden sein.

00:01:28,260 --> 00:01:33,759
Wir können also z.B. nicht das "else" weglassen,
denn dann würde das nicht zu einem vernünftigen

00:01:33,759 --> 00:01:35,880
Wert oder überhaupt
einem Wert ausgewertet werden.

00:01:35,880 --> 00:01:43,580
Das war die Haskell-Syntax, und das
habe ich entsprechend dieser mathematischen Syntax erklärt.

00:01:43,580 --> 00:01:45,900
So weit, so gut.

00:01:45,900 --> 00:01:50,840
Nun, wie ich gerade erwähnt habe, sobald
Sie mehr als eine Bedingung haben, oder Sie

00:01:50,840 --> 00:01:55,560
komplexere Bedingungen haben, dann müssten Sie
auf dieser Seite einen if-then-else-Ausdruck verschachteln.

00:01:55,560 --> 00:01:58,960
Also müssen Sie vielleicht im "then"-Zweig ein
weiteres "if-then-else" haben, um die zweite Bedingung

00:01:58,960 --> 00:02:00,040
zu prüfen.

00:02:00,040 --> 00:02:02,920
Und das wird schnell
nicht mehr so schön.

00:02:02,920 --> 00:02:04,960
In der Mathematik gibt
es natürlich einen anderen Ansatz.

00:02:04,960 --> 00:02:09,679
In der Mathematik neigt man dazu, in einem
Ausdruck wie diesem mehr als zwei Fälle zu schreiben.

00:02:09,679 --> 00:02:12,950
Wir haben also den einen Fall, einen anderen Fall,
und noch einen Fall, ..., und dann den "otherwise"-Fall.

00:02:12,950 --> 00:02:17,819
Mathematiker verschachteln diese Art von Ausdrücken also
nicht, sie geben hier einfach eine längere Liste

00:02:17,819 --> 00:02:25,299
von Bedingungen und Ausdrücken an.

57 # slide
00:02:25,299 --> 00:02:29,669
So etwas lässt sich
auch in Haskell abbilden.

00:02:29,669 --> 00:02:31,760
Das könnte so aussehen.

00:02:31,760 --> 00:02:38,529
Diese Art der Definition haben Sie wahrscheinlich noch
nie gesehen, es sei denn, Sie haben HLint

00:02:38,529 --> 00:02:41,670
benutzt und es hat es vorgeschlagen, was
es bei verschachtelten if-then-else-Ausdrücken zu tun pflegt.

00:02:41,670 --> 00:02:48,480
Dies könnte also ein Beispiel sein, das wir gerade
wieder sehen: eine "scene" aus einem Zeitparameter zu berechnen.

00:02:48,480 --> 00:02:53,841
Und vielleicht gibt es komplexere Bedingungen als
einfach, wenn t kleiner ist als dies, dann

00:02:53,841 --> 00:02:56,290
... else ..., oder
vielleicht gibt es mehr Bedingungen.

00:02:56,290 --> 00:02:57,680
Wir könnten also so
etwas wie das hier haben.

00:02:57,680 --> 00:03:01,430
Und eigentlich, wenn Sie das gerade gelesen
haben, wissen Sie wahrscheinlich, was hier gemeint ist.

00:03:01,430 --> 00:03:07,199
Also, unter der Bedingung, dass t
kleiner-gleich pi ist, sollten wir etwas tun.

00:03:07,199 --> 00:03:13,389
Unter der Bedingung, dass das nicht der Fall
ist, sondern t tatsächlich größer als pi, aber kleiner-gleich

00:03:13,389 --> 00:03:16,629
dem Doppelten von pi ist,
dann sollten wir etwas anderes haben.

00:03:16,629 --> 00:03:24,530
Und unter einer dritten Bedingung, nämlich dass t
tatsächlich größer als 2*pi ist, dann soll noch ein

00:03:24,530 --> 00:03:26,599
anderer Ausdruck ausgewertet werden.

00:03:26,599 --> 00:03:33,879
Dies ist also auch eine Art, bedingtes
Verhalten auszudrücken, und es entspricht sehr direkt

00:03:33,879 --> 00:03:37,109
dem, was Mathematiker gerne schreiben.

00:03:37,109 --> 00:03:46,249
Hier ist eine Funktionsdefinition f(x) = ...,
und dann vielleicht noch drei sich gegenseitig ausschließende

00:03:46,249 --> 00:03:49,010
Bedingungen auf den x-Wert.

00:03:49,010 --> 00:03:55,839
Und je nachdem, was wir
hier haben, bekommen wir unterschiedliche Ausdrücke.

00:03:55,839 --> 00:04:02,219
Genau wie hier könnten wir nun jede beliebige
Boolesche Bedingung schreiben: alles, was in der Mathematik ausgewertet

00:04:02,219 --> 00:04:04,180
oder überprüft werden kann.

00:04:04,180 --> 00:04:07,569
Hier können wir alles schreiben,
was vom Booleschen Typ ist.

00:04:07,569 --> 00:04:12,519
Oft werden das natürlich Vergleiche wie
hier sein, oder Kombinationen von Vergleichen".


00:04:12,519 --> 00:04:13,869
Aber das muss nicht der Fall sein.

00:04:13,869 --> 00:04:17,440
Sie könnten jeden beliebigen Ausdruck schreiben,
der zu einem Boolean ausgewertet wird.

00:04:17,440 --> 00:04:23,259
Es müssen nicht unbedingt arithmetische Vergleiche sein,
die mit "und" und "oder" usw. kombiniert werden.

00:04:23,259 --> 00:04:30,419
Sie können hier alles schreiben, jedes Prädikat,
alles, was zu einem Booleschen Wert ausgewertet wird.

00:04:30,419 --> 00:04:34,330
Und wie ich bereits erwähnt habe,
sobald Sie anfangen, verschachtelte if-then-else-Ausdrücke zu schreiben,

00:04:34,330 --> 00:04:38,050
wird HLint vorschlagen, Dinge
wie diese zu schreiben.

00:04:38,050 --> 00:04:40,880
Dieses HLint ist eine
Komponente innerhalb von Autotool.

00:04:40,880 --> 00:04:46,860
Sie profitieren also von diesen Vorschlägen auch
im Autotool, ohne HLint als separates Tool

00:04:46,860 --> 00:04:52,770
zu verwenden.

58 # slide
00:04:52,770 --> 00:05:00,650
Lassen Sie uns noch einige Details besprechen,
zum Beispiel die Reihenfolge, in der wir

00:05:00,650 --> 00:05:02,130
solche Bedingungen schreiben.

00:05:02,130 --> 00:05:03,800
Also, diese Bedingungen
werden Guards genannt.

00:05:03,800 --> 00:05:06,260
Das ist der Ausdruck
einer Funktion mit Guards.

00:05:06,260 --> 00:05:10,139
Und ein Guard ist diese Art von
Booleschem Ausdruck, der hier geschrieben werden kann.

00:05:10,139 --> 00:05:14,580
In if-then-else ist es klar, was passiert: Sie
haben "if" und dann machen Sie entweder das linke

00:05:14,580 --> 00:05:16,110
oder das rechte, das
"then" oder das "else".

00:05:16,110 --> 00:05:19,740
Es gibt also keine Frage der Reihenfolge, weil
das "then" und das "else" klar sind, in

00:05:19,740 --> 00:05:26,790
welchen Fällen sie ausgeführt werden
(beziehungsweise der entsprechende Ausdruck ausgewertet wird).

00:05:26,790 --> 00:05:31,940
Hier stellt sich nun natürlich zumindest die
Frage, was passiert, wenn sich z. B. diese Guards

00:05:31,940 --> 00:05:33,069
überschneiden.

00:05:33,069 --> 00:05:36,069
Oder ist es egal, in
welcher Reihenfolge man sie aufschreibt?

00:05:36,069 --> 00:05:41,820
Das werde ich am Beispiel der Fakultät diskutieren,
die natürlich auch ein sehr einfaches Beispiel für

00:05:41,820 --> 00:05:42,850
Rekursion ist.

00:05:42,850 --> 00:05:46,719
Also, die factorial-Funktion, wie sie
in der Mathematik definiert ist.

00:05:46,719 --> 00:05:53,090
Man könnte sie natürlich auch über
ein if-then-else schreiben, aber mathematisch gesehen, würde

00:05:53,090 --> 00:05:54,090
man schreiben:

00:05:54,090 --> 00:06:00,080
Die Fakultät einer ganzen Zahl ist eins, wenn
die ganze Zahl Null ist (das ist der Anfang

00:06:00,080 --> 00:06:04,789
der Fakultät-Funktion), und wenn das Argument
größer als Null ist, dann wollen Sie

00:06:04,789 --> 00:06:09,990
n mal Fakultät
des Vorgängers berechnen.

00:06:09,990 --> 00:06:14,310
Das sieht vernünftig aus.

00:06:14,310 --> 00:06:15,969
Was ist nun mit
der Reihenfolge der Klauseln?

00:06:15,969 --> 00:06:20,819
Spielt es also eine Rolle, in
welcher Reihenfolge ich diese Dinge aufschreibe?

00:06:20,819 --> 00:06:22,919
Nun, das hängt von den Bedingungen ab.

00:06:22,919 --> 00:06:26,789
In diesem Fall hier schließen
sich die beiden Bedingungen gegenseitig aus:

00:06:26,789 --> 00:06:33,060
Es ist keine Eingabe n möglich, die
sowohl Null als auch größer als Null wäre.

00:06:33,060 --> 00:06:39,999
Und da das der Fall ist, ist die folgende
Variante, bei der ich die beiden Zeilen hier einfach

00:06:39,999 --> 00:06:42,639
vertauscht habe, gleichwertig.

00:06:42,639 --> 00:06:47,060
Denn es entscheidet einfach der Wert von n, welche
der beiden Zeilen genommen wird, und die Reihenfolge, in

00:06:47,060 --> 00:06:51,229
der diese niedergeschrieben
werden, spielt keine Rolle.

00:06:51,229 --> 00:06:55,219
Nun werde ich weitere Beispiele betrachten,
in denen ich die Guards vertausche, etc.

00:06:55,219 --> 00:07:00,009
Und was ich in der Vergangenheit getan hätte, ist, ein
separates Fenster offen zu haben, in dem ich dieses Programm

00:07:00,009 --> 00:07:05,360
in Haskell habe und das Programm editiere, und
es laufen lasse, um die Auswirkungen zu sehen, wenn

00:07:05,360 --> 00:07:09,330
ich die Reihenfolge der Dinge ändere und
die Bedingungen in den Guards ändere, usw.

00:07:09,330 --> 00:07:13,749
Das will ich jetzt nicht machen,
weil das zu viel Anhalten und Neustarten

00:07:13,749 --> 00:07:15,199
meiner Videoaufzeichnung wäre.

00:07:15,199 --> 00:07:20,360
Was ich also vorschlage, wenn Sie den Argumenten
hier folgen wollen, ist, dass Sie das selbst tun.

00:07:20,360 --> 00:07:26,639
Sie können das Video anhalten und den Code
in ein Editor-Fenster kopieren und diesen dann in GHCi

00:07:26,639 --> 00:07:30,409
ausführen, alle Versionen des
Codes, die ich bespreche.

00:07:30,409 --> 00:07:35,120
Hier werde ich also einfach sagen, was passiert, und
Sie können es selbst überprüfen (wenn Sie den Code

00:07:35,120 --> 00:07:36,120
kopiert haben).

00:07:36,120 --> 00:07:39,150
Aber ich werde das hier
nicht wirklich für alle Versionen demonstrieren.

00:07:39,150 --> 00:07:40,340
Ich werde einfach darüber sprechen.

00:07:40,340 --> 00:07:47,150
Daher wird dies wahrscheinlich etwas kürzer sein, als
wenn ich es in der Vergangenheit getan habe.

00:07:47,150 --> 00:07:48,539
In diesem Beispiel werden wir sehen:

00:07:48,539 --> 00:07:53,689
Egal, welche der beiden Versionen, die wir hier sehen,
genommen wird, wenn Sie es auf etwas wie 12 oder

00:07:53,689 --> 00:07:59,289
was auch immer laufen lassen, irgendeine nette
nicht-negative Zahl (hier sehen Sie schon, dass negative

00:07:59,289 --> 00:08:06,419
Zahlen ein Problem sein könnten, aber lassen
Sie uns "factorial" jetzt nur auf nicht-negative Eingaben

00:08:06,419 --> 00:08:16,319
anwenden), dann verhalten sich diese beiden Versionen,
die wir hier und hier sehen, gleich.



59 # slide
00:08:16,319 --> 00:08:18,180
Was ist, wenn
sich die Guard-Bedingungen überschneiden?

00:08:18,180 --> 00:08:23,580
Wenn Sie also nicht haben, dass einfach
der Eingabewert eindeutig bestimmt, welche der beiden

00:08:23,580 --> 00:08:28,159
Zeilen genommen wird?

00:08:28,159 --> 00:08:33,920
Das könnte damit korrespondieren, dass man das größer
(>) aus der vorherigen Folie in größer-gleich (≥)

00:08:33,920 --> 00:08:35,110
ändert.

00:08:35,110 --> 00:08:37,579
Dann gibt es
plötzlich einen Unterschied.

00:08:37,579 --> 00:08:43,409
Plötzlich funktioniert diese Version noch
gut, aber diese ist problematisch.

00:08:43,409 --> 00:08:49,970
Vielleicht können Sie schon erahnen, was passieren würde,
oder Sie können nebenbei prüfen, was passiert, wenn

00:08:49,970 --> 00:08:58,050
Sie diesen Code nehmen und ihn
noch einmal ausführen, vielleicht mit Eingabe 12.

00:08:58,050 --> 00:09:09,070
Was Sie sehen
sollten, ist ein Laufzeitfehler.

00:09:09,070 --> 00:09:12,910
Warum ist das so?

00:09:12,910 --> 00:09:18,350
Wenn Sie das ausführen und mit 12 beginnen,
dann ist 12 größer-gleich 0; dann haben Sie

00:09:18,350 --> 00:09:21,990
12 * factorial 11.

00:09:21,990 --> 00:09:23,470
Und dann ist in diesem Fall wieder 11.

00:09:23,470 --> 00:09:25,810
Also ist es 11 * factorial 10.

00:09:25,810 --> 00:09:28,650
Das geht runter, runter, runter,
... bis zur Fakultät 0.

00:09:28,650 --> 00:09:34,300
Was dann passiert, ist, dass factorial
0 mit dem zweiten Fall übereinstimmen würde.

00:09:34,300 --> 00:09:38,100
Aber eigentlich wertet Haskell diese
von oben nach unten aus.

00:09:38,100 --> 00:09:41,760
Es wird also zuerst prüfen,
ob die erste Guard-Bedingung erfüllt ist.

00:09:41,760 --> 00:09:47,380
Und für die Eingabe n = 0 ist
dieser erste Guard tatsächlich erfüllt, denn 0 ist größer-gleich

00:09:47,380 --> 00:09:48,380
0.

00:09:48,380 --> 00:09:52,820
Was also passieren wird,
ist: 0 * factorial (-1).

00:09:52,820 --> 00:09:58,360
Und tatsächlich wird Haskell nicht irgendwie magisch
sagen: "Nun, 0 * irgendwas ist irrelevant".

00:09:58,360 --> 00:10:03,310
Stattdessen wird es tatsächlich versuchen,
die Fakultät von -1 zu berechnen.

00:10:03,310 --> 00:10:09,750
Und wenn man dann für die Fakultät von -1
wieder in die Rekursion geht, dann haben wir -1, und

00:10:09,750 --> 00:10:13,610
-1 ist nicht größer oder gleich 0.

00:10:13,610 --> 00:10:15,380
Was ist also factorial (-1)?

00:10:15,380 --> 00:10:16,380
Wir wissen es nicht.

00:10:16,380 --> 00:10:17,380
Der Compiler weiß es nicht.

00:10:17,380 --> 00:10:18,380
Das Laufzeitsystem weiß es nicht.

00:10:18,380 --> 00:10:19,380
Also wird es einen Laufzeitfehler geben.

00:10:19,380 --> 00:10:20,380
Das passiert hier nicht.

00:10:20,380 --> 00:10:21,380
Und warum nicht?

00:10:21,380 --> 00:10:27,490
Weil es hier nicht der Fall ist, dass
wir, sobald wir factorial 0 haben, wieder einen rekursiven

00:10:27,490 --> 00:10:28,960
Aufruf machen.

00:10:28,960 --> 00:10:34,259
Denn beim Auswerten/Prüfen von oben nach unten wird
die Fakultät von null mit dem ersten Fall übereinstimmen.

00:10:34,259 --> 00:10:36,279
Die Ausgabe wird also 1 sein.

00:10:36,279 --> 00:10:37,279
Und dann hört die Rekursion auf.

00:10:37,279 --> 00:10:44,480
Wenn Sie also einen Basisfall wie hier haben, dann
sollte dieser Basisfall der erste in einer solchen Folge von

00:10:44,480 --> 00:10:48,540
Prüfungen sein.

00:10:48,540 --> 00:10:57,340
Manchmal ist der Compiler in der Lage,
vor Fällen wie diesem zu warnen, denn

00:10:57,340 --> 00:11:01,160
im Wesentlichen ist der Laufzeitfehler, den wir
dadurch bekommen, dass dies nicht vollständig definiert ist.

00:11:01,160 --> 00:11:05,890
Integers enthalten negative Zahlen, aber für
negative Zahlen geben wir keinen Fall an.

00:11:05,890 --> 00:11:11,279
Manchmal ist der Compiler in der
Lage, vor diesem Problem zu warnen.

60 # slide
00:11:11,279 --> 00:11:18,940
Okay, aber sagen wir mal,
wir machen diesen Fehler nicht.

00:11:18,940 --> 00:11:23,690
Sagen wir, wir bleiben
bei der korrekten Reihenfolge.

00:11:23,690 --> 00:11:27,779
Was ist dann das Problem?

00:11:27,779 --> 00:11:33,190
Wir haben nicht das Problem, dass wir, wenn wir mit
12 beginnen, zu null und dann zu 0 * factorial (-1)

00:11:33,190 --> 00:11:34,190
kommen.

00:11:34,190 --> 00:11:35,250
Dieses Problem haben wir nicht.

00:11:35,250 --> 00:11:41,010
Wenn wir aber gleich diese Funktion mit
-1 aufrufen, haben wir wieder einen Laufzeitfehler.

00:11:41,010 --> 00:11:46,920
Wenn wir also mit -1 aufrufen, dann
passt weder der Basisfall noch der rekursive Fall.

00:11:46,920 --> 00:11:51,560
Wir erhalten also einen Laufzeitfehler.

61 # slide
00:11:51,560 --> 00:11:58,199
Wie bereits erwähnt, kann uns der Compiler
mit entsprechenden Einstellungen vor diesem Fehler warnen.

00:11:58,199 --> 00:12:05,230
Und im Autotool werden wir diese
Warnungen fortan aktivieren, sodass der Compiler

00:12:05,230 --> 00:12:13,630
sich beschwert, wenn Sie z. B. mit Guards
programmieren und nicht darauf achten, dass es

00:12:13,630 --> 00:12:15,380
immer einen passenden Fall gibt.

00:12:15,380 --> 00:12:18,800
Der Compiler kann natürlich nicht mit
Sicherheit wissen, ob Sie alle Fälle abdecken.

00:12:18,800 --> 00:12:21,250
Also wird der
Compiler übervorsichtig sein.

00:12:21,250 --> 00:12:26,440
Es kann also sein, dass er Sie
warnt, obwohl man mit etwas mathematischem Verständnis sehen

00:12:26,440 --> 00:12:28,880
kann, dass Ihr Code alle Fälle abdeckt.

00:12:28,880 --> 00:12:34,500
Der Compiler versucht, Sie vor Fällen zu warnen, bei
denen er nicht weiß, dass Sie alle Fälle abgedeckt

00:12:34,500 --> 00:12:37,880
haben, weil er es nicht erkennen kann.

00:12:37,880 --> 00:12:43,079
Eine Möglichkeit, um sicherzustellen, dass Sie alle Fälle abgedeckt
haben, und auch, um den Compiler sicher sein zu lassen,

00:12:43,079 --> 00:12:47,160
dass Sie alle Fälle abgedeckt haben, ist,
dass Sie so etwas wie eine "catch-all"-Klausel haben.



00:12:47,160 --> 00:12:53,410
In dem Beispiel von vorhin könnten Sie, anstatt
zwei Bedingungen zu haben, von denen eine n==0 und

00:12:53,410 --> 00:12:58,230
die andere etwas wie n>0
oder n>=0 ist, sagen: "otherwise".

00:12:58,230 --> 00:13:05,399
Dann wird von oben nach unten geprüft. Für
jede Eingabe, die nicht null ist, wird diese letzte

00:13:05,399 --> 00:13:06,399
Zeile genommen.

00:13:06,399 --> 00:13:13,000
Zumindest haben wir dann keinen Laufzeitfehler, in dem
Sinne, dass die Fakultät für eine Eingabe nicht

00:13:13,000 --> 00:13:15,540
weiß, was sie berechnen soll.

00:13:15,540 --> 00:13:21,320
In GHCi würde das jetzt
also nicht zu einem Laufzeitfehler führen.

00:13:21,320 --> 00:13:25,670
Natürlich könnte es trotzdem ein Problem sein,
wenn Sie mit negativen Werten aufrufen, aber

00:13:25,670 --> 00:13:31,190
dann nicht wegen eines Laufzeitfehlers (eines
fehlenden Falls), sondern tatsächlich wegen Nichttermination.

00:13:31,190 --> 00:13:36,860
Denn dann laufen Sie (beim Aufruf
mit negativen Eingaben) in eine unendliche Rekursion.

00:13:36,860 --> 00:13:39,050
Denn bei negativen Werten
hört man nie auf.

00:13:39,050 --> 00:13:40,300
Aber das ist ein separates Problem.

00:13:40,300 --> 00:13:46,779
Und natürlich ein Problem, das kein
Compiler im Allgemeinen abfangen kann; einfach

00:13:46,779 --> 00:13:52,910
wegen des "Halteproblems".

62 # slide
00:13:52,910 --> 00:13:53,910
Das war diese Beobachtung.

00:13:53,910 --> 00:13:56,660
In diesem Fall würden
negative Eingaben ein Problem darstellen.

00:13:56,660 --> 00:14:00,389
Wir könnten das auch in
gewissem Sinne beheben, indem wir sagen:

00:14:00,389 --> 00:14:05,700
Wir nehmen den Basisfall, wann immer wir einen nicht-positiven
Wert haben; nicht nur für null, sondern auch für negative

00:14:05,700 --> 00:14:06,700
Werte.

00:14:06,700 --> 00:14:10,579
Das wäre dann etwas, das den Compiler
besteht, denn der Compiler kann erkennen, dass

00:14:10,579 --> 00:14:12,820
wir alle Fälle abgedeckt haben.

00:14:12,820 --> 00:14:18,170
Er hat auch nie ein Problem zur Laufzeit,
dass er nicht weiß, welchen Fall er nehmen soll,

00:14:18,170 --> 00:14:19,430
eben wegen dieses letzten Falles.

00:14:19,430 --> 00:14:20,920
Der Compiler garantiert dies also.

00:14:20,920 --> 00:14:26,639
Dann stimmt es, dass Ihnen sozusagen nie
die zu berücksichtigenden Fälle ausgehen, weil immer der

00:14:26,639 --> 00:14:28,070
"otherwise"-Fall gilt.

00:14:28,070 --> 00:14:36,620
Und es gibt auch kein Nicht-Abbruch-Problem,
einfach, weil wir irgendwann nach so

00:14:36,620 --> 00:14:42,629
vielen Reduzierungen oder gleich beim Aufruf
mit einem negativen Wert immer diesen Fall

00:14:42,629 --> 00:14:49,519
erreichen (entweder sofort oder nach
einer endlichen Anzahl von Schritten).

00:14:49,519 --> 00:14:53,760
Also, einige Lektionen hier:

00:14:53,760 --> 00:14:58,649
Die Reihenfolge spielt eine Rolle bei
der Auswahl der Zeile, die wir nehmen.

00:14:58,649 --> 00:15:03,470
Die Semantik wird
die Reihenfolge berücksichtigen.

00:15:03,470 --> 00:15:06,009
Das bedeutet auch, dass
wir diese Reihenfolge ausnutzen können.

00:15:06,009 --> 00:15:08,350
So können wir vielleicht
einige spätere Bedingungen vereinfachen.

00:15:08,350 --> 00:15:12,040
Wir werden das gleich
an einem Beispiel sehen.

00:15:12,040 --> 00:15:23,029
Wir können einige spätere Bedingungen vereinfachen, da
wir wissen, dass die vorhergehenden Guards bereits

00:15:23,029 --> 00:15:24,089
überprüft wurden.

00:15:24,089 --> 00:15:29,459
Die Vollständigkeit ist wichtig,
weil wir Laufzeitfehler vermeiden wollen.

63 # slide
00:15:29,459 --> 00:15:37,350
Nun einige weitere Anmerkungen.

00:15:37,350 --> 00:15:40,610
Die Compiler-Prüfungen im Vorfeld sind
nett, aber sie sind nicht perfekt.

00:15:40,610 --> 00:15:44,230
Sie können nicht perfekt
sein, z.B. wegen des "Halteproblems".

00:15:44,230 --> 00:15:48,560
So ist es z.B. unmöglich, unendliche Rekursion
zu erkennen, aber auch einige andere Probleme,

00:15:48,560 --> 00:15:50,339
die ein Programm haben könnte.

00:15:50,339 --> 00:16:00,920
Haskell macht einen ziemlich guten Job, um vermeidbare Fehler
zu verhindern, aber es kann nicht alle Probleme beheben.

00:16:00,920 --> 00:16:06,860
Selbst die einfacheren Prüfungen, die nicht auf
Perfektion abzielen, sind nicht so mächtig, wie man

00:16:06,860 --> 00:16:08,220
manchmal hoffen könnte.

00:16:08,220 --> 00:16:13,149
Manchmal könnte man aufgrund einer mathematischen Einsicht
in das Problem denken, dass der Compiler in

00:16:13,149 --> 00:16:17,019
der Lage sein sollte, zu erkennen,
dass eine bestimmte Definition erschöpfend ist.

00:16:17,019 --> 00:16:19,519
Aber manchmal ist das nicht der
Fall, und zwar aus gutem Grund.

00:16:19,519 --> 00:16:20,550
Hier ist ein Beispiel.

00:16:20,550 --> 00:16:26,930
Es wird Sie davor warnen, sich auf
bestimmte Eigenschaften zu verlassen, z.B. auf Beziehungen aus

00:16:26,930 --> 00:16:27,930
der Mathematik.

00:16:27,930 --> 00:16:33,680
Sie könnten denken, wenn Sie eine Bedingung wie diese schreiben,
f x y ist: wenn x und y gleich sind,

00:16:33,680 --> 00:16:39,629
dann etwas, und wenn x und y nicht
gleich sind, dann etwas anderes; Sie könnten annehmen,

00:16:39,629 --> 00:16:41,810
dass dies statisch sicher wäre.

00:16:41,810 --> 00:16:45,490
Nun, der Compiler wird nicht in der Lage sein,
zu sagen, dass dies sicher ist, etwa weil "im

00:16:45,490 --> 00:16:50,480
Grunde diese beiden Dinge Gegensätze voneinander, sodass
nur und genau eines von ihnen wahr sein wird".

00:16:50,480 --> 00:16:54,360
Das ist eine vernünftige Annahme,
aber tatsächlich nicht so einfach.

00:16:54,360 --> 00:17:00,110
Es gibt einen guten Grund, warum dies vom
Compiler im Allgemeinen nicht als sicher angesehen wird.

00:17:00,110 --> 00:17:06,830
Und der Grund ist, dass dies zwar für
Basistypen wie Zahlen, Zeichen oder Zeichenketten gilt (dass bei



00:17:06,830 --> 00:17:13,250
diesen beiden Dingen immer eines davon wahr
sein wird); aber tatsächlich können Sie in

00:17:13,250 --> 00:17:18,760
Haskell Gleichheit und Ungleichheit für Ihre eigenen
Typen überladen, und niemand kann Sie als

00:17:18,760 --> 00:17:24,371
Programmierer daran hindern, einen neuen Typ mit
Gleichheits- und Ungleichheitsprüfungen zu schreiben, bei dem

00:17:24,371 --> 00:17:29,050
es einige Wertepaare x und y gibt,
bei denen keine dieser beiden Bedingungen wahr ist.

00:17:29,050 --> 00:17:32,410
Und dann kann der Compiler nicht versprechen, dass
eine der beiden Bedingungen immer wahr sein wird.

00:17:32,410 --> 00:17:34,930
Vielleicht ist das für Ihren
eigenen Typ nicht einmal der Fall.

00:17:34,930 --> 00:17:40,440
In diesem Sinne ist es also besser,
die zweite Bedingung wieder durch "otherwise" zu

00:17:40,440 --> 00:17:53,590
ersetzen, denn dann kann auch der Compiler sagen,
dass definitiv einer der beiden Fälle zutreffen wird.

64 # slide
00:17:53,590 --> 00:18:01,790
Außerdem wären wir in einer idealen Welt nicht
so sehr auf das Massieren unserer Guard-Bedingungen angewiesen.

00:18:01,790 --> 00:18:06,790
Kehren wir also zu diesem Thema zurück,
bei dem wir Probleme mit negativen Eingaben hatten.

00:18:06,790 --> 00:18:13,190
Und die Lösung war, im ersten Fall von n == 0
auf n ≤ 0 umzuschalten, denn dann hätten wir alle Fälle

00:18:13,190 --> 00:18:20,850
abgedeckt und wären auch bei negativen
Eingaben nicht in eine unendliche Rekursion geraten.

00:18:20,850 --> 00:18:26,040
Man könnte einwenden, dass das nicht das
ist, was man will: dass diese Fakultät für

00:18:26,040 --> 00:18:29,400
alle negativen Zahlen eins zurückgibt,
wenn man hier auf "n ≤ 0" wechselt.

00:18:29,400 --> 00:18:35,240
Die eigentliche Lösung (die konzeptionell ansprechendste Lösung) wäre
also, das Typsystem zu verwenden, um zu verhindern,

00:18:35,240 --> 00:18:37,500
dass man hier negative Eingaben bekommt.

00:18:37,500 --> 00:18:44,630
Der Typ 'Integer' enthält also negative Zahlen,
aber man könnte ein ausdrucksstärkeres Typsystem verwenden,

00:18:44,630 --> 00:18:49,220
das tatsächlich garantieren kann, dass die
Fakultät in einem gegebenen Programm niemals auf

00:18:49,220 --> 00:18:50,910
negativen Zahlen aufgerufen wird.

00:18:50,910 --> 00:18:56,400
Das ist etwas, das möglich ist, aber das
ist wirklich ein Thema für eine andere Vorlesung, und

00:18:56,400 --> 00:18:57,770
vielleicht nicht einmal für diesen Kurs.

00:18:57,770 --> 00:19:03,741
Es ist eigentlich für einen anderen Kurs oder ein
Seminar oder eine weiterführende Vorlesung, nicht unbedingt für dieses

00:19:03,741 --> 00:19:04,741
Semester.

00:19:04,741 --> 00:19:16,760
Ich wollte nur erwähnen, dass eine
solche eher statische Lösung auch möglich ist.

65 # slide
00:19:16,760 --> 00:19:18,000
Aber lassen Sie uns
nicht in diese Richtung gehen.

00:19:18,000 --> 00:19:24,270
Wenden wir unsere Erkenntnisse, die wir bei der Besprechung
des factorial-Beispiels gewonnen haben, zunächst auf die Situation an,

00:19:24,270 --> 00:19:25,690
die wir vorhin betrachtet haben.

00:19:25,690 --> 00:19:27,480
Wir hatten die Funktion "scene".

00:19:27,480 --> 00:19:29,890
Und mathematisch habe
ich sie so geschrieben:

00:19:29,890 --> 00:19:36,550
Ich prüfe, ob t kleiner-gleich pi ist, dann
prüfe ich die nächste Periode von pi bis 2 * pi,

00:19:36,550 --> 00:19:40,260
und dann über 2 * pi (das könnte
etwas sein, was ich ausdrücken möchte).

00:19:40,260 --> 00:19:46,180
Nun, angesichts dessen, was wir über die Reihenfolge der
Überprüfung solcher Guards wissen, und was wir über erschöpfende

00:19:46,180 --> 00:19:52,310
Definitionen wissen, können wir
dies ein wenig revidieren.

00:19:52,310 --> 00:19:58,990
Der ideale Weg, dies zu schreiben, wäre also so etwas
wie das hier, was sowohl kürzer ist als auch einige zusätzliche

00:19:58,990 --> 00:20:02,680
Vorteile hat, wie
z. B. bekanntes Erschöpfen.

00:20:02,680 --> 00:20:04,130
Was ist hier der Unterschied?

00:20:04,130 --> 00:20:06,300
Die erste Bedingung ist
immer noch wie oben.

00:20:06,300 --> 00:20:13,870
In der zweiten Bedingung muss nicht geprüft
werden, ob t größer als pi ist, weil

00:20:13,870 --> 00:20:18,760
wir wissen, dass die zweite Zeile nur
geprüft wird, wenn die erste Zeile nicht zutrifft.

00:20:18,760 --> 00:20:24,090
Wir kommen also nur in die zweite
Zeile, wenn die erste Bedingung nicht wahr war.

00:20:24,090 --> 00:20:30,300
Und da es sich um Fließkommazahlen handelt,
wissen wir genau, dass t größer als

00:20:30,300 --> 00:20:32,590
pi ist, wenn t
nicht kleiner-gleich pi ist.

00:20:32,590 --> 00:20:36,830
Also ist diese Prüfung in diesem
Guard hier eigentlich überflüssig in diesem Sinne.

00:20:36,830 --> 00:20:43,460
Denn die zweite Zeile erreichen wir ohnehin
nur, wenn diese erste nicht gültig war.

00:20:43,460 --> 00:20:50,380
Und ganz ähnlich können wir argumentieren, dass
wir in der letzten Zeile dies nicht prüfen

00:20:50,380 --> 00:20:55,680
müssen, denn wenn dies nicht wahr wäre,
dann hätten wir schon den Fall vorher genommen.

00:20:55,680 --> 00:21:01,530
Indem wir hier also "otherwise" schreiben, drücken wir
dieselben Bedingungen aus, und wir helfen dem Compiler

00:21:01,530 --> 00:21:08,010
zu wissen, dass dies ein
gültiger und vollständiger Ausdruck ist.

00:21:08,010 --> 00:21:16,070
Wir vermeiden also syntaktische Wiederholungen, wir vermeiden redundante
Prüfungen, indem wir die Reihenfolge ausnutzen und das,

00:21:16,070 --> 00:21:20,220
was wir über
die Vollständigkeit wissen.

00:21:20,220 --> 00:21:26,330
Und in gewisser Weise würde ich behaupten,
dass wir die Definition auch lesbarer gemacht haben.

00:21:26,330 --> 00:21:31,520
Versuchen Sie also, Strategien wie diese in
Ihren nächsten Übungsaufgaben anzuwenden, wenn Sie komplexe

00:21:31,520 --> 00:21:37,420
Bedingungen wie oben haben.



66 # slide
00:21:37,420 --> 00:21:43,290
Schauen wir uns noch ein paar weitere
Beispiele und verschiedene Möglichkeiten an, Definitionen zu schreiben.

00:21:43,290 --> 00:21:49,570
Bisher haben wir immer den Fall betrachtet,
dass wir im Grunde einen "Funktionskopf" haben, wenn

00:21:49,570 --> 00:21:52,230
Sie so wollen, und
dann eventuell mehrere Guards.

00:21:52,230 --> 00:21:56,680
Tatsächlich können wir aber auch
mehrere Zeilen für eine Funktionsdefinition schreiben.

00:21:56,680 --> 00:22:02,100
Anstatt also "factorial n" und dann diesen Guard
und diesen Guard zu haben, könnten wir diesen

00:22:02,100 --> 00:22:03,320
Kopf auch mehrfach haben.

00:22:03,320 --> 00:22:09,490
Wenn wir also sagen: Fakultät n unter der
Bedingung, dass n gleich null ist, ist eins, und

00:22:09,490 --> 00:22:14,530
Fakultät n unter der Bedingung "otherwise"
(die eigentlich keine Bedingung ist,

00:22:14,530 --> 00:22:16,640
weil sie immer wahr ist), berechnet
n * factorial (n - 1).

00:22:16,640 --> 00:22:19,890
Dies wäre also äquivalent zu den
Versionen, die wir bisher gesehen haben.

00:22:19,890 --> 00:22:24,790
Warum sollten wir das überhaupt
tun (es mehrfach zu schreiben)?

00:22:24,790 --> 00:22:30,750
Nun, dank der Top-Down-Auswertungsreihenfolge in Bezug
auf die Auswahl der Fälle können wir

00:22:30,750 --> 00:22:33,240
es dann z.B. auch so schreiben.

00:22:33,240 --> 00:22:38,860
Was vielleicht ansprechender wäre, zu sagen: factorial
n unter irgendeiner Bedingung ist eins, und factorial

00:22:38,860 --> 00:22:42,160
n ohne irgendeine Bedingung ist das.

00:22:42,160 --> 00:22:46,730
Und da dies von oben nach unten ausgewertet wird,
hat es die gleiche Semantik wie das, was wir hier

00:22:46,730 --> 00:22:49,420
oben geschrieben haben.

00:22:49,420 --> 00:22:54,920
Es ist natürlich auch wieder
anfällig für Änderungen in der Reihenfolge.

00:22:54,920 --> 00:22:59,750
Wenn wir hier also die Reihenfolge ändern, dann kann
sich das, was berechnet wird, oder ob es abbricht,

00:22:59,750 --> 00:23:01,630
komplett ändern.

00:23:01,630 --> 00:23:09,540
Eine andere syntaktische Möglichkeit ist so etwas wie
eine Prüfung wie diese: factorial n unter der Bedingung,

00:23:09,540 --> 00:23:11,880
dass n gleich null ist, ist etwas.

00:23:11,880 --> 00:23:15,060
Diese Bedingung n == 0 würden
Sie in der Mathematik anders schreiben.

00:23:15,060 --> 00:23:17,270
Sie würden einfach sagen:
Fakultät von null ist eins.

00:23:17,270 --> 00:23:21,130
Anstatt zu sagen: Die Fakultät von n,
wenn das gleich null ist, ist eins.

00:23:21,130 --> 00:23:24,210
Dann können wir die
erste Zeile auch so schreiben.

00:23:24,210 --> 00:23:28,740
Und dann zahlt es sich wirklich aus, dass wir
mehrere Zeilen schreiben, statt uns auf Guards zu verlassen.

00:23:28,740 --> 00:23:34,470
Hier sagen wir: Die Fakultät von null ist
eins, und die Fakultät von n ist dies.

00:23:34,470 --> 00:23:41,460
Und da wir von oben nach unten prüfen, bedeutet
die letzte Zeile eigentlich die Fakultät für ein beliebiges

00:23:41,460 --> 00:23:44,240
n ungleich null, weil
null hier schon behandelt wird.

00:23:44,240 --> 00:23:49,760
Und das ist jetzt wieder etwas, was
Sie so ähnlich auch in einer Lehrbuchdefinition (in

00:23:49,760 --> 00:23:52,520
der Mathematik) der
Fakultät finden würden.

00:23:52,520 --> 00:23:57,750
Da steht: Fakultät 0 ist dies und
Fakultät von n (im Hinterkopf: für irgendetwas anderes

00:23:57,750 --> 00:24:00,750
als null) ist dieser Ausdruck.

00:24:00,750 --> 00:24:05,510
Sie können diese Stile mischen und für Ihre
Funktion, die Sie ausdrücken wollen, herausfinden, was die

00:24:05,510 --> 00:24:12,280
schönste Art ist, die Fallunterscheidungen auszudrücken, die
Sie für die Lösung Ihres Problems brauchen.

00:24:12,280 --> 00:24:13,490
Dies kann gemischt werden.

00:24:13,490 --> 00:24:19,080
Schauen wir uns also ein anderes Beispiel
an, bei dem wir mehrere Eingabewerte haben und

00:24:19,080 --> 00:24:28,650
dann auch diese Art
von Guard-Stil und Matchen-gegen-Konstanten-Stil mischen.

67 # slide
00:24:28,650 --> 00:24:29,830
Dies ist ein solches Beispiel.

00:24:29,830 --> 00:24:37,930
Dies ist die Ackermann-Funktion, die Sie
vielleicht aus Ihrer Vorlesung über Komplexitätstheorie kennen.

00:24:37,930 --> 00:24:40,000
Und selbst wenn Sie das nicht
tun, ist es nicht wirklich wichtig.

00:24:40,000 --> 00:24:43,530
Es ist eine Funktion, die
einige interessante und komplexe Bedingungen hat.

00:24:43,530 --> 00:24:45,220
So hat sie verschiedene Basisfälle.

00:24:45,220 --> 00:24:50,680
Entweder ist die erste oder die zweite
Eingabe null, aber es gibt auch einige Bedingungen

00:24:50,680 --> 00:24:53,540
für die jeweils andere Eingabe.

00:24:53,540 --> 00:24:58,520
Sie können beides ausdrücken, den Abgleich gegen
die Konstante, aber auch die zusätzliche Bedingung

00:24:58,520 --> 00:25:00,450
an der anderen Eingabe.

00:25:00,450 --> 00:25:01,960
Und hier ist es andersherum.

00:25:01,960 --> 00:25:07,610
Wir haben die Bedingung durch eine Konstantenübereinstimmung
auf dem zweiten Argument und irgendeine explizit

00:25:07,610 --> 00:25:11,510
formulierte Bedingung auf
der ersten Eingabe.

00:25:11,510 --> 00:25:18,480
Und es gibt auch einen Fall, in
dem wir numerische Prüfungen auf beiden Eingaben haben.

00:25:18,480 --> 00:25:22,600
Dann haben wir in jedem Fall
irgendeinen Ausdruck, der berechnet werden muss.

00:25:22,600 --> 00:25:26,200
Es ist nicht wirklich wichtig, was die Funktion
genau tut; der Punkt ist, dass wir diese Art

00:25:26,200 --> 00:25:29,120
haben, unsere Bedingungen auszudrücken.

00:25:29,120 --> 00:25:31,880
Und wieder wird dies
von oben nach unten abgeglichen.

00:25:31,880 --> 00:25:36,740
Wenn also die erste Eingabe null ist
und die zweite eine nicht-negative Zahl, dann wird

00:25:36,740 --> 00:25:38,940
der erste Basisfall genommen.

00:25:38,940 --> 00:25:44,720
Wenn Sie dies mit GHC ausprobieren, erhalten
Sie einige Warnungen, dass die Bedingungen nicht erfüllt sind.



00:25:44,720 --> 00:25:51,510
sind, da der Compiler auch hier versucht,
herauszufinden, ob Sie alle Fälle erfüllt haben oder

00:25:51,510 --> 00:25:52,510
nicht.

00:25:52,510 --> 00:25:57,390
Sie sollten sich die Warnungen ansehen und versuchen, sie
zu interpretieren, um zu sehen, wie weit der Compiler

00:25:57,390 --> 00:26:03,370
es geschafft hat, dieses Programm und die
verschiedenen Fälle, die hier auftreten, zu analysieren.

68 # slide
00:26:03,370 --> 00:26:08,440
Das war nur ein Beispiel.

00:26:08,440 --> 00:26:11,350
Lassen Sie uns eigentlich
zu einigen allgemeinen Bemerkungen zurückkehren.

00:26:11,350 --> 00:26:16,290
Und das wird fast
das Ende dieses Videos sein.

00:26:16,290 --> 00:26:21,810
Lassen Sie uns also rekapitulieren, was
die allgemeinen Regeln für Funktionsdefinitionen sind.

00:26:21,810 --> 00:26:23,110
Wir können eine
oder mehrere Gleichungen haben.

00:26:23,110 --> 00:26:24,110
Wir haben mit einer angefangen.

00:26:24,110 --> 00:26:27,580
Aber jetzt haben wir gesehen, dass wir
mehrere Gleichungen für eine Funktion haben können.

00:26:27,580 --> 00:26:29,910
Und sie werden von
oben nach unten geprüft.

00:26:29,910 --> 00:26:39,080
Und diese Gleichungen können Guards haben, müssen es
aber nicht, wie wir gerade bei der Funktion Fakultät

00:26:39,080 --> 00:26:40,580
gesehen haben.

00:26:40,580 --> 00:26:43,810
Es kann ein oder mehrere Argumente geben.

00:26:43,810 --> 00:26:49,290
Bisher sind diese Argumente Variablennamen, auf die
Sie vielleicht einige Bedingungen über Guards ausdrücken wollen,

00:26:49,290 --> 00:26:55,990
oder sie können Konstanten wie null oder eins
sein, die wir in einigen der Beispiele gesehen

00:26:55,990 --> 00:26:56,990
haben.

00:26:56,990 --> 00:26:58,370
Die Variablennamen können anonym sein.

00:26:58,370 --> 00:27:05,550
Das heißt, wie Sie gleich in einem Beispiel
auf der letzten Folie für heute sehen werden, wir

00:27:05,550 --> 00:27:09,630
können Fälle haben, in denen wir gegen eine
Variable abgleichen, aber diese Variable nie wieder verwenden werden.

00:27:09,630 --> 00:27:13,560
Und damit sich der Compiler nicht beschwert,
dass wir eine Variable benannt haben, die wir

00:27:13,560 --> 00:27:18,510
nicht verwenden, können wir das "_" als
eine Variable verwenden, die wir nie verwenden werden.

00:27:18,510 --> 00:27:25,300
Das wird nützlich sein, wie Sie
auf der nächsten Folie sehen werden.

00:27:25,300 --> 00:27:28,200
Innerhalb einer Gleichung müssen
die Variablennamen eindeutig sein.

00:27:28,200 --> 00:27:33,390
Wie wir also vor ein paar Folien gesehen haben,
können wir zwei Gleichungen für die Fakultät mit demselben

00:27:33,390 --> 00:27:35,870
Variablennamen haben, aber
es sind unterschiedliche Gleichungen.

00:27:35,870 --> 00:27:39,300
In einer Gleichung können wir
nicht ZWEIMAL DEN GLEICHEN Variablennamen haben.

00:27:39,300 --> 00:27:42,420
Wir können nicht ackermann von n
und n haben (ackermann n n).

00:27:42,420 --> 00:27:46,630
Wir können ackermann von n und m
haben, aber nicht ackermann von n und n.

00:27:46,630 --> 00:27:50,260
Denn in einer Zeile, in einer
Gleichung, müssen die Variablennamen eindeutig sein.

00:27:50,260 --> 00:27:53,290
Dies gilt nicht für anonyme Variablen.

00:27:53,290 --> 00:28:00,480
Wir können mehrere anonyme Variablen in einer Zeile
haben, und das stellt nicht irgendwie eine Gefahr

00:28:00,480 --> 00:28:01,480
dar.

00:28:01,480 --> 00:28:07,170
Und schließlich ist dies vielleicht nicht etwas, das Sie
ausprobieren würden, aber für den Fall, dass Sie es tun

00:28:07,170 --> 00:28:13,500
würden (weil Sie vielleicht mathematische Definitionen gesehen
haben, die eine Funktionalität wie "Lösen von Bedingungen

00:28:13,500 --> 00:28:20,750
an Eingaben über
mathematische Ausdrücke" verwenden):

00:28:20,750 --> 00:28:27,220
So etwas wie eine Funktionsdefinition in der
Mathematik, die zum Beispiel sagt: f(2×n)= ...

00:28:27,220 --> 00:28:33,460
(etwas, das "f(n)" beinhaltet); das ist eine
Definitionsart, die Leute manchmal in der Mathematik schreiben

00:28:33,460 --> 00:28:39,140
(weil sie vielleicht eine Funktion für alle geraden
ganzen Zahlen definieren wollen, also sagen sie: f(2×n)=

00:28:39,140 --> 00:28:41,400
...); aber das ist nicht
etwas, das Haskell akzeptieren würde.

00:28:41,400 --> 00:28:46,520
Denn dann müsste Haskell aus einer gegebenen
Eingabe wie 12 herausfinden, ob das zu

00:28:46,520 --> 00:28:47,740
2×n passt oder nicht.

00:28:47,740 --> 00:28:53,820
Haskell müsste also tatsächlich arithmetische Gleichungen auf eine
Weise lösen, die nicht so allgemein möglich ist, wie

00:28:53,820 --> 00:28:56,020
man es sich in
einem Compiler wünschen würde.

00:28:56,020 --> 00:28:57,270
Es ist also nicht möglich.

00:28:57,270 --> 00:29:03,000
In diesen Argumentpositionen können wir also
einfache Dinge haben, wie Konstanten, Variablennamen, später

00:29:03,000 --> 00:29:09,070
auch einige Patterns über Datentypen, aber
nicht so etwas wie einen arithmetischen

00:29:09,070 --> 00:29:12,080
Ausdruck beliebiger Art, wie 2 * n.

00:29:12,080 --> 00:29:21,200
Denn das würde das "Lösen" von
Gleichungen erfordern, nur um zu entscheiden, welche

00:29:21,200 --> 00:29:25,530
Funktionsdefinition für eine bestimmte
Eingabesituation zu nehmen ist.

00:29:25,530 --> 00:29:28,830
Dies ist nur eine Randbemerkung.

00:29:28,830 --> 00:29:33,350
Lassen Sie mich zum Schluss eigentlich
nur noch ein Beispiel dafür zeigen.

00:29:33,350 --> 00:29:35,100
Was meine ich mit anonymen Variablen?

00:29:35,100 --> 00:29:38,000
Und warum sind sie nützlich?

69 # slide
00:29:38,000 --> 00:29:42,020
Nun, lassen Sie
uns dieses Beispiel betrachten.

00:29:42,020 --> 00:29:50,720
Sagen wir also, wir wollen die
logischen Operationen auf dem Typ 'Boolean' definieren.

00:29:50,720 --> 00:29:53,410
Wir könnten sagen: "not True =
False" und "not False = True".

00:29:53,410 --> 00:29:58,860
Aber eigentlich brauchen wir in der zweiten
Zeile nicht "not False = True" zu schreiben.



00:29:58,860 --> 00:30:04,040
denn das Einzige, was hier stehen kann,
wäre "False", weil "True" bereits behandelt wird.

00:30:04,040 --> 00:30:10,220
Dann könnten wir sagen: Gut, schreiben wir "not x
= True", also verwenden wir hier eine Variable namens x.

00:30:10,220 --> 00:30:14,610
Aber auch das wäre nicht so schön, denn
dann ist das x auf der rechten Seite unbenutzt.

00:30:14,610 --> 00:30:18,800
Und bei bestimmten Einstellungen würde sich
der Compiler sogar beschweren, dass Sie eine

00:30:18,800 --> 00:30:22,520
Variable x einführen, aber dann im
Scope das x gar nicht verwenden.

00:30:22,520 --> 00:30:25,600
Und dann ist die Lösung "_", was
im Grunde genommen sagt: "Das ist mir egal".

00:30:25,600 --> 00:30:30,860
Also ist "not" von "True" "False", und "not"
wovon auch immer ist "True", was angesichts der

00:30:30,860 --> 00:30:34,140
Reihenfolge, in der es ausgewertet
wird, eine perfekte Definition ist.

00:30:34,140 --> 00:30:37,450
Und es ist
auch sehr intuitiv geschrieben.

00:30:37,450 --> 00:30:41,200
Und ähnlich könnte man auch
bei anderen logischen Operationen vorgehen.

00:30:41,200 --> 00:30:46,790
Sagen wir zum Beispiel, wir wollen
die Konjunktion von booleschen Werten implementieren.

00:30:46,790 --> 00:30:51,380
Dann könnten wir sagen: "True and True ist
True", und wir könnten drei Fälle schreiben wie "True

00:30:51,380 --> 00:30:55,150
and False ist False", "False and True
ist False" und "False and False ist False".

00:30:55,150 --> 00:30:59,970
Aber warum sollten wir das tun, wenn wir auch
sagen können: "was auch immer 'and' was auch immer

00:30:59,970 --> 00:31:03,060
ist False", da "True and True"
bereits durch die erste Zeile geprüft wurde?

00:31:03,060 --> 00:31:09,070
Dann ist damit sehr
kompakt definiert, wie Konjunktion funktioniert.

00:31:09,070 --> 00:31:14,490
Und ähnlich könnten wir
auch einen anderen Stil verwenden.

00:31:14,490 --> 00:31:20,040
Wir könnten sagen: "b and True ist
b" und "egal and egal ist False".

00:31:20,040 --> 00:31:23,040
Dann würden wir zwei Fälle
in der ersten Zeile behandeln.

00:31:23,040 --> 00:31:32,260
Es ist vielleicht ein bisschen Geschmackssache,
welche dieser beiden Versionen man wählt.

00:31:32,260 --> 00:31:35,660
Für Ihre Übungsaufgaben ist
das nicht wirklich wichtig.

00:31:35,660 --> 00:31:41,820
In der Realität gibt es einen kleinen
Unterschied zwischen diesen beiden Versionen der Funktion, insbesondere

00:31:41,820 --> 00:31:47,780
dann, wenn Sie sie mit teuren
Berechnungen wie der Ackermann-Funktion in einer der

00:31:47,780 --> 00:31:48,970
Argumentpositionen kombinieren.

00:31:48,970 --> 00:31:57,620
Aber das werden Fälle sein, die nicht in
der Art und Weise auftreten, wie Sie z. B. Konjunktionen

00:31:57,620 --> 00:31:59,760
und Bedingungskombinationen
verwenden wollen.

00:31:59,760 --> 00:32:03,710
Ich werde also nicht
weiter auf diesen Teil eingehen.

