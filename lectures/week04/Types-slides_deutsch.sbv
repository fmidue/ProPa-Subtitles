0:00:01.370,0:00:06.620
Zunächst einmal muss ich
mich ein wenig korrigieren:

0:00:06.620,0:00:15.370
Ich habe im vorigen Video gesagt, dass ich
die letzte Vorlesungswoche mit der Folie zum Verschieben

0:00:15.370,0:00:22.420
von if-then-else-Ausdrücken in und
aus Funktionsargumentpositionen abgeschlossen habe.

0:00:22.420,0:00:23.610
Das war
eigentlich nicht richtig.

0:00:23.610,0:00:27.420
Das war Folie 47, während die Vorlesung
der letzten Woche mit Folie 52 endete.

0:00:27.420,0:00:33.340
Es gab also noch etwas anderes Material
danach, nämlich über die Syntax zu sprechen.

0:00:33.340,0:00:42.210
Davon abgesehen möchte ich hier noch
eine weitere Beobachtung aus den Übungen machen.

0:00:42.210,0:00:49.039
Eigentlich ist das nicht genau aus den
diesjährigen Übungsaufgaben, sondern aus einer Aufgabe, die dem

0:00:49.039,0:00:52.170
Beispiel "bewegte Sonne"
vom letzten Jahr ähnelt.

0:00:52.170,0:00:55.699
Es gab eine Beobachtung, die ich hier noch
einmal machen möchte, auch wenn es nicht genau das

0:00:55.699,0:01:01.660
Beispiel ist, das in
den diesjährigen Übungen verwendet wurde.

0:01:01.660,0:01:04.680
Es geht
um gemeinsame Unterausdrücke.

0:01:04.680,0:01:08.571
So taucht es hier im Fall eines
if-then-else auf, aber das ist nicht der Hauptpunkt.

0:01:08.571,0:01:11.550
Es geht
um gemeinsame Unterausdrücke.

0:01:11.550,0:01:19.870
Auch Marcellus und Oliver haben darüber in
ihren Videos gesprochen, über das Verschieben von

0:01:19.870,0:01:25.390
Ausdrücken, die wiederholt vorkommen,
in irgendwie benannte Entitäten.

0:01:25.390,0:01:29.530
Und das wurde dort für das Gras,
für die Sonne, für Äste usw. verwendet.

0:01:29.530,0:01:32.130
Also im Grunde
für konstante Ausdrücke.

0:01:32.130,0:01:37.630
Aber das Konzept der Eliminierung gemeinsamer Unterausdrücke
gilt auch für Ausdrücke, die Variablen enthalten.

0:01:37.630,0:01:39.570
Und das wird
hier sehr schön illustriert.

0:01:39.570,0:01:41.240
Betrachten wir
dieses Beispiel.

0:01:41.240,0:01:45.910
Es gab eine "scene"-Berechnung und irgendwie hatte sie
etwas mit Rotation oder dem Verschieben von Dingen

0:01:45.910,0:01:46.910
zu
tun.

0:01:46.910,0:01:58.210
Es gab also eine Bedingung: wenn 8 * sin t
> 0, dann mache etwas (wobei sin und cos verwendet

0:01:58.210,0:02:00.010
werden), und sonst
mache etwas anderes.

0:02:00.010,0:02:01.810
Das ist aber
nicht wirklich wichtig.

0:02:01.810,0:02:03.220
Vielleicht war
das hier "blank".

0:02:03.220,0:02:04.400
Vielleicht auch
etwas anderes.

0:02:04.400,0:02:07.930
Wichtig ist, dass hier
eine Neuberechnung stattgefunden hat.

0:02:07.930,0:02:13.489
Also wird dieser Wert hier berechnet, und dann,
zumindest wenn er positiv ist, wird der "then"-Zweig

0:02:13.489,0:02:16.150
genommen, und es
wird wieder berechnet.

0:02:16.150,0:02:19.430
Es ist keine
sehr teure Berechnung.

0:02:19.430,0:02:24.780
Ja, nur den Sinus zu berechnen, ist vielleicht
nicht der problematischste Fall, aber es wäre sowohl

0:02:24.780,0:02:29.769
effizienter als auch klarer zu sagen:
Lasst uns diesen Dingen Namen geben.

0:02:29.769,0:02:35.849
Wir können einfach Dinge benennen, die keine
anderen Variablen enthalten, aber wir können natürlich auch

0:02:35.849,0:02:40.420
die Unterausdrücke "8 * cos t"
und "8 * sin t" benennen.

0:02:40.420,0:02:44.959
Und dann wird es klarer, denn dann können
wir sehen, dass wir tatsächlich prüfen, ob die y-Koordinate

0:02:44.959,0:02:52.249
größer als null ist, dann verschieben wir das, was
wir hier hatten, an die x- und y-Position, ansonsten

0:02:52.249,0:02:53.349
machen wir
etwas anderes.

0:02:53.349,0:02:58.060
Das ist also sowohl klarer (die
zweite Version), als auch etwas effizienter.

0:02:58.060,0:03:06.390
Denn wir berechnen nicht
zweimal denselben mathematischen Ausdruck.

0:03:06.390,0:03:10.920
Es gibt eine Befürchtung, die manchmal an dieser
Stelle auftaucht, vielleicht auch der Grund, warum der Student,

0:03:10.920,0:03:17.569
der diesen Code ursprünglich geschrieben hatte,
diese Umbenennung nicht vorgenommen hat, nämlich dass

0:03:17.569,0:03:23.219
wir im "else"-Zweig vielleicht den
Kosinus (den x-Wert) nicht brauchen.

0:03:23.219,0:03:27.180
Also, hier sagen wir: Wenn diese Bedingung wahr
ist, dann berechnen wir das, und dann müssen wir

0:03:27.180,0:03:28.920
das ein
zweites Mal berechnen.

0:03:28.920,0:03:31.840
Aber wenn diese Bedingung falsch ist,
dann gehen wir in den "else"-Zweig.

0:03:31.840,0:03:34.900
Und vielleicht haben wir im "else"-Zweig
nicht den Kosinus oder den Sinus.

0:03:34.900,0:03:36.569
Vielleicht ist der
"else"-Zweig wirklich "blank".

0:03:36.569,0:03:41.529
Dann könnte man argumentieren, dass wir hier zwar das
x und das y berechnen, und dann prüfen, ob

0:03:41.529,0:03:46.139
das y positiv ist (wenn ja, dann verwenden wir
natürlich das x und das y), und ansonsten tun wir

0:03:46.139,0:03:50.540
nichts (wir haben das "blank"); warum
haben wir dann die Berechnung von x?

0:03:50.540,0:03:54.939
Das ist eine Sorge, die Studierende
an dieser Stelle haben könnten oder hatten.

0:03:54.939,0:03:57.669
Und nun, diese
Sorge ist unbegründet.

0:03:57.669,0:03:58.669

Warum?

0:03:58.669,0:03:59.709
Weil wir uns nicht
in einer imperativen Sprache befinden.

0:03:59.709,0:04:03.349
Es ist also gar nicht wahr, dass
wir an dieser Stelle x und y berechnen.

0:04:03.349,0:04:04.530
Es handelt sich
nicht um eine Variablenzuweisung.

0:04:04.530,0:04:09.590
Es ist nicht so, dass Sie durch dieses
Stück Code gehen und diesen Wert berechnen, ihn

0:04:09.590,0:04:15.620
x zuweisen, diesen Wert berechnen, ihn y zuweisen,
die Prüfung durchführen, und wenn wir im "else"-Zweig landen

0:04:15.620,0:04:21.430
und ein "blank" haben, dann
haben wir das x umsonst berechnet.

0:04:21.430,0:04:25.949
Das ist nicht das, was hier passiert, denn
dies ist kein sequentieller Code, mit dem wir

0:04:25.949,0:04:27.949
dies und das
und das berechnen.

0:04:27.949,0:04:29.520
Das sind
nur mathematische Definitionen.

0:04:29.520,0:04:37.919
Das heißt also, dass x, wenn
Sie es später brauchen, mit diesem Ausdruck

0:04:37.919,0:04:39.840
ausgewertet
wird.

0:04:39.840,0:04:46.199
Es wird also noch gar nicht das x berechnet, sondern
nur deklariert: Wenn x zu irgendeinem Zeitpunkt relevant ist, dann

0:04:46.199,0:04:48.850
ist das der Wert,
den es annehmen würde.

0:04:48.850,0:04:49.850
Und das Gleiche
gilt für y.

0:04:49.850,0:04:52.250
Dann prüfen wir
natürlich das y.

0:04:52.250,0:04:56.340
Das y wird in der Tat berechnet, aber es
wird nicht zu diesem Zeitpunkt berechnet, wenn es deklariert wird.

0:04:56.340,0:04:57.930
Es wird berechnet,
wenn diese Prüfung stattfindet.

0:04:57.930,0:05:01.590
Und natürlich brauchen wir den Wert von
y, um diesen Vergleich durchführen zu können.

0:05:01.590,0:05:05.280
Also wird y berechnet,
wenn wir diese Prüfung durchführen.

0:05:05.280,0:05:08.840
Wenn diese Prüfung positiv ist, dann werden wir
das tun, und dann brauchen wir natürlich das

0:05:08.840,0:05:09.840
x.

0:05:09.840,0:05:10.919
Und dann würde
das x berechnet werden.

0:05:10.919,0:05:16.470
Dann wird hier also
der cos t berechnet.

0:05:16.470,0:05:21.110
Wenn aber das y nicht
positiv ist, landen wir im "else"-Zweig.

0:05:21.110,0:05:23.030
Der "else"-Zweig ist
zum Beispiel "leer".

0:05:23.030,0:05:25.240
Es wird also
nicht einmal x erwähnt.

0:05:25.240,0:05:27.990
Dann wird x
nie berechnet werden.

0:05:27.990,0:05:33.070
Man muss sich also vom sequenziellen Denken
befreien, wo man, wenn man das sieht, denkt:

0:05:33.070,0:05:38.180
Jetzt berechne ich das teure x, und jetzt berechne
ich das teure y, und dann mache ich etwas mit

0:05:38.180,0:05:39.180
diesen
Werten.

0:05:39.180,0:05:42.440
Das ist nicht das, was hier
passiert, denn das ist kein sequentieller Code.

0:05:42.440,0:05:45.930
Es sind
mathematische Deklarationen.

0:05:45.930,0:05:51.639
Und wenn das x nicht benötigt wird, weil
wir im "else"-Zweig "blank" haben, dann wird das

0:05:51.639,0:05:58.650
x nie
berechnet werden.

0:05:58.650,0:06:00.310
Lassen Sie uns ein
wenig über Typen sprechen.

0:06:00.310,0:06:03.110
Und zunächst
einmal über Zahlentypen.

0:06:03.110,0:06:07.940
Das ist auch etwas, was
jetzt vermehrt in den Übungen auftaucht.

0:06:07.940,0:06:11.889
In den ersten Beispielen in CodeWorld ging
es natürlich um Doubles, weil das die

0:06:11.889,0:06:15.520
Einheit ist, in der
in CodeWorld gemessen wird.

0:06:15.520,0:06:22.099
Dann, in der letzten Übungsaufgabe, über die
Liste der natürlichen Zahlen, gab es schon

0:06:22.099,0:06:25.930
diesen 'Integer' Typ
für nicht-gebrochene Werte (Ganzzahlen).

0:06:25.930,0:06:32.389
Und tatsächlich haben einige Studierende in
dieser Übung bereits Fließkomma- und Ganzzahl-Typen gemischt.

0:06:32.389,0:06:33.389
Das war
nicht nötig.

0:06:33.389,0:06:36.050
Es gab eine Möglichkeit, dies
nur mit ganzen Zahlen zu berechnen.

0:06:36.050,0:06:41.130
Aber einige Studierende versuchten, die Konvertierung zu verwenden,
um die Anzahl der Ziffern einer Zahl zu ermitteln.

0:06:41.130,0:06:43.970
Anstatt mit Division und Rundung
von Werten etc. zu arbeiten.

0:06:43.970,0:06:51.490
Sie haben also bereits mit Funktionen
gearbeitet, die zwischen Fließkomma- und Ganzzahlwerten wechseln.

0:06:51.490,0:06:56.320
Sie werden an manchen Stellen
beides brauchen und auch deren Zusammenspiel.

0:06:56.320,0:06:58.020
Wir müssen
also darüber sprechen.

0:06:58.020,0:07:02.909
Und es dient auch als erster Einblick
in einige Aspekte der Typen in Haskell, anders

0:07:02.909,0:07:06.070
als das, was Sie
bisher an Funktionstypen gesehen haben.

0:07:06.070,0:07:09.990
Zunächst einmal, von außen
betrachtet, hat Haskell verschiedene Zahlentypen.

0:07:09.990,0:07:14.569
Wie in den meisten Programmiersprachen
gibt es Integer-Typen unterschiedlicher Größe und

0:07:14.569,0:07:17.150
es gibt
Fließkomma-Typen unterschiedlicher Größe.

0:07:17.150,0:07:18.949
Sie sehen hier
also Float und Double.

0:07:18.949,0:07:26.270
Die entsprechen in etwa dem, was Sie
in anderen Sprachen mit diesen Typnamen finden.

0:07:26.270,0:07:29.300
Der Typ 'Rational' ist vielleicht nicht
so häufig in anderen Sprachen zu finden.

0:07:29.300,0:07:33.319
Es ist eigentlich ein Typ
der rationalen Zahlen mit beliebiger Genauigkeit.

0:07:33.319,0:07:35.169
Dies sind
keine Fließkommazahlen.

0:07:35.169,0:07:39.009
Eigentlich ist jede rationale Zahl
exakt in diesem Typ darstellbar.

0:07:39.009,0:07:43.930
Es gibt also keinen Präzisionsverlust,
wenn man z.B. rationale Zahlen addiert.

0:07:43.930,0:07:47.759
Und auch bei den ganzen Zahlen gibt
es diese interessante Unterscheidung zwischen Int und Integer.

0:07:47.759,0:07:52.729
Und die Art, wie man darüber nachdenkt, ist,
dass Int im Grunde die Maschinen-Ganzzahl ist, also

0:07:52.729,0:07:56.190
etwas, das eine feste Bitlänge
wie 32 oder 64 Bit hat.

0:07:56.190,0:08:04.270
Es gibt also einen endlichen Bereich von
Integer-Zahlen, die in Int dargestellt werden können.

0:08:04.270,0:08:06.650
Integer hingegen ist
der mathematische 'Integer' Typ.

0:08:06.650,0:08:12.360
Das sind also wirklich beliebig große
Integer-Zahlen, mit einer beliebigen Anzahl von Stellen

0:08:12.360,0:08:15.939
und ohne
Verlust an Genauigkeit.

0:08:15.939,0:08:18.889
Wir haben also
diese verschiedenen Typen.

0:08:18.889,0:08:24.759
Und natürlich können wir unsere Literalzahlen mit
verschiedenen Typen verwenden, genau wie in anderen Sprachen.

0:08:24.759,0:08:31.760
So kann die Zahl Drei, einfach eine Konstante, die
mit 3 geschrieben wird, ein Int, ein Float, ein

0:08:31.760,0:08:34.580
Integer oder ein Rational
sein, oder viele andere Typen.

0:08:34.580,0:08:39.070
Man sieht also bei einer Zahl
nicht, wie gegeben, welcher Typ sie ist.

0:08:39.070,0:08:41.310
Das ist im
Grunde polymorph oder überladen.

0:08:41.310,0:08:45.880
Es gibt auch Konstanten,
die nicht alle Zahlentypen haben.

0:08:45.880,0:08:51.050
Wenn Sie also 3.5 schreiben, dann weiß der Compiler
(und auch wir), dass es weder ein Int noch ein

0:08:51.050,0:08:52.050
Integer
ist.

0:08:52.050,0:08:55.889
3.5 könnte also z.B. ein Float
oder ein Double sein, aber kein Integer.

0:08:55.889,0:08:58.630
Dagegen kann 3 sowohl ein
Integer als auch ein Float sein.

0:08:58.630,0:09:03.570
Das ist auch in
anderen Sprachen eine gängige Praxis.

0:09:03.570,0:09:07.510
Außerdem gibt es, wie
in gewissem Sinne erwartet, Konvertierungsfunktionen.

0:09:07.510,0:09:13.500
Aber wir werden auf der nächsten Folie sehen,
dass sie in manchen Situationen eine etwas andere Rolle

0:09:13.500,0:09:14.500
spielen.

0:09:14.500,0:09:19.730
Aber wenn wir zwischen einigen dieser Zahlentypen
konvertieren müssen, dann können wir das tun.

0:09:19.730,0:09:23.740
Es gibt also Konvertierungsfunktionen,
die nicht an Präzision verlieren.

0:09:23.740,0:09:30.839
Das sind Funktionen, die von Int nach
Integer oder anderen Nicht-Fließkomma-Typen zu einem beliebigen Zahlentyp

0:09:30.839,0:09:31.839

gehen.

0:09:31.839,0:09:35.350
Wenn Sie z.B. von Maschinen-Integer zu
diesem 'Integer' Typ mit beliebiger Genauigkeit gehen wollen,

0:09:35.350,0:09:37.230
dann können Sie
die Funktion "fromIntegral" verwenden.

0:09:37.230,0:09:39.851
Es heißt nicht
"fromInteger" oder so ähnlich.

0:09:39.851,0:09:40.993
Das ist etwas,
was Studierende manchmal verwechseln.

0:09:40.993,0:09:47.370
Denn es gibt auch ältere Versionen von Haskell, in
denen es zwar noch existiert, aber nicht wirklich benutzt

0:09:47.370,0:09:49.110
wird, bzw.
größtenteils veraltet ist.

0:09:49.110,0:09:52.840
Es gibt
auch eine fromInteger-Funktion.

0:09:52.840,0:09:53.930
Die sollten Sie
aber nicht verwenden.

0:09:53.930,0:09:57.370
Sie sollten
die fromIntegral-Funktion verwenden.

0:09:57.370,0:09:58.380
Sie hat
viele verschiedene Typen.

0:09:58.380,0:09:59.700
Sie ist
auch überladen.

0:09:59.700,0:10:05.790
Sie kann also einen Int in einen Integer, einen Integer
in einen Int, einen Int in eine Rationale und einen Int

0:10:05.790,0:10:09.029
in eine Fließkommazahl/Rationale/Double konvertieren,
wie ich bereits erwähnt habe.

0:10:09.029,0:10:15.670
Es handelt sich also im Grunde um Konvertierungen von
einem 'Integer' Typ in einen anderen Zahlentyp, unabhängig davon, ob

0:10:15.670,0:10:17.320
dieser Zahlentyp ein
'Integer' Typ ist oder nicht.

0:10:17.320,0:10:18.820
Und hier gibt es
keinen Verlust an Genauigkeit.

0:10:18.820,0:10:21.570
Nun, im Fall von "von Integer zu Int"
gibt es natürlich einen gewissen Verlust an Präzision.

0:10:21.570,0:10:26.850
Den muss es geben,
wegen der eingeschränkten Ausdruckskraft.

0:10:26.850,0:10:31.260
Aber es gibt keinen Präzisionsverlust
in Form von Rundungsfehlern aufgrund

0:10:31.260,0:10:35.560
von Nachkommastellen
oder ähnlichem.

0:10:35.560,0:10:38.970
Denn das geht nur von
Integer und ähnlichen Typen aus.

0:10:38.970,0:10:43.760
In der Gegenrichtung gibt es in gewisser Weise
Funktionen, die wirklich einen Rundungsfehler / eine Rundungsdiskrepanz

0:10:43.760,0:10:46.840
haben.

0:10:46.840,0:10:52.410
Denn wenn Sie 3.5 haben und eine Ganzzahl wollen, dann
müssen Sie auf 3 oder 4 gehen, also müssen Sie

0:10:52.410,0:10:53.560
eine
Änderung vornehmen.

0:10:53.560,0:10:56.670
Sie können aufrunden, Sie
können abrunden, Sie können abschneiden.

0:10:56.670,0:11:00.800
Und im Grunde gibt es für
all diese verschiedenen Modi Funktionen in Haskell.

0:11:00.800,0:11:07.730
So würde "truncate" von 3.5 auf 3
gehen, während "round" von 3.5 auf 4 gehen

0:11:07.730,0:11:08.730
würde, wegen
des Aufrundens.

0:11:08.730,0:11:13.560
Und "ceiling" und "floor" sind ähnlich wie
"truncate", verhalten sich aber unterschiedlich, je nachdem, ob

0:11:13.560,0:11:18.029
sie negative oder
positive Zahlen erhalten.

0:11:18.029,0:11:23.210
Welche Typen haben
diese präzisionsverlierenden Konvertierungsfunktionen?

0:11:23.210,0:11:26.529
Sie können z.B. von einem
Float zu einem Int konvertieren.

0:11:26.529,0:11:30.860
Denn die Eingabe wäre eine Fließkommazahl,
weil wir etwas wie 3.5 haben.

0:11:30.860,0:11:35.420
Das Ergebnis wird, wieder, ein ganzzahliger
Typ wie 'Int' oder 'Integer' sein.

0:11:35.420,0:11:38.550
Denn nachdem Sie "abgeschnitten" ("truncate" angewendet) haben,
haben Sie eine 3 oder eine 4.

0:11:38.550,0:11:41.459
Sie brauchen also
keine Fließkommazahl mehr.

0:11:41.459,0:11:53.010
Sie können mit diesen Funktionen von
diesem zu einem 'Integer' oder 'Int' Typ wechseln.

0:11:53.010,0:11:59.890
Neben den Konstanten, die überladen sind,
sind auch die meisten mathematischen Operatoren

0:11:59.890,0:12:00.890
überladen.

0:12:00.890,0:12:07.070
Denn es wäre sehr umständlich und unpraktisch
(ist aber in manchen Sprachen tatsächlich der Fall),

0:12:07.070,0:12:12.399
dass Sie unterschiedliche mathematische Operatoren
benötigen, je nachdem, ob Sie z.B.

0:12:12.399,0:12:14.540
mit Fließkommazahlen
oder Integer-Zahlen arbeiten.

0:12:14.540,0:12:18.730
Es gibt zwar bestimmte Varianten wie
eine spezielle Funktion für Ganzzahldivision in Haskell,

0:12:18.730,0:12:21.060
aber die meisten
der Operatoren sind überladen.

0:12:21.060,0:12:30.360
Wenn Sie also etwas haben wie f x =
2 × x + 3.5, dann müssen Sie nicht

0:12:30.360,0:12:37.040
irgendwie eine eigene Unterscheidung treffen, ob
3.5 eine Fließkommazahl ist oder eine Integer-Zahl.

0:12:37.040,0:12:41.800
In dem Sinne, dass dies vielleicht eine
Integer-Multiplikation ist, dann aber eine Fließkomma-Addition, sodass

0:12:41.800,0:12:43.709
vielleicht eine
Konvertierung nötig wäre.

0:12:43.709,0:12:46.910
Nein, denn diese
Operatoren sind überladen.

0:12:46.910,0:12:49.529
Sie arbeiten mit
den richtigen Typen.

0:12:49.529,0:12:54.490
In 3 + 4.5 weiß das "+" also,
dass es eine Fließkomma-Addition sein muss, weil wir

0:12:54.490,0:12:55.490
hier eine
Fließkommazahl haben.

0:12:55.490,0:12:59.510
Es weiß auch, dass diese 3, obwohl
sie auch eine Ganzzahl sein könnte, tatsächlich als

0:12:59.510,0:13:02.139
Fließkommazahl 3
genommen wird.

0:13:02.139,0:13:03.990
Und das ist auch
der Grund, warum das funktioniert.

0:13:03.990,0:13:08.360
Und ein passender Typ für f wird
vom Compiler gewählt, wenn Sie so etwas machen.

0:13:08.360,0:13:11.370
Er wird herausfinden, dass das x auch
eine Fließkommazahl sein muss, denn sonst könnten

0:13:11.370,0:13:16.399
Sie es nicht verdoppeln und
dann mit einer Fließkomma-Addition addieren.

0:13:16.399,0:13:22.361
Ähnlich verhält es sich, wenn Sie eine andere
Funktion haben, die f verwendet. Dann wissen wir wiederum

0:13:22.361,0:13:28.399
aus dem, was ich gerade gesagt habe, dass x
(das Argument von f) eine Fließkommazahl sein muss, wegen dieses

0:13:28.399,0:13:29.399
Ausdrucks.

0:13:29.399,0:13:33.600
Und das klappt ganz gut, weil die
4 auch als Fließkommawert angesehen werden kann.

0:13:33.600,0:13:36.839
Dann wird das Ergebnis von
f auch eine Fließkommazahl sein.

0:13:36.839,0:13:41.699
Das g wird also wissen, dass diese
Division eine Fließkomma-Division sein muss, also muss y

0:13:41.699,0:13:42.699
auch eine
Fließkommazahl sein.

0:13:42.699,0:13:48.319
Wenn Sie also so etwas schreiben, dann brauchen
wir nicht zu konvertieren, weil die Sprache sowohl

0:13:48.319,0:13:52.230
die Konstanten als auch
die mathematischen Operationen überlädt.

0:13:52.230,0:13:57.470
Das ist hier der Fall, denn wir
überlassen dem Compiler die Wahl, welche Typen wir

0:13:57.470,0:13:58.470
x und
y zuweisen.

0:13:58.470,0:14:03.769
Wir haben keine Typen für f und g aufgeschrieben
und keine Einschränkungen für x und y gemacht, auch nicht

0:14:03.769,0:14:04.880
für das
Ergebnis dieser Funktionen.

0:14:04.880,0:14:10.000
Der Compiler kann also durch Überladen
geeignete Zahlentypen für x und y wählen.

0:14:10.000,0:14:14.220
In diesem Fall wird er Fließkommatypen wählen,
aufgrund dessen, was ich gerade erklärt habe.

0:14:14.220,0:14:21.079
Wenn wir hingegen explizite Funktionstypen schreiben
und diese auch die Ein- und

0:14:21.079,0:14:27.380
Ausgabetypen einschränken, zum Beispiel auf
Ganzzahlen, dann müssen wir konvertieren.

0:14:27.380,0:14:32.570
Um dies zu verdeutlichen, schauen
wir uns ein ähnliches Beispiel an.

0:14:32.570,0:14:36.800
Schauen wir uns
zunächst das hier an.

0:14:36.800,0:14:40.339
Nehmen wir an, ich möchte, dass f
eine Funktion von Integer nach Float ist.

0:14:40.339,0:14:48.970
Wenn ich dann den gleichen Ausdruck wie
hier verwenden möchte, muss ich tatsächlich sicherstellen, dass

0:14:48.970,0:14:51.589
dieser Wert an dieser
Stelle ein Fließkommawert ist.

0:14:51.589,0:14:54.130
Und das
ist er nicht.

0:14:54.130,0:14:58.250
Wenn ich sage, f geht von Integer
zu Float, dann wäre x ein Integer.

0:14:58.250,0:15:01.860
Um es dann für eine Fließkomma-Multiplikation
zu verwenden, was ich tun muss, weil

0:15:01.860,0:15:06.410
ich anschließend eine Fließkomma-Addition machen will, dann
muss ich dieses x von Int in

0:15:06.410,0:15:07.889
eine
Fließkommazahl umwandeln.

0:15:07.889,0:15:12.029
Und das kann "fromIntegral" tun, denn wie
ich auf der vorherigen Folie sagte, kann dieses

0:15:12.029,0:15:15.110
"fromIntegral" von Typen wie Int oder
Integer zu jedem geeigneten anderen Typ gehen.

0:15:15.110,0:15:16.870
Es könnte also
zu Float gehen.

0:15:16.870,0:15:19.019
Das wird
also funktionieren.

0:15:19.019,0:15:21.550
Und das ist dann
eine Art von Konvertierung.

0:15:21.550,0:15:25.279
Ja, es ist keine syntaktische
Konvertierung, wie sie in C vorkommt.

0:15:25.279,0:15:27.600
Es ist eine Funktion,
die diese Konvertierung durchführt.

0:15:27.600,0:15:33.149
Es ist also nicht irgendwie
ein eingebautes extra syntaktisches Konstrukt.

0:15:33.149,0:15:35.839
Und ähnlich ist es, wenn ich
etwa ein Beispiel wie oben mache:

0:15:35.839,0:15:43.000
Das f x ist also wieder frei in
der Wahl seines Typs, aber irgendwie möchte ich

0:15:43.000,0:15:50.040
in der zweiten Funktion statt des Wertes
4 hier die Länge der Zeichenkette "abcd" haben.

0:15:50.040,0:15:54.850
Nun müsste ich wissen, dass die Längen-Funktion in
Haskell eine Funktion ist, die, in diesem Fall, einen

0:15:54.850,0:15:56.970
String nimmt und
eine natürliche Zahl liefert.

0:15:56.970,0:16:00.680
Sie liefert keine Fließkommazahl, weil "length"
bei einem ganzzahligen Ergebnis mehr Sinn

0:16:00.680,0:16:01.680

macht.

0:16:01.680,0:16:06.690
Wenn ich also so etwas schreibe (ich ersetze
also die 4 durch die Länge von "abcd"), dann

0:16:06.690,0:16:07.690
muss ich wieder konvertieren.

0:16:07.690,0:16:08.690
Und warum?

0:16:08.690,0:16:12.050
Weil hier die 4 keinen Typ hatte,
also hat der Compiler per Überladung entschieden:

0:16:12.050,0:16:14.399
"Also, ich betrachte diese
4 als eine Fließkommazahl".

0:16:14.399,0:16:17.070
Das geht hier nicht, wenn ich
sage, es ist das Ergebnis der length-Funktion.

0:16:17.070,0:16:20.279
Die length-Funktion gibt immer
eine ganze Zahl zurück.

0:16:20.279,0:16:25.220
Wenn ich sie dann als Argument für f
verwenden will, und der Compiler hat für f aufgrund

0:16:25.220,0:16:30.810
dieses Zusatzes hier abgeleitet, dass das
Argument eine Fließkommazahl sein muss, dann muss

0:16:30.810,0:16:35.029
ich dafür sorgen, dass ich meine Ganzzahl
(die aus der length-Funktion kommt) in diesen

0:16:35.029,0:16:36.029
Fließkomma-Typ
einbette.

0:16:36.029,0:16:37.889
Und das kann ich
wiederum mit "fromIntegral" machen.

0:16:37.889,0:16:42.449
Ich bräuchte hier
also wieder eine Konvertierung.

0:16:42.449,0:16:44.279
An dieser Stelle
fragen nun manchmal Studierende:

0:16:44.279,0:16:48.759
"Warum muss ich hier diese expliziten Konvertierungen
machen, während sie hier irgendwie versteckt sind?

0:16:48.759,0:16:52.600
Vielleicht führt der Compiler
hier stille Konvertierungen ein."

0:16:52.600,0:16:54.380
Aber so sollte
man das nicht sehen.

0:16:54.380,0:16:59.220
Es ist nicht so, dass wir hier
explizite Konvertierungen haben, und hier irgendwie versteckte

0:16:59.220,0:17:00.220
Konvertierungen.

0:17:00.220,0:17:01.220
Nein.

0:17:01.220,0:17:02.220
Was tatsächlich
passiert, ist:

0:17:02.220,0:17:06.130
Hier brauchen wir Konvertierungen,
hier brauchen wir keine Konvertierungen.

0:17:06.130,0:17:07.900
Es gibt also
keine versteckten Konvertierungen.

0:17:07.900,0:17:11.740
Indem wir einfach keine Typen für f und g
angeben, überlassen wir dem Compiler die Wahl der Typen.

0:17:11.740,0:17:15.959
Und der Compiler kann in diesem Fall
die Typen so wählen, dass keine Konvertierungen

0:17:15.959,0:17:16.959
notwendig
sind.

0:17:16.959,0:17:19.319
Denn der Compiler entscheidet einfach,
dass x ein Float ist.

0:17:19.319,0:17:21.970
Dann ist eine
Konvertierung nicht nötig.

0:17:21.970,0:17:25.559
Wenn wir sagen "Nein, das x ist
ein Integer", dann ist eine Konvertierung notwendig.

0:17:25.559,0:17:28.100
Und der Compiler führt die
Konvertierung nicht von sich aus ein.

0:17:28.100,0:17:29.340
Wir müssen
sie schreiben.

0:17:29.340,0:17:42.850
Andernfalls würde sie die Typendisziplin
in Haskell (auch für Zahlentypen) unterlaufen.

0:17:42.850,0:17:47.669
Nur der Vollständigkeit halber: Es gibt
tatsächlich einige Operatoren, die nicht vollständig überladen

0:17:47.669,0:17:48.669

sind.

0:17:48.669,0:17:50.920
Sie sind also nicht
bei allen Typen verfügbar.

0:17:50.920,0:17:52.299
Und die Division
ist eines dieser Beispiele.

0:17:52.299,0:18:01.190
Das Divisionssymbol, wie Sie es wahrscheinlich in
vielen Sprachen zu sehen gewohnt sind, ist bei

0:18:01.190,0:18:03.160
ganzzahligen Typen
nicht verfügbar.

0:18:03.160,0:18:05.450
Es ist eine Operation
im Stil der Fließkommazahlen.

0:18:05.450,0:18:10.770
Sie funktioniert zwar auf den
rationalen Zahlen, aber nicht auf Integer-Typen.

0:18:10.770,0:18:12.170
Was haben
wir stattdessen?

0:18:12.170,0:18:15.000
Wir haben
eine spezielle Divisionsfunktion.

0:18:15.000,0:18:17.960
Dieser Operator "div" ist
auch aus anderen Sprachen bekannt.

0:18:17.960,0:18:23.210
Er operiert auf Int oder
Integer, aber z.B. nicht auf Fließkommazahlen.

0:18:23.210,0:18:27.650
Es ist also wirklich eine andere Operation,
ein anderes Symbol als das Schrägstrich-Symbol für

0:18:27.650,0:18:30.340
die Division
auf Fließkommazahlen.

0:18:30.340,0:18:40.429
Ein netter syntaktischer Trick ist, dass binäre
Funktionen wie "div", aber auch alle nicht-arithmetischen Funktionen,

0:18:40.429,0:18:41.600
wie Operatoren
verwendet werden können.

0:18:41.600,0:18:46.250
Während es also in Haskell keinen Schrägstrich-Operator für
Division gibt, kann diese Funktion als Operator verwendet werden,

0:18:46.250,0:18:50.860
indem man sie einfach infix
und mit diesen Backticks schreibt.

0:18:50.860,0:18:52.539
Aber das ist
nur syntaktischer Zucker.

0:18:52.539,0:18:59.880
Für "17 `div` 3", so geschrieben, weiß der
Compiler also, dass es dasselbe ist, wie die Anwendung

0:18:59.880,0:19:04.620
der binären Funktion "div" auf 17
und 3 als ihre beiden Argumente.

0:19:04.620,0:19:08.980
Es ist nur eine
andere Art, es zu schreiben.

0:19:08.980,0:19:12.580
Es handelt sich nicht um
einen neuen Operator oder Ähnliches.

0:19:12.580,0:19:15.490
Und eine weitere nützliche Sache ist natürlich,
dass es viele weitere mathematische Konstanten und Funktionen

0:19:15.490,0:19:16.490
gibt.

0:19:16.490,0:19:17.490
Einige von ihnen
haben wir bereits gesehen.

0:19:17.490,0:19:18.490
Ich habe die
mathematische Konstante pi verwendet.

0:19:18.490,0:19:19.490
Ich habe
diese Sinusfunktion benutzt.

0:19:19.490,0:19:24.110
Es gibt auch diese Funktion für die
Quadratwurzel; Minimum- und Maximum-Funktionen auf ganzen Zahlen

0:19:24.110,0:19:25.320
und
anderen Typen.

0:19:25.320,0:19:33.919
Es gibt also eine Menge Funktionen und sie haben
die erwarteten Namen, ähnlich wie die mathematischen Bibliotheken in

0:19:33.919,0:19:35.090
anderen
Sprachen.

0:19:35.090,0:19:38.010
Ich werde sie nicht alle vorstellen,
sie werden einfach in Beispielen auftauchen.

0:19:38.010,0:19:44.730
Wenn Sie also einen Bedarf haben, dann schauen
Sie vielleicht in irgendeiner Haskell-Bibliothek oder der Standardbibliothek

0:19:44.730,0:19:47.300
nach, welche Funktion Sie
für einen bestimmten Zweck benötigen.

0:19:47.300,0:19:54.450
Ich werde also keine
vollständige Liste oder Ähnliches geben.

0:19:54.450,0:19:57.909
Das sollte
nicht nötig sein.

0:19:57.909,0:20:04.120
Lassen Sie mich noch im Zusammenhang mit Zahlentypen
eine Beobachtung machen, die auf den Übungen der letzten

0:20:04.120,0:20:05.120
Jahre basiert.

0:20:05.120,0:20:10.620
Also, das ist auch etwas, was
jetzt wahrscheinlich wieder in Übungsaufgaben auftauchen wird.

0:20:10.620,0:20:14.140
Ich erwähnte die
Notwendigkeit der Umrechnung.

0:20:14.140,0:20:19.260
Und die allgemeine Strategie, um damit in
Ihren nächsten Übungsaufgaben umzugehen, in denen Sie vielleicht

0:20:19.260,0:20:25.940
sowohl Integer- als auch Fließkommatypen
antreffen, ist, dass es normalerweise nicht

0:20:25.940,0:20:27.790
schadet, einige
"fromIntegral"-Aufrufe hinzuzufügen.

0:20:27.790,0:20:29.140
Warum ist
das so?

0:20:29.140,0:20:31.510
Sie können viele
verschiedene Typen haben.

0:20:31.510,0:20:34.620
So haben sie unter anderem
Typen wie "Int → Int".

0:20:34.620,0:20:40.250
Wenn Sie also etwas haben, das vielleicht
in einer List Comprehension aus einer Generatorliste zieht,

0:20:40.250,0:20:41.720
0 bis 10
oder so ähnlich:

0:20:41.720,0:20:45.020
Es wäre ein Int, aber vielleicht
müssen Sie es als Double verwenden.

0:20:45.020,0:20:49.590
Dann schadet es nicht, ein "fromIntegral" auf die
Variable zu setzen, die Sie aus dieser "0

0:20:49.590,0:20:50.789
bis
10"-Liste ziehen.

0:20:50.789,0:20:53.830
Denn entweder wird sie als Int verwendet,
und das ist in Ordnung, denn "fromIntegral"

0:20:53.830,0:20:57.900
verwandelt Int in Int (es hat sich nichts geändert),
oder sie wird als Double verwendet, und dann ist

0:20:57.900,0:21:01.290
auch alles in Ordnung, denn Sie
haben diesen "fromIntegral"-Aufruf hinzugefügt, der den Integer

0:21:01.290,0:21:03.470
tatsächlich in einen
Double verwandelt, zum Beispiel.

0:21:03.470,0:21:07.910
In diesem Sinne ist "fromIntegral"
im schlimmsten Fall eine No-Op.

0:21:07.910,0:21:12.460
Es schadet also nicht wirklich, ihn an
bestimmten Stellen hinzuzufügen, insbesondere, wenn Sie Fehlermeldungen

0:21:12.460,0:21:16.500
über Int vs. Double erhalten.

0:21:16.500,0:21:22.549
Auch wenn Sie redundante fromIntegral-Aufrufe hinzufügen, wird
der Compiler / das Autotool Sie eigentlich

0:21:22.549,0:21:23.549
davor
warnen.

0:21:23.549,0:21:25.710
In diesem Sinne
schadet es also nicht.

0:21:25.710,0:21:27.010
Es ist ähnlich
wie mit den Klammern.

0:21:27.010,0:21:32.279
Am Anfang, wenn Sie Haskell-Programme schreiben, neigen Sie
dazu, zu viele Klammern hinzuzufügen. Und vielleicht ist es

0:21:32.279,0:21:36.740
sogar eine gute Strategie, am Anfang ein paar mehr Klammern
hinzuzufügen, nur um auf der sicheren Seite zu sein, und

0:21:36.740,0:21:42.230
dann den Compiler oder das Autotool oder welches Tool
auch immer Sie verwenden, sagen zu lassen, welche Klammern

0:21:42.230,0:21:43.230
redundant
sind.

0:21:43.230,0:21:47.919
In ähnlicher Weise könnten Sie dieses fromIntegral verwenden, es
dort hinzufügen, wo Sie den Verdacht haben, dass Sie

0:21:47.919,0:21:53.770
es brauchen könnten, und wenn sich in Ihrem endgültigen
Programm herausstellt, dass es nicht benötigt wird, dann können Sie

0:21:53.770,0:21:58.580
sich vom Compiler oder Autotool sagen lassen,
wo Sie einige dieser "fromIntegral"-Aufrufe wieder entfernen können.

0:21:58.580,0:22:01.650
Das ist dann
eine sichere Strategie.

0:22:01.650,0:22:04.110
Das war
die eine Bemerkung.

0:22:04.110,0:22:09.870
Eine andere Bemerkung gilt generell für alle Funktionen,
aber speziell (wegen dieser ganzen Konvertierungsprobleme) für Typen,

0:22:09.870,0:22:13.090
die mit Zahlen
zu tun haben.

0:22:13.090,0:22:18.789
Es ist gute Praxis und wirklich
hilfreich, die Typsignatur zumindest für die Top-Level-Funktionen

0:22:18.789,0:22:19.789
aufzuschreiben.

0:22:19.789,0:22:24.530
Das hat Vorteile, wie z.B. dass der Compiler besser
in der Lage ist, Ihnen bei Typfehlern zu helfen.

0:22:24.530,0:22:29.419
Aber unter anderem erspart es Ihnen
auch den Umgang mit bestimmten kompliziert aussehenden

0:22:29.419,0:22:30.460
Typen wie
dem hier.

0:22:30.460,0:22:36.651
Wenn Sie also eine Funktion auf Zahlen schreiben, und Sie
nicht sagen "Ich möchte, dass dies eine Funktion von Float nach

0:22:36.651,0:22:37.651
Float
ist",

0:22:37.651,0:22:40.140
dann wird der
Compiler irgendeinen Typ ableiten.

0:22:40.140,0:22:46.360
Er könnte etwas ableiten, das abschreckend
aussieht wie dieses "Floating a" und "Ord a",

0:22:46.360,0:22:51.880
und dann diesen seltsamen Pfeil, der
kein Funktionspfeil ist, und dann "a → a".

0:22:51.880,0:22:56.230
Es wird im Moment nicht
erwartet, dass Sie das verstehen.

0:22:56.230,0:23:01.000
Wenn Sie eine Ahnung davon haben wollen, was hier
passiert: Es ist etwas ähnlich wie bei Java-Interfaces,

0:23:01.000,0:23:10.320
wo "Floating" und "Ord" im Grunde genommen komplett abstrakte Klassen
sind (in Java würde man sie mittels

0:23:10.320,0:23:11.700
"interface" deklarieren).

0:23:11.700,0:23:13.940
Aber das brauchen Sie
an dieser Stelle nicht.

0:23:13.940,0:23:20.470
Und Sie können solche Konzepte in
Haskell vermeiden, indem Sie expliziter sind.

0:23:20.470,0:23:25.409
Wenn Sie also aufschreiben, dass Ihr "fun" eine
Funktion von Int nach Int ist, dann wird Ihnen

0:23:25.409,0:23:26.520
der
Compiler glauben.

0:23:26.520,0:23:31.030
Nun, er wird Ihnen nicht
einfach glauben, er wird es überprüfen.

0:23:31.030,0:23:37.150
Und Sie müssen sich nicht auf die Inferenz
verlassen, die zu so kompliziert aussehenden Typen führen kann.

0:23:37.150,0:23:40.030
Dies ist also ein
Kommentar speziell zu Zahlentypen.

0:23:40.030,0:23:44.210
Aber auch ganz allgemein sollten
zumindest Top-Level-Funktionen in Ihren Übungsvorlagen mit

0:23:44.210,0:23:45.230
Typsignaturen
versehen werden.

0:23:45.230,0:23:49.309
Sie müssen das nicht für alle lokalen Definitionen
tun, wie ich es im Beispiel vorhin mit den

0:23:49.309,0:23:52.770
lokalen Funktionen x
und y getan habe.

0:23:52.770,0:23:56.779
Sie müssen nicht alle Typsignaturen für solche
Dinge schreiben, aber für Funktionen der obersten Ebene

0:23:56.779,0:24:05.160
sollten Sie
es lieber tun.

0:24:05.160,0:24:06.870
Natürlich gibt es
nicht nur Zahlentypen.

0:24:06.870,0:24:09.960
Es gibt alle Arten
von Typen in Haskell.

0:24:09.960,0:24:17.520
Und ich werde auf dieser Folie einige
Grundtypen durchsprechen und wahrscheinlich anschließend ein kleines

0:24:17.520,0:24:24.429
Video mit dem Whiteboard machen, um
einige Beispielwerte, insbesondere für zusammengesetzte Typen,

0:24:24.429,0:24:25.429

anzuschauen.

0:24:25.429,0:24:29.440
Gehen wir also schnell die bereits
existierenden Typen durch, abgesehen von Zahlen.

0:24:29.440,0:24:32.030
Es gibt also einen
Typ von Booleschen Werten.

0:24:32.030,0:24:35.180
Und eigentlich sind die einzigen
Bewohner dieses Typs "True" und "False".

0:24:35.180,0:24:40.500
Und auf diesen Werten haben Sie Operatoren
wie "&&" (und), "||" (oder), "not" (nicht).

0:24:40.500,0:24:42.830
Also, die logischen Operatoren
auf dem Booleschen Typ.

0:24:42.830,0:24:43.980
Es ist wirklich
ein eigener Typ.

0:24:43.980,0:24:49.830
Es ist nicht wie in C, wo irgendwie 0
und 1 eines Integer-Typs auch als Boolesche Werte fungieren.

0:24:49.830,0:24:54.690
Das ist wirklich ein eigener Typ:
True und False, und Operatoren darauf.

0:24:54.690,0:25:00.370
Und natürlich ist dieser Typ eigentlich auch der
Typ von Bedingungen, die Sie in "if-then-else" verwenden.

0:25:00.370,0:25:03.770
Die Bedingung muss etwas sein,
das zu einem "Bool" ausgewertet wird.

0:25:03.770,0:25:08.000
Und natürlich können Sie diese Booleschen
Operatoren auch an diesen Stellen verwenden.

0:25:08.000,0:25:11.480
Das ist also
die eine Sache.

0:25:11.480,0:25:14.290
Und dann gibt es
noch einen Typ von Zeichenwerten.

0:25:14.290,0:25:16.570
Er wird "Char" genannt.

0:25:16.570,0:25:25.919
Er hat die erwarteten Werte, wie alle
Buchstaben, die Sie haben können, auch Sonderzeichen

0:25:25.919,0:25:27.870
wie "eine neue Zeile" ('\n'), usw.

0:25:27.870,0:25:37.270
Es gibt Operationen wie das Vorwärts- oder
Rückwärtsbewegen in der ASCII-Tabelle, in gewisser Weise.

0:25:37.270,0:25:42.120
Der Nachfolger von 'a' ist 'b', und
der Vorgänger von 'b' als Zeichen ist 'a'.

0:25:42.120,0:25:47.340
Sie können Zeichen auch mit den
üblichen Vergleichsoperationen vergleichen, die Sie auch auf

0:25:47.340,0:25:48.340
Zahlen
anwenden würden.

0:25:48.340,0:25:49.340
Diese sind
also ebenfalls überladen.

0:25:49.340,0:25:53.669
Noch interessanter ist
die Konstruktion von Listentypen.

0:25:53.669,0:25:58.020
Wir haben schon einige Listen gesehen, nämlich
bei den List Comprehensions: Listen von Bildern.

0:25:58.020,0:26:01.809
Aber diese Konstruktion
kann beliebig verwendet werden.

0:26:01.809,0:26:03.010
Sie können also eine
Liste von irgendetwas haben.

0:26:03.010,0:26:04.070
Sie können eine
Liste von Integern haben.

0:26:04.070,0:26:05.200
Sie können eine
Liste von Bools haben.

0:26:05.200,0:26:07.890
Sie können eine Liste von
Listen mit ganzen Zahlen haben.

0:26:07.890,0:26:10.110
Und es gibt
viele vordefinierte Funktionen.

0:26:10.110,0:26:14.990
Sie werden einige davon später
sehen, oder vielleicht nächste Woche.

0:26:14.990,0:26:23.230
Aber wie auch immer, es gibt eine Menge verfügbarer Maschinerie, um
mit Listen zu arbeiten, wie etwa die List Comprehensions, aber

0:26:23.230,0:26:26.010
auch die Definition
von Funktionen und Operatoren.

0:26:26.010,0:26:30.470
So haben Sie zum Beispiel die Funktion "reverse",
die eine Liste nimmt und die Reihenfolge umkehrt.

0:26:30.470,0:26:36.380
Oder Funktionen, um bestimmte Teile einer Liste auszuwählen,
einen Präfix oder Suffix, oder was auch immer.

0:26:36.380,0:26:38.560
Und: Listen
sind homogen.

0:26:38.560,0:26:43.170
Wenn Sie also eine Liste von Ints (ganzen Zahlen) haben,
dann können Sie in dieser Liste nur Int (ganze Zahlen)

0:26:43.170,0:26:44.170
haben.

0:26:44.170,0:26:47.610
Man kann keine Liste haben, in der einige
der Werte Integer sind und einige davon Boolesche Werte

0:26:47.610,0:26:48.610
sind.

0:26:48.610,0:26:49.640
Sie haben einen
Typ von Integer (Int)-Listen.

0:26:49.640,0:26:51.429
Sie haben einen
Typ von Boolean (Bool)-Listen.

0:26:51.429,0:26:55.520
Aber Sie haben keinen Typ von "einige dieser
Werte sind Ganzzahlen und einige sind Boolesche Werte".

0:26:55.520,0:26:59.390
Dieser muss
also homogen sein.

0:26:59.390,0:27:05.370
Dann gibt es einen Typ von Zeichenfolgen,
und der heißt wie in anderen Sprachen 'String'.

0:27:05.370,0:27:07.919
Aber es ist
eine Liste von Zeichen.

0:27:07.919,0:27:14.590
Ja, wir können eine spezielle Notation schreiben ("abc"),
aber was es unter der Haube wirklich ist, ist

0:27:14.590,0:27:19.539
eine normale Liste, bei der
der Elementtyp der Zeichentyp (Char) ist.

0:27:19.539,0:27:23.260
Also ist "abc" eigentlich die Liste
dieser drei Zeichen 'a', 'b' und 'c'.

0:27:23.260,0:27:27.890
So etwas wie die eben erwähnte
reverse-Funktion ist also auch auf Strings anwendbar,

0:27:27.890,0:27:29.480
weil Strings auch
nur Listen sind.

0:27:29.480,0:27:34.220
Es ist nur zufällig der Fall, dass
es sich um eine Liste von Zeichen handelt.

0:27:34.220,0:27:42.679
Wichtig in diesem Zusammenhang ist, dass in
CodeWorld dieser 'String' Typ nicht direkt verwendet wird.

0:27:42.679,0:27:44.730
Also verwendet CodeWorld
einen eigenen 'Text' Typ.

0:27:44.730,0:27:45.730
Er wird
'Text' genannt.

0:27:45.730,0:27:47.170
Er ist sehr
ähnlich zu String.

0:27:47.170,0:27:53.360
Und Sie können auch diese Notation verwenden,
aber Sie müssen auch die Funktion "pack" verwenden.

0:27:53.360,0:27:56.870
Und wenn Sie sich die Beispiele oder die Vorlagen
für die letzte Übung, die wir gegeben haben, angesehen

0:27:56.870,0:27:58.070
haben, können Sie
das in Aktion sehen.

0:27:58.070,0:28:02.929
Wenn Sie also Zeichenketten oder Zeichenfolgen in
CodeWorld verwenden wollen, dann machen Sie es

0:28:02.929,0:28:07.440
so, wie es in
der letzten Übungswoche gemacht wurde.

0:28:07.440,0:28:12.980
Verwenden Sie von dort aus
die Beispiele, wie das gemacht wird.

0:28:12.980,0:28:19.960
Und dann gibt es noch eine weitere Möglichkeit,
Werte in einer komplexeren Struktur zu kombinieren oder anzuordnen.

0:28:19.960,0:28:22.049
Neben Listen gibt
es auch Tupel-Typen.

0:28:22.049,0:28:26.630
Der Unterschied bei ihnen ist, dass
sie zum einen nicht homogen sein müssen.

0:28:26.630,0:28:31.040
Sie können also ein Paar von Integern oder
ein Tripel von Integern, Strings und Booleans haben.

0:28:31.040,0:28:34.800
Es muss also nicht homogen
sein, aber mit einer festen Länge.

0:28:34.800,0:28:39.080
Wenn Sie einen Tripel-Typ haben, dann
müssen alle Werte des Typs Tripel sein.

0:28:39.080,0:28:44.100
Sie können nicht, wie z.B. bei einem
Listentyp, mehrere Listen mit unterschiedlicher Länge haben.

0:28:44.100,0:28:49.260
Listentypen sind also homogen und
ein Listenwert kann beliebig lang sein.

0:28:49.260,0:28:57.350
Tupel-Typen sind nicht homogen: Sie können
Tripel verschiedener Typen als Bestandteile haben,

0:28:57.350,0:29:00.429
aber jedes Element dieses
Typs muss ein Tripel sein.

0:29:00.429,0:29:05.450
Sie können keinen Typ haben, der
z.B. einige Paare und einige Tripel enthält.

0:29:05.450,0:29:07.970
Und alle diese
Konstrukte können kombiniert werden.

0:29:07.970,0:29:13.700
Sie können also Listen von Paaren, Paare von
Listen, Listen von Paaren von Listen und Paaren haben.

0:29:13.700,0:29:17.419
Sie können Basistypen
an allen Stellen verschachteln.

0:29:17.419,0:29:22.540
Und natürlich können sie später, wenn wir
eigene Datentypen definieren, auch in Listen und Tupeln

0:29:22.540,0:29:23.950
usw.
verwendet werden.

0:29:23.950,0:29:34.179
Es gibt also einen kombinatorischen Bereich von
Typkonstruktoren und man kann sie auf viele verschiedene

0:29:34.179,0:29:35.179
Arten kombinieren.

0:29:35.179,0:29:40.299
Und schon mit den grundlegenden Dingen, die Sie auf
dieser Folie sehen, haben Sie eine ganze Reihe von

0:29:40.299,0:29:42.539
Möglichkeiten, Ihre
Daten anzuordnen.

0:29:42.539,0:29:49.940
Und um das zu veranschaulichen, werde ich einige
Werte einiger dieser Typen in einem separaten Whiteboard-Video

0:29:49.940,0:29:50.440
zeigen.
