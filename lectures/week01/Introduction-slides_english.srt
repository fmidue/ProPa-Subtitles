2 # slide
00:00:18,810 --> 00:00:24,470
I will now talk about motivation for this
course, what Programming Paradigms is all

00:00:24,470 --> 00:00:29,590
about, and what we will focus on specifically,
this year as in previous years.

00:00:29,590 --> 00:00:32,820
And I will also mention some literature that
you might want to use.

00:00:32,820 --> 00:00:38,760
At first, I want to show a few results of
the Moodle survey we ran in 2019.

00:00:38,760 --> 00:00:43,540
You probably have already seen or taken part
in the current Moodle survey.

00:00:43,540 --> 00:00:50,260
But since the results from that are not yet
complete, I instead will show and talk a bit

00:00:50,260 --> 00:00:52,020
about a few results from 2019.

00:00:52,020 --> 00:00:57,860
And I think that some of the aspects will
be similar in your answers, once they are

00:00:57,860 --> 00:01:01,290
completed for the current course.

3 # slide
00:01:01,290 --> 00:01:07,479
One question that we asked is about what language
was used when students took the "Grundlegende

00:01:07,479 --> 00:01:08,530
Programmiertechniken" course.

00:01:08,530 --> 00:01:14,080
So, this is a question that only makes sense
for the "Angewandte Informatik" students,

00:01:14,080 --> 00:01:17,570
because it doesn't really apply to the ISE
students.

00:01:17,570 --> 00:01:23,490
This question is relevant for us, since at
some places in the course I will make comparisons

00:01:23,490 --> 00:01:28,630
between language constructs of new languages
that you are going to learn, and languages

00:01:28,630 --> 00:01:30,990
that we expect you to already know.

00:01:30,990 --> 00:01:40,020
We also know, of course, that the GPT lecture
has switched from teaching Java to teaching

00:01:40,020 --> 00:01:41,310
Python mainly.

00:01:41,310 --> 00:01:46,650
In 2019, as you see here, it was still the
case that two thirds of the students in our

00:01:46,650 --> 00:01:52,190
course had GPT with Java lectures.

00:01:52,190 --> 00:01:57,170
I expect that now this ratio will have changed
somewhat.

00:01:57,170 --> 00:02:02,570
But, also from the first answers in the survey
that we could already see, it's also the case

00:02:02,570 --> 00:02:06,729
that there are still quite a few students
for whom Java was the language that you learned

00:02:06,729 --> 00:02:07,729
in GPT.

00:02:07,729 --> 00:02:10,759
So, actually, we will try to accommodate both.

00:02:10,759 --> 00:02:18,870
We will address such comparisons in such a
way that whether your first or dominant imperative

00:02:18,870 --> 00:02:23,580
programming language is Java or Python, you
should be able to appreciate the comparisons

00:02:23,580 --> 00:02:27,290
that I'm going to make.

4 # slide
00:02:27,290 --> 00:02:33,560
Then we also asked about what language students
feel most proficient in.

00:02:33,560 --> 00:02:39,610
That is, which language they know best or
are most confident using.

00:02:39,610 --> 00:02:41,530
Not all students gave an answer to this.

00:02:41,530 --> 00:02:47,970
But among those that did give an answer, it's
probably not very surprising, given that most

00:02:47,970 --> 00:02:55,120
students learned Java in GPT before, that
again Java was the main mentioned language

00:02:55,120 --> 00:02:56,120
here.

00:02:56,120 --> 00:03:03,340
And also, again of course, there is Python
present, probably often by students who learned

00:03:03,340 --> 00:03:06,730
GPT with Python code.

00:03:06,730 --> 00:03:09,069
But then, there also is C entering the picture.

00:03:09,069 --> 00:03:14,530
And that could be both the ISE students, for
whom C is used in their first programming

00:03:14,530 --> 00:03:15,530
lecture.

00:03:15,530 --> 00:03:19,470
But, this could actually also be students
who learned C at other places, for example,

00:03:19,470 --> 00:03:20,470
at school.

00:03:20,470 --> 00:03:25,379
My son, in 10th grade, was learning C in school
in the Informatik lectures.

00:03:25,379 --> 00:03:29,200
So, that's also a possibility here.

00:03:29,200 --> 00:03:36,480
Anyway, as we see, it's now more than 80%
for these three languages.

00:03:36,480 --> 00:03:40,060
And probably the picture will be similar this
time.

00:03:40,060 --> 00:03:46,159
And even among the languages that were mentioned,
most languages are imperative programming

00:03:46,159 --> 00:03:47,159
languages.

00:03:47,159 --> 00:03:51,940
So, definitely different from the kind of
languages that will be studied in this course.

00:03:51,940 --> 00:03:58,709
Which is, of course, the main point of having
this Programming Paradigms course.

00:03:58,709 --> 00:04:03,170
That you learn something else than what you
already know from your first programming courses

00:04:03,170 --> 00:04:06,140
or from other places.

5 # slide
00:04:06,140 --> 00:04:13,319
Another thing we also asked was whether students
have a favorite programming language, and

00:04:13,319 --> 00:04:14,659
what that is.

00:04:14,659 --> 00:04:18,519
Fewer students gave an answer to this question.

00:04:18,519 --> 00:04:24,910
And as you can see from the last picture,
it becomes a bit more diverse now.

00:04:24,910 --> 00:04:33,349
But, all is quite still very much in favor
of C/Java-like languages or Python.

00:04:33,349 --> 00:04:38,710
About 15 students in 2019 mentioned that they
have some experience with functional programming.

00:04:38,710 --> 00:04:43,490
And a similar number mentioned the same for
logic programming.

00:04:43,490 --> 00:04:48,800
I don't think anybody mentioned a functional
or logic programming language as their favorite

00:04:48,800 --> 00:04:50,750
programming language.

00:04:50,750 --> 00:04:54,000
My aim is not necessarily to change this with
this course.

00:04:54,000 --> 00:04:58,070
But at least, you should learn something new
in addition to things that you do already

00:04:58,070 --> 00:04:59,070
know.

00:04:59,070 --> 00:05:03,349
So, neither Haskell nor Prolog, the two languages
that you will study, have to become your new

00:05:03,349 --> 00:05:04,349
favorite language.

00:05:04,349 --> 00:05:11,039
But at least, you should learn something new
that maybe you can later apply in other languages

00:05:11,039 --> 00:05:15,990
that you're going to use.

6 # slide
00:05:15,990 --> 00:05:21,779
Of course, one could ask at this point, why
do you have to learn another programming language?

00:05:21,779 --> 00:05:25,949
It seems that all of you have learned programming
before.

00:05:25,949 --> 00:05:30,909
And many of you have at least one programming
language that you feel confident in.

00:05:30,909 --> 00:05:32,830
So, why shouldn't this be enough?

00:05:32,830 --> 00:05:36,599
Why do you have to learn more programming
languages?

00:05:36,599 --> 00:05:42,469
Well, at this point, I like to repeat this
quote by a medieval king: "To know another

00:05:42,469 --> 00:05:44,569
language is to have a second soul".

00:05:44,569 --> 00:05:50,830
Of course, given the time when this was said,
it doesn't refer to programming languages.

00:05:50,830 --> 00:05:55,860
So, this refers to natural languages that
people speak.

00:05:55,860 --> 00:05:59,809
And it was at a time when it was not yet so
common as it is today that people know more

00:05:59,809 --> 00:06:03,039
than one language.

00:06:03,039 --> 00:06:10,029
And what Charlemagne acknowledged or expressed
here is that knowing at least a second or

00:06:10,029 --> 00:06:16,309
maybe even a third language is not just about
being able to speak to more people, but actually

00:06:16,309 --> 00:06:18,559
learning another language also shapes the
thinking.

00:06:18,559 --> 00:06:23,719
So, if you have a new language that you can
express yourself in, you are maybe also more

00:06:23,719 --> 00:06:28,520
open to new ideas, and you can express things
that are not easily expressed in your normal

00:06:28,520 --> 00:06:29,550
language that you use.

00:06:29,550 --> 00:06:33,249
And the same, I would say, applies to programming
languages.

00:06:33,249 --> 00:06:39,680
So, learning another programming language
opens up new possibilities about thinking

00:06:39,680 --> 00:06:44,180
in terms of algorithms, in terms of constructs,
or expressing ideas.

00:06:44,180 --> 00:06:52,539
And that's valuable even if you're then going
on to program mainly in one language.

7 # slide
00:06:52,539 --> 00:06:57,789
This is also supported by more recent history.

00:06:57,789 --> 00:07:04,169
So, what we have here is a picture of the
poster that I used to have in my old office.

00:07:04,169 --> 00:07:08,729
And it tries to depict the history of programming
languages.

00:07:08,729 --> 00:07:11,059
Of course, it's not a complete picture.

00:07:11,059 --> 00:07:14,729
For one thing, because it's from a 2004 book.

00:07:14,729 --> 00:07:21,689
So, it's already quite old, again, by the
standards of computer science.

00:07:21,689 --> 00:07:28,339
And also, it's actually a picture mainly of
the programming languages that the specific

00:07:28,339 --> 00:07:31,919
publisher has published books about.

00:07:31,919 --> 00:07:33,119
So, it's definitely not complete.

00:07:33,119 --> 00:07:34,309
But that's not really the point.

00:07:34,309 --> 00:07:39,679
The point is that while in the beginning there
were just a few languages developing, ...

00:07:39,679 --> 00:07:43,669
So, probably it's not even so easy to zoom
in here.

00:07:43,669 --> 00:07:48,409
So, if you do not know, you might want to
actually research what was the first programming

00:07:48,409 --> 00:07:52,520
language that is acknowledged as a high-level
programming language, so not just machine

00:07:52,520 --> 00:07:53,520
code.

00:07:53,520 --> 00:07:57,469
But anyway, as we can also see, over the years
this has proliferated.

00:07:57,469 --> 00:08:00,589
So, there are many languages developing in
parallel.

00:08:00,589 --> 00:08:05,210
There are also connections where it seems
that one language is influencing another.

00:08:05,210 --> 00:08:12,779
This is indicated here with these thin lines
that go between the different lanes.

00:08:12,779 --> 00:08:17,929
And of course, one might ask: If it's good
enough that everybody knows C, Java, or Python,

00:08:17,929 --> 00:08:21,459
then why do we need to have all these different
languages?

00:08:21,459 --> 00:08:24,110
Why is there this kind of development in parallel?

00:08:24,110 --> 00:08:28,059
But of course, also, you see that languages
die out.

00:08:28,059 --> 00:08:33,469
There are languages that start and after a
short while they seem to disappear again.

00:08:33,469 --> 00:08:36,560
And there are languages that live a very long
life.

00:08:36,560 --> 00:08:39,769
And again, the question could be: Why is that?

00:08:39,769 --> 00:08:49,579
So, what separates programming languages to
be a long-term success or to be very short-lived?

8 # slide
00:08:49,579 --> 00:08:59,750
Another picture from a different source with
fewer selected languages, but better visible

00:08:59,750 --> 00:09:02,710
dependencies and inheritance relationships
between them.

00:09:02,710 --> 00:09:05,250
And most interestingly, with some color coding.

00:09:05,250 --> 00:09:09,139
So, here we see some labels that are used.

00:09:09,139 --> 00:09:15,791
And this could already be seen as paradigm
labels for indicating what kind of language

00:09:15,791 --> 00:09:18,620
we have in each specific case.

00:09:18,620 --> 00:09:27,850
And you will find, for example, C, Java, Python
in this yellow-green area: imperative and/or

00:09:27,850 --> 00:09:29,150
object-oriented programming languages.

00:09:29,150 --> 00:09:35,410
Whereas the languages we will be looking at,
Haskell and Prolog, appear in the red and

00:09:35,410 --> 00:09:36,410
blue colors.

00:09:36,410 --> 00:09:42,589
So, that already indicates that there must
be something very different about them from

00:09:42,589 --> 00:09:45,379
the majority of languages that you see here.

00:09:45,379 --> 00:09:50,910
Maybe it's also interesting for you to just
look at this picture a bit, and ask yourself

00:09:50,910 --> 00:09:57,670
whether you have heard about more than 10
of the languages that are mentioned here.

00:09:57,670 --> 00:10:01,800
Maybe count how far you get.

00:10:01,800 --> 00:10:06,130
And some other aspect here that is interesting,
mainly from the title of the article where

00:10:06,130 --> 00:10:09,980
this picture was taken from: it's called "The
Semicolon Wars".

00:10:09,980 --> 00:10:16,399
So, this was an article in a popular science
magazine that was actually commenting on the

00:10:16,399 --> 00:10:27,850
passion that some people feel for the programming
languages that they use.

9 # slide
00:10:27,850 --> 00:10:30,120
This also translates into popularity contests.

00:10:30,120 --> 00:10:35,339
So, we asked you in the survey whether you
do have a favorite programming language.

00:10:35,339 --> 00:10:39,709
Of course, the same kind of questions and
experiments have been done on the internet.

00:10:39,709 --> 00:10:45,939
So, here is one specific evaluation that somebody
did based on search results and some other

00:10:45,939 --> 00:10:47,220
data sets, I think.

00:10:47,220 --> 00:10:49,329
Not a very surprising picture.

00:10:49,329 --> 00:10:53,329
So, C, Java, Python are near the top.

00:10:53,329 --> 00:10:55,500
It's already a few years old, this picture.

00:10:55,500 --> 00:11:01,430
So, I guess that nowadays Python would be
further up, and maybe some new entries or

00:11:01,430 --> 00:11:05,170
languages like Swift or Rust would also be
near the top.

00:11:05,170 --> 00:11:08,790
So, here, a few years ago, there was still
a very disturbing occurrence of PHP.

00:11:08,790 --> 00:11:12,880
I don't know how this would fare today.

00:11:12,880 --> 00:11:21,510
But well, that's what at some point people
seemed to like in terms of programming languages.

10 # slide
00:11:21,510 --> 00:11:29,440
And, one final visualization which is interesting,
mainly because it is interactive.

00:11:29,440 --> 00:11:34,279
So, if you follow the link that is given down
there, you get to an interactive version of

00:11:34,279 --> 00:11:37,730
this picture where you can zoom in.

00:11:37,730 --> 00:11:39,009
You can filter by paradigms.

00:11:39,009 --> 00:11:47,189
You can explore this graph and, for example,
find out why the dots for the languages are

00:11:47,189 --> 00:11:48,199
of different sizes here.

00:11:48,199 --> 00:11:54,999
So, that's a measure of the influence that
languages have on other languages by some

00:11:54,999 --> 00:11:55,999
metric.

00:11:55,999 --> 00:12:00,079
And then it's interesting, for example, that
of course C is very influential (here, the

00:12:00,079 --> 00:12:07,500
big blue dot that you see), but for example
also Haskell seems moderately influential.

00:12:07,500 --> 00:12:10,750
Even though according to the previous slide,
it's not very popular.

00:12:10,750 --> 00:12:15,130
So, Haskell and other functional languages
may not be the most popular languages, but

00:12:15,130 --> 00:12:17,199
they are influential.

00:12:17,199 --> 00:12:25,210
And maybe further down this course you will
be able to appreciate this to some extent.

11 # slide
00:12:25,210 --> 00:12:30,110
Putting all these pictures aside, one question
of course remains.

00:12:30,110 --> 00:12:32,509
Namely, why is there such diversity in the
first place?

00:12:32,509 --> 00:12:35,310
Why are there that many programming languages?

00:12:35,310 --> 00:12:40,589
Is it the case that one or maybe even each
of these languages can do more than some others

00:12:40,589 --> 00:12:45,240
of them, so that there is a reason for each
individual language to exist?

00:12:45,240 --> 00:12:49,130
Or are there problems that one cannot even
solve in certain languages?

00:12:49,130 --> 00:12:53,779
So that is why we have to have that many
languages, because we have that many problems?

00:12:53,779 --> 00:12:56,470
Or is there a best language, at least for
a certain purpose?

00:12:56,470 --> 00:13:00,660
Or maybe there's no best language overall,
but for one specific application area there

00:13:00,660 --> 00:13:02,540
could be a best language.

00:13:02,540 --> 00:13:07,220
And since we have different application areas,
we need to have many languages?

00:13:07,220 --> 00:13:11,120
And of course also, what actually separates
these different programming languages?

00:13:11,120 --> 00:13:16,850
In what sense are two of these many languages
different from each other, apart from the

00:13:16,850 --> 00:13:22,089
obvious syntax difference that you know when
you see two programs in different languages?

00:13:22,089 --> 00:13:26,399
And of course, for some of these questions
you should already know the answers.

00:13:26,399 --> 00:13:29,600
Or partial answers, at least in theory, from
the theoretical side.

00:13:29,600 --> 00:13:35,970
For example, you do know that all programming
languages ultimately have to be translated

00:13:35,970 --> 00:13:37,410
down to machine code.

00:13:37,410 --> 00:13:42,170
So, in that sense, they cannot do more than
machine code can do.

00:13:42,170 --> 00:13:48,329
If you have attended the "Berechenbarkeit
und Komplexität" course by Prof. König,

00:13:48,329 --> 00:13:54,399
then you also know that there is the important
concept of Turing power, of a programming

00:13:54,399 --> 00:13:58,509
language being equivalent in expressive power
to a Turing Machine.

00:13:58,509 --> 00:14:03,550
And virtually all of the languages that appeared
in the previous slides are Turing equivalent

00:14:03,550 --> 00:14:04,550
in that sense.

00:14:04,550 --> 00:14:10,029
So, on a theoretical insight, none of them
is more powerful than the others.

00:14:10,029 --> 00:14:13,720
Of course, they can solve exactly the same
mathematical problems.

00:14:13,720 --> 00:14:18,199
But nevertheless, it could be that for a specific
application area, one language is simply much

00:14:18,199 --> 00:14:19,360
better suited.

00:14:19,360 --> 00:14:23,569
That's indeed one of the reasons for different
languages to exist.

00:14:23,569 --> 00:14:28,459
So, some of the languages that you have seen,
or that have been mentioned, were virtually

00:14:28,459 --> 00:14:30,959
tailor-made for one application domain.

00:14:30,959 --> 00:14:36,850
And then, of course, a lot of effort was put
into making them nicely usable for this application

00:14:36,850 --> 00:14:37,850
domain.

00:14:37,850 --> 00:14:41,529
And in that sense, they might even be the
best language for a certain area, even though

00:14:41,529 --> 00:14:45,520
they are not theoretically more powerful than
other languages.

00:14:45,520 --> 00:14:51,630
And, if you do know two or three or four programming
languages yourself, then you might also have

00:14:51,630 --> 00:15:01,379
your own opinions, of course, about some of
these questions here, in particular on the

00:15:01,379 --> 00:15:02,379
practical side.

12 # slide
00:15:02,379 --> 00:15:07,319
The last question from the previous slide
about "what separates/differentiates different

00:15:07,319 --> 00:15:08,319
programming languages":

00:15:08,319 --> 00:15:13,019
Of course, one can ask oneself what are relevant
dimensions or distinctions that one can make?

00:15:13,019 --> 00:15:17,959
Of course, if one thinks a bit about this,
then several things offer themselves.

00:15:17,959 --> 00:15:20,210
So, for example, of course, one can compare
the syntax.

00:15:20,210 --> 00:15:25,690
And not just the concrete syntax (how the
keywords are called in two different languages),

00:15:25,690 --> 00:15:30,430
but for example also how syntactically rich
or syntactically poor/scarce the languages

00:15:30,430 --> 00:15:31,430
are.

00:15:31,430 --> 00:15:37,689
And two typical languages that you maybe haven't
heard of before (or not both of them, at least),

00:15:37,689 --> 00:15:39,160
are APL and Lisp.

00:15:39,160 --> 00:15:42,990
So, the language is called APL for Array Processing
Language.

00:15:42,990 --> 00:15:46,420
It was used for mathematical calculations
on matrices, etc.

00:15:46,420 --> 00:15:49,089
Arrays in the general sense.

00:15:49,089 --> 00:15:56,939
And the design of this language was such that
it had very rich syntax in the sense of expressing

00:15:56,939 --> 00:15:59,959
mathematical concepts via mathematical symbols.

00:15:59,959 --> 00:16:07,070
So actually, in order to program in APL efficiently,
one needed a separate keyboard on which all

00:16:07,070 --> 00:16:11,819
the special symbols would appear that you
wanted to see in an APL program.

00:16:11,819 --> 00:16:19,480
And on the other extreme side of the spectrum is Lisp,
which is also an ancestor of functional programming.

00:16:19,480 --> 00:16:21,519
In Lisp, the syntax is very simple.

00:16:21,519 --> 00:16:26,089
So, there are very few syntactical constructs,
basically only identifiers and opening and

00:16:26,089 --> 00:16:29,110
closing brackets, and everything is made from
them.

00:16:29,110 --> 00:16:32,769
No special operators, no special symbols,
etc.

00:16:32,769 --> 00:16:34,250
So: extreme differences.

00:16:34,250 --> 00:16:37,879
Of course, many languages live somewhere in
the middle.

00:16:37,879 --> 00:16:41,389
Another dimension that one could consider
is verbosity:

00:16:41,389 --> 00:16:45,790
So, does it take a lot of program text to
express a certain idea?

00:16:45,790 --> 00:16:51,660
Or is it the opposite, that very short programs
express mathematical ideas, for example?

00:16:51,660 --> 00:16:53,029
And again, there are extremes:

00:16:53,029 --> 00:16:54,699
So COBOL is a very old language.

00:16:54,699 --> 00:16:59,350
It was used in the commercial domain, and
is still today used in some areas.

00:16:59,350 --> 00:17:05,189
The idea of COBOL, when it was designed, was
to be very close to natural language.

00:17:05,189 --> 00:17:10,089
In the sense that a business consultant would
be able to read a COBOL program, even though

00:17:10,089 --> 00:17:12,900
not being a programmer.

00:17:12,900 --> 00:17:18,100
So that leads to a very verbose program text.

00:17:18,100 --> 00:17:20,549
And on the other extreme side, one could see
Haskell, that we will be looking at.

00:17:20,549 --> 00:17:28,329
And you will later see that a lot of ideas
can be expressed in very short Haskell programs.

00:17:28,329 --> 00:17:32,770
There are differences in terms of how languages
are implemented.

00:17:32,770 --> 00:17:37,650
Of course, it is not really a difference of
the language itself, but of how it is used.

00:17:37,650 --> 00:17:40,730
So: compilers vs. interpreters.

00:17:40,730 --> 00:17:44,460
In principle, any language could be either
compiled or interpreted.

00:17:44,460 --> 00:17:49,220
But there are languages that are really made
for one of these two execution modes.

00:17:49,220 --> 00:17:52,200
C is a typical compiled-only language.

00:17:52,200 --> 00:17:57,399
Versus Perl, for which I don't even know whether
a compiler exists.

00:17:57,399 --> 00:18:02,350
This also influences not just how the program
runs, but also how development of programs

00:18:02,350 --> 00:18:04,270
in the language works.

00:18:04,270 --> 00:18:10,250
For example, for interpreters there are different
development habits that people acquire.

00:18:10,250 --> 00:18:17,409
Then, there could be differences between being
a very domain-specific or a very general-purpose

00:18:17,409 --> 00:18:18,409
language.

00:18:18,409 --> 00:18:22,730
So, SQL that you might have seen already (or
you will have seen already, if you have taken

00:18:22,730 --> 00:18:30,130
the "Datenbanken" lecture), is a very typical
example of a domain-specific language.

00:18:30,130 --> 00:18:36,789
Even SQL, despite being Turing equivalent,
is still domain-specific in the following

00:18:36,789 --> 00:18:37,789
sense:

00:18:37,789 --> 00:18:41,210
You might be able to program everything in
SQL, but what you really should be using SQL

00:18:41,210 --> 00:18:45,630
for is dealing with relational databases.

00:18:45,630 --> 00:18:50,750
That's what it's made for and where it can
be used in a reasonable way.

00:18:50,750 --> 00:18:55,990
Versus languages like Java, that are really
made not with some specific purpose, but in

00:18:55,990 --> 00:19:00,279
order to program whatever application one
is interested in.

00:19:00,279 --> 00:19:01,820
But then, it is also not specialized.

00:19:01,820 --> 00:19:09,220
So it can do everything, but other languages
are better at things for which they were designed.

00:19:09,220 --> 00:19:14,480
There are distinctions like sequentiality
or concurrency/parallelism, which are, of course,

00:19:14,480 --> 00:19:17,480
driven to some extent by hardware developments.

00:19:17,480 --> 00:19:21,390
For example, JavaScript is a typical sequential
language.

00:19:21,390 --> 00:19:28,770
There are even problems using it in a parallel
fashion in a browser, for example.

00:19:28,770 --> 00:19:33,340
Versus Erlang, which is a language that was
developed for network processing.

00:19:33,340 --> 00:19:39,380
And from the very beginning, the very first
ideas, it is designed for concurrency and

00:19:39,380 --> 00:19:46,250
parallelism in order to cope with parallel
hardware or parallel networks.

00:19:46,250 --> 00:19:50,440
Another important distinction is that between
typed and untyped languages.

00:19:50,440 --> 00:19:56,440
And that's also another area where people
start language wars.

00:19:56,440 --> 00:19:59,490
In this course, interestingly, we will see
both.

00:19:59,490 --> 00:20:07,190
So, Haskell is a typical example of a typed,
and very strongly typed, programming language.

00:20:07,190 --> 00:20:10,919
And this will also be featured importantly
in the course itself.

00:20:10,919 --> 00:20:16,570
Versus Prolog, which is a typical example
of an untyped programming language.

00:20:16,570 --> 00:20:25,222
So this spans across paradigms, this distinction
between typed and untyped languages.

00:20:25,222 --> 00:20:27,390
There are dynamic and static languages.

00:20:27,390 --> 00:20:31,920
It is not that easy to capture this distinction.

00:20:31,920 --> 00:20:38,680
But there are languages for which, whether
they are compiled or interpreted, but mainly

00:20:38,680 --> 00:20:41,360
applies to interpreted languages, that are
very dynamic.

00:20:41,360 --> 00:20:48,230
So, at runtime, things can change, types can
change, and composition of modules can change.

00:20:48,230 --> 00:20:53,130
Ruby is an example where this dynamic nature
is very prominent.

00:20:53,130 --> 00:21:00,590
Versus ML, another functional language, which
is really made for static analysis of programs.

00:21:00,590 --> 00:21:06,000
And then shouldn't change their composition
at runtime, for example.

00:21:06,000 --> 00:21:10,110
Then, there are these paradigm names: declarative
vs. imperative.

00:21:10,110 --> 00:21:14,350
And that already occurred earlier in one of
the pictures.

00:21:14,350 --> 00:21:19,080
There we had "declarative" as a label for
Prolog and "imperative" as a label for C.

00:21:19,080 --> 00:21:24,500
And I assume that most of the languages that
you have learned so far, or that you have

00:21:24,500 --> 00:21:32,039
used so far, are imperative languages, whether
or not they were explicitly labeled etc.

00:21:32,039 --> 00:21:36,010
And then, there is also this label of "object-orientation".

00:21:36,010 --> 00:21:39,350
There is not really an opposite to that.

00:21:39,350 --> 00:21:45,210
And I would actually say that "object-oriented"
is more something that is added on to a paradigm.

00:21:45,210 --> 00:21:48,970
So often, object-oriented languages are imperative
programming languages, whether or not they

00:21:48,970 --> 00:21:49,970
were explicitly labeled as such when you learned
them.

00:21:49,970 --> 00:21:50,970
But that need not be the case.

00:21:50,970 --> 00:21:53,980
There are, for example, also object-oriented
functional programming languages.

00:21:53,980 --> 00:21:57,740
Haskell is not one of those, so that's not
something that we will consider.

00:21:57,740 --> 00:22:04,059
But object-orientation is something in addition
to a paradigm, and it will not play a role

00:22:04,059 --> 00:22:06,399
in this course.

00:22:06,399 --> 00:22:12,810
There might be other distinctions to be made,
but these are just some examples to maybe

00:22:12,810 --> 00:22:15,280
also get you thinking about the languages
that you already know.

00:22:15,280 --> 00:22:23,370
How they fall into these different distinctions.

13 # slide
00:22:23,370 --> 00:22:27,350
Despite all these differences mentioned on
the previous slide, there are of course also

00:22:27,350 --> 00:22:31,059
common principles underlying different programming
languages.

00:22:31,059 --> 00:22:36,019
For example, if we have a programming language,
we need to be able to describe the syntax

00:22:36,019 --> 00:22:39,860
and semantics, and also of course discuss
implementation strategies.

00:22:39,860 --> 00:22:44,950
These are things we will not feature very
prominently in this course.

00:22:44,950 --> 00:22:48,510
Of course, we need to discuss syntax and semantics.

00:22:48,510 --> 00:22:52,640
But we will not do this very formally, and
we will not implement languages.

00:22:52,640 --> 00:23:00,170
So these aspects are things that would, for
example, occur in the lecture "Compilerbau".

00:23:00,170 --> 00:23:05,840
that I give in the Master Program, but not
in the Bachelor Program.

00:23:05,840 --> 00:23:11,820
Another note: There are, of course, language
concepts that also appear in different languages

00:23:11,820 --> 00:23:15,590
and maybe also appear in different ways in
different languages.

00:23:15,590 --> 00:23:19,780
So, for example, every programming language
that I know has variables and some binding

00:23:19,780 --> 00:23:20,780
constructs.

00:23:20,780 --> 00:23:22,680
But the role might be different.

00:23:22,680 --> 00:23:28,580
As you will see, Haskell variables are something
completely different from variables in C or

00:23:28,580 --> 00:23:29,580
Java.

00:23:29,580 --> 00:23:31,630
And in Prolog, it's again a different story.

00:23:31,630 --> 00:23:34,880
So, there are variables, but their role is
different.

00:23:34,880 --> 00:23:40,230
And similarly, there are constructs like typing
that again play a different role in different

00:23:40,230 --> 00:23:42,480
languages, if the languages are typed at all.

00:23:42,480 --> 00:23:48,210
So, Java is a typed programming language,
but types there are noticeably different from

00:23:48,210 --> 00:23:50,760
types in Haskell, for example.

00:23:50,760 --> 00:23:57,409
And likewise, control structures, how programs
are organized, abstraction features, how to

00:23:57,409 --> 00:23:58,740
modularize programs.

00:23:58,740 --> 00:24:04,700
That's important in all languages, but it's
different in different languages.

00:24:04,700 --> 00:24:12,299
And we will try to bring this also to the
front by discussing such distinctions.

00:24:12,299 --> 00:24:17,500
There is this idea of labeling languages according
to the paradigms.

00:24:17,500 --> 00:24:23,200
So, we say that Java and C are imperative
languages, and Haskell and ML are functional

00:24:23,200 --> 00:24:24,630
languages, for example.

00:24:24,630 --> 00:24:31,440
Actually, defining this is not very easy,
but the aspects that have been discussed here

00:24:31,440 --> 00:24:34,600
and mentioned on the slide contribute to these
distinctions.

00:24:34,600 --> 00:24:40,899
In any case, such aspects can best be appreciated
if one knows several different languages.

00:24:40,899 --> 00:24:44,190
And that's one of the aims of this course.

14 # slide
00:24:44,190 --> 00:24:48,590
So, what is the plan for this lecture?

00:24:48,590 --> 00:24:53,860
We will focus on two paradigms: functional
and logic programming.

00:24:53,860 --> 00:25:00,019
I assume that these are two new paradigms
for most of you, and that's also supported

00:25:00,019 --> 00:25:03,000
by the survey results so far.

00:25:03,000 --> 00:25:09,669
We will pick two specific languages: Haskell
for functional programming, and Prolog for

00:25:09,669 --> 00:25:11,760
logic programming.

00:25:11,760 --> 00:25:14,840
In the case of functional programming, we
would have had a choice.

00:25:14,840 --> 00:25:22,260
So there is a long history and also different
example languages for functional programming.

00:25:22,260 --> 00:25:28,559
And we choose Haskell because it allows us
to discuss all the aspects that we want to

00:25:28,559 --> 00:25:29,559
cover.

00:25:29,559 --> 00:25:33,940
And on the Prolog side, the situation is a
bit different, because Prolog is really the

00:25:33,940 --> 00:25:37,420
only major logic programming language existing
at all.

00:25:37,420 --> 00:25:43,630
So, there isn't much choice to take another
logic programming language.

00:25:43,630 --> 00:25:51,130
In both cases, we consider actual programming
concepts, and we will also discuss aspects

00:25:51,130 --> 00:25:52,370
related to semantics.

00:25:52,370 --> 00:25:55,519
So, evaluation in the case of Haskell, resolution
in the case of Prolog.

00:25:55,519 --> 00:26:01,820
Some of that will already be familiar to you
from the "Logik" lecture.

00:26:01,820 --> 00:26:05,279
With Haskell, we explore typing concepts.

00:26:05,279 --> 00:26:08,809
I mentioned this already, that Haskell has
a very strong type discipline.

00:26:08,809 --> 00:26:16,659
That allows us to discuss aspects like: inference,
genericity, polymorphism in a more disciplined

00:26:16,659 --> 00:26:21,160
way than what would, for example, be possible
with a language like Java (even though it's

00:26:21,160 --> 00:26:23,070
also a typed language).

00:26:23,070 --> 00:26:25,960
For Prolog, types do not play a role.

00:26:25,960 --> 00:26:30,909
And in each case, we will discuss and compare
concepts, as I already mentioned on the previous

00:26:30,909 --> 00:26:37,039
slide: variables, the distinction between
expressions and commands, and other aspects

00:26:37,039 --> 00:26:42,490
across languages (both across Haskell and
Prolog, and in comparison to imperative programming

00:26:42,490 --> 00:26:44,800
languages).

15 # slide
00:26:44,800 --> 00:26:54,470
Before talking about possible literature,
in two slides, first, a few final comments

00:26:54,470 --> 00:26:56,049
about motivation.

00:26:56,049 --> 00:27:02,070
Or actually, first, a few comments about the
notion of declarative programming.

00:27:02,070 --> 00:27:08,960
That label already occurred in one of the
earlier pictures as a distinction of Prolog.

00:27:08,960 --> 00:27:15,130
Actually, declarative (or also descriptive)
programming is often used as an umbrella term

00:27:15,130 --> 00:27:19,380
for both functional and logic programming.

00:27:19,380 --> 00:27:25,389
The reason is that they share the idea that
programmers should be more thinking in terms

00:27:25,389 --> 00:27:26,519
of "what" instead of "how".

00:27:26,519 --> 00:27:33,570
So the idea, originally, that programming
should consist more of specifying a problem,

00:27:33,570 --> 00:27:38,549
than planning a certain computation process
in individual steps.

00:27:38,549 --> 00:27:46,669
Then, logic programming came into fashion
in some sense.

00:27:46,669 --> 00:27:48,100
This was even more ambitious.

00:27:48,100 --> 00:27:51,960
The idea then was that programmers shouldn't
be thinking about computation processes at

00:27:51,960 --> 00:27:52,960
all.

00:27:52,960 --> 00:27:58,450
They should only specify and that would, somehow,
resolve all the problems.

00:27:58,450 --> 00:28:00,539
That was a bit overambitious.

00:28:00,539 --> 00:28:08,809
But the general idea of focusing more on the
specification of problems than on their detailed

00:28:08,809 --> 00:28:16,090
solution/computation has survived in the form
of both functional and logic programming.

00:28:16,090 --> 00:28:18,630
Of course, this does not mean that some magic
is going on.

00:28:18,630 --> 00:28:23,380
So, it's still necessary for the programmer
to think about algorithms.

00:28:23,380 --> 00:28:26,440
And that's, of course, a good and useful thing.

00:28:26,440 --> 00:28:31,490
But arguably, I think it's nicer in a declarative
setting.

00:28:31,490 --> 00:28:32,630
Why is that?

00:28:32,630 --> 00:28:40,029
Largely because declarative programming
is usually happening at a high level and has

00:28:40,029 --> 00:28:42,909
a somewhat mathematical feel to it.

00:28:42,909 --> 00:28:48,480
In the case of logic programming, obviously,
the mathematical aspect is the logic.

00:28:48,480 --> 00:28:53,269
Whereas in the case of functional programming,
the mathematics that is involved is mainly

00:28:53,269 --> 00:28:59,590
algebra: dealing with expressions and their
transformations.

00:28:59,590 --> 00:29:08,559
This leads to claims, and often observations,
about functional or logic programs being shorter

00:29:08,559 --> 00:29:16,309
(to some extent), more readable (if one knows
the languages), and more often correct, than

00:29:16,309 --> 00:29:18,850
programs written in a more conventional style.

00:29:18,850 --> 00:29:24,309
And one reason for this is that execution
and reasoning about programs is much closer

00:29:24,309 --> 00:29:30,590
to each other in a declarative or descriptive
language than in a standard imperative language.

00:29:30,590 --> 00:29:39,140
We will discuss this also when we make observations
about expressions, commands, and other language

00:29:39,140 --> 00:29:40,140
constructs.

00:29:40,140 --> 00:29:43,290
How they turn out in the different paradigms.

00:29:43,290 --> 00:29:48,320
A side benefit of declarative languages is
that they often have reduced syntax.

00:29:48,320 --> 00:29:55,050
That, of course, has to do with all the observations
I made about shorter programs.

00:29:55,050 --> 00:30:01,570
But also the way in which programs are expressed
is often conceptually simpler.

00:30:01,570 --> 00:30:06,429
Because, for example, there are fewer keywords,
but on the other hand a richer expression

00:30:06,429 --> 00:30:07,429
language.

00:30:07,429 --> 00:30:15,620
But we will see this when we encounter examples.

16 # slide
00:30:15,620 --> 00:30:23,130
Ultimately, why should you bother studying
these new paradigms at all?

00:30:23,130 --> 00:30:30,700
Well, one basic and maybe somewhat unsatisfying
answer is that for many of you, this is a

00:30:30,700 --> 00:30:31,720
mandatory course.

00:30:31,720 --> 00:30:37,110
So you simply will have to deal with this
material in order to get the required credits.

00:30:37,110 --> 00:30:41,899
A deeper reason is that learning different
languages now will make it easier for you

00:30:41,899 --> 00:30:43,889
to pick up new languages later on.

00:30:43,889 --> 00:30:50,490
It is very unlikely that during your career
as a computer scientist you will never again

00:30:50,490 --> 00:30:52,340
have to learn a new language.

00:30:52,340 --> 00:30:56,100
Much more likely, you will have to learn new
languages every few years.

00:30:56,100 --> 00:31:00,289
Not only syntactically new languages, but
also new language ideas.

00:31:00,289 --> 00:31:03,470
Then this course helps to prepare you for
that.

00:31:03,470 --> 00:31:10,179
Also, certain features and concepts from languages
that were once considered rather exotic have

00:31:10,179 --> 00:31:15,590
made their way into more mainstream programming
languages again and again in the past.

00:31:15,590 --> 00:31:17,290
And it's likely to happen again.

00:31:17,290 --> 00:31:23,400
Examples from the past would be comprehension
syntax or lambda expressions that have been

00:31:23,400 --> 00:31:28,629
taken over into languages like Java, for example.

00:31:28,629 --> 00:31:33,899
Also, in some application domains there is
an increased demand for mathematics-based

00:31:33,899 --> 00:31:38,570
languages, for disciplined and conceptually
expressive languages.

00:31:38,570 --> 00:31:43,490
For example, that applies to domains where
formal verification becomes more and more

00:31:43,490 --> 00:31:44,490
important.

00:31:44,490 --> 00:31:50,030
It turns out that both logic and functional
programs are easier to verify.

00:31:50,030 --> 00:31:57,679
Generally, as already mentioned earlier, knowing
new paradigms or more paradigms increases

00:31:57,679 --> 00:31:59,590
capacity to express ideas.

00:31:59,590 --> 00:32:06,990
So, even if you will never, in practice, again
write functional or logic programs, the ideas

00:32:06,990 --> 00:32:13,840
that you acquire while dealing with this material,
hopefully, will increase your range also in

00:32:13,840 --> 00:32:15,190
other languages.

00:32:15,190 --> 00:32:22,460
And finally, one aspect is that if you want
to write a Bachelor or Master thesis further

00:32:22,460 --> 00:32:28,740
down in your studies in my group, then very
likely you will have to use the material from

00:32:28,740 --> 00:32:29,769
this course.

00:32:29,769 --> 00:32:36,629
So I would estimate that in 90% of cases where
a student wants to write a Bachelor thesis

00:32:36,629 --> 00:32:41,600
in my group, they would have to be using Haskell.

"17 # slide
00:32:41,600 --> 00:32:48,279
As I mentioned at the beginning of the video,
I want to close with a few words about literature,

00:32:48,279 --> 00:32:51,679
in particular books that you may use for the
course.

00:32:51,679 --> 00:32:57,440
One thing I have to say is that there is not
one specific book that covers exactly this

00:32:57,440 --> 00:32:58,440
course.

00:32:58,440 --> 00:33:04,120
So, there's no book "Programming Paradigms"
that would somehow correspond exactly to the

00:33:04,120 --> 00:33:05,330
course I am giving.

00:33:05,330 --> 00:33:09,390
But there are several books, both for the
Haskell and for the Prolog part, that would

00:33:09,390 --> 00:33:10,750
be useful.

00:33:10,750 --> 00:33:16,879
All the books I'm going to mention, on the
next two slides, are available in our library.

00:33:16,879 --> 00:33:22,690
Of course, that is only of limited usefulness
for you in the current situation, but that

00:33:22,690 --> 00:33:23,809
might change in a few weeks.

00:33:23,809 --> 00:33:26,139
The library might open more reliably again.

00:33:26,139 --> 00:33:31,100
And even in the meanwhile, there are certain
books that are also available online.

00:33:31,100 --> 00:33:35,610
And actually, I asked the library last year
to acquire a few more e-books.

00:33:35,610 --> 00:33:47,840
So there should be additional opportunities/availability
of e-books.

18 # slide
00:33:47,840 --> 00:33:54,350
On the Haskell side, the book that is probably
closest to what I'm doing in this course is

00:33:54,350 --> 00:33:56,309
the book "Programming in Haskell" by Graham
Hutton.

00:33:56,309 --> 00:33:57,830
There is a first and a second edition.

00:33:57,830 --> 00:34:02,679
I mentioned here the second edition, but actually,
the first edition is also very useful for

00:34:02,679 --> 00:34:03,679
the course.

00:34:03,679 --> 00:34:06,380
So you might use either one.

00:34:06,380 --> 00:34:13,270
Then, there is a more comprehensive and much
thicker book by Simon Thompson: "Haskell

00:34:13,270 --> 00:34:14,780
- The Craft of Functional Programming".

00:34:14,780 --> 00:34:21,630
It's already in its third edition, and it
does contain all the things we will be doing

00:34:21,630 --> 00:34:23,200
on the conceptual Haskell side.

00:34:23,200 --> 00:34:26,010
And it covers a lot in addition.

00:34:26,010 --> 00:34:31,530
So, it covers more material than we do in
this course, definitely.

00:34:31,530 --> 00:34:36,400
Then, there is this very nice book, "Thinking
Functionally with Haskell".

00:34:36,400 --> 00:34:42,070
This takes a bit more mathematical approach
to programming in Haskell, which might not

00:34:42,070 --> 00:34:44,770
be suitable for all readers.

00:34:44,770 --> 00:34:51,250
But maybe there are some among you that would
benefit and profit from this kind of approach.

00:34:51,250 --> 00:34:57,600
Then, if you prefer a German book (because
all the other three books mentioned so far

00:34:57,600 --> 00:35:03,310
are English books), there is this book: "Haskell-Intensivkurs"
by these two authors.

00:35:03,310 --> 00:35:10,490
And both, the book by Richard Bird and "Haskell-Intensivkurs",
are books that you can already read online

00:35:10,490 --> 00:35:11,600
and for free.

00:35:11,600 --> 00:35:20,130
If you log in from the university network
or via VPN.

00:35:20,130 --> 00:35:22,660
And there's another German book, but it is
out of print.

00:35:22,660 --> 00:35:27,490
So it's available in the library, but I'm
not sure whether you will find it elsewhere,

00:35:27,490 --> 00:35:29,550
for example, if you want to buy a book.

00:35:29,550 --> 00:35:35,250
And generally, in the Moodle course, you will
also find, both for the Haskell and Prolog

00:35:35,250 --> 00:35:45,290
part, some links to further books from the
library that you could browse.

19 # slide
00:35:45,290 --> 00:35:49,540
For the Prolog part of this course, I would
mostly suggest this book.

00:35:49,540 --> 00:35:53,530
It is also a book that is available for free
online.

00:35:53,530 --> 00:35:57,750
So, you can read it online, but you can also
order a paper copy.

00:35:57,750 --> 00:36:01,350
And there should also be copies in the library.

00:36:01,350 --> 00:36:07,110
And there are actually very many additional
Prolog books in the library, both in English

00:36:07,110 --> 00:36:08,790
and in German.

00:36:08,790 --> 00:36:15,570
Some of them are quite old, and most of them
cover much more material than we will be doing

00:36:15,570 --> 00:36:16,570
in this course.

00:36:16,570 --> 00:36:20,790
But of course, they would still be useful
also to learn the introductory concepts that

00:36:20,790 --> 00:36:29,470
we will be dealing with".
