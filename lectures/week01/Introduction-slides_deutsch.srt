
2 # slide
00:00:18,810 --> 00:00:24,470
Ich werde nun über die Motivation für
diesen Kurs sprechen, worum es bei Programmierparadigmen geht.

00:00:24,470 --> 00:00:29,590
Und worauf wir uns dieses Jahr, wie
auch in den vergangenen Jahren, speziell konzentrieren werden.

00:00:29,590 --> 00:00:32,820
Und ich werde auch einige Literatur
nennen, die Sie vielleicht verwenden möchten.

00:00:32,820 --> 00:00:38,760
Zunächst möchte ich ein paar Ergebnisse der
Moodle-Umfrage zeigen, die wir 2019 durchgeführt haben.

00:00:38,760 --> 00:00:43,540
Wahrscheinlich haben Sie die aktuelle
Moodle-Umfrage schon gesehen oder daran teilgenommen.

00:00:43,540 --> 00:00:50,260
Aber da die Ergebnisse daraus noch nicht vollständig
sind, werde ich stattdessen ein paar Ergebnisse aus 2019

00:00:50,260 --> 00:00:52,020
zeigen und ein wenig darüber sprechen.

00:00:52,020 --> 00:00:57,860
Und ich denke, dass einige der Aspekte in
Ihren Antworten ähnlich sein werden, wenn sie für

00:00:57,860 --> 00:01:01,290
den aktuellen Kurs abgeschlossen sind.

3 # slide
00:01:01,290 --> 00:01:07,479
Eine Frage, die wir gestellt haben, ist die nach
der Sprache, in der die Studierenden den Kurs "Grundlegende Programmiertechniken"

00:01:07,479 --> 00:01:08,530
absolviert haben.

00:01:08,530 --> 00:01:14,080
Das ist also eine Frage, die nur
für die Studierenden der "Angewandten Informatik" Sinn

00:01:14,080 --> 00:01:17,570
macht, weil sie für
die ISE-Studierenden nicht wirklich zutrifft.

00:01:17,570 --> 00:01:23,490
Für uns ist diese Frage relevant, da ich
an einigen Stellen im Kurs Vergleiche zwischen Sprachkonstrukten

00:01:23,490 --> 00:01:28,630
von neuen Sprachen, die Sie lernen
werden, und Sprachen, von denen wir erwarten,

00:01:28,630 --> 00:01:30,990
dass Sie sie
bereits kennen, anstellen werde.

00:01:30,990 --> 00:01:40,020
Wir wissen natürlich auch, dass die GPT-Vorlesung von der
Vermittlung von Java auf die Vermittlung von Python hauptsächlich

00:01:40,020 --> 00:01:41,310
umgestellt hat.

00:01:41,310 --> 00:01:46,650
Im Jahr 2019 war es, wie Sie hier
sehen, noch so, dass zwei Drittel der Studierenden in

00:01:46,650 --> 00:01:52,190
unserem Kurs GPT
mit Java-Vorlesungen hatten.

00:01:52,190 --> 00:01:57,170
Ich gehe davon aus, dass sich
dieses Verhältnis nun etwas verändert hat.

00:01:57,170 --> 00:02:02,570
Aber auch aus den ersten Antworten in der Umfrage,
die wir schon sehen konnten, ist es auch so,

00:02:02,570 --> 00:02:06,729
dass es immer noch recht viele Studierende gibt, für
die Java die Sprache war, die Sie in GPT

00:02:06,729 --> 00:02:07,729
gelernt haben.

00:02:07,729 --> 00:02:10,759
Wir werden also tatsächlich
versuchen, beidem gerecht zu werden.

00:02:10,759 --> 00:02:18,870
Wir werden solche Vergleiche so ansprechen, dass
Sie, egal ob Ihre erste oder dominante imperative

00:02:18,870 --> 00:02:23,580
Programmiersprache Java oder Python ist, in
der Lage sein sollten, die Vergleiche, die

00:02:23,580 --> 00:02:27,290
ich anstellen werde, zu schätzen.

4 # slide
00:02:27,290 --> 00:02:33,560
Dann haben wir auch danach gefragt, in
welcher Sprache sich die Studierenden am sichersten fühlen.

00:02:33,560 --> 00:02:39,610
Das heißt, welche Sprache sie am besten beherrschen
oder mit der sie am sichersten umgehen können.

00:02:39,610 --> 00:02:41,530
Nicht alle Studierenden
gaben darauf eine Antwort.

00:02:41,530 --> 00:02:47,970
Aber unter denjenigen, die eine Antwort gegeben haben, ist
es wahrscheinlich nicht sehr überraschend, wenn wir bedenken, dass die

00:02:47,970 --> 00:02:55,120
meisten Studierenden vorher Java in GPT gelernt haben,
dass auch hier Java die am häufigsten genannte Sprache

00:02:55,120 --> 00:02:56,120
war.

00:02:56,120 --> 00:03:03,340
Und natürlich ist auch wieder Python
dabei, wahrscheinlich oft von Schülern, die GPT

00:03:03,340 --> 00:03:06,730
mit Python-Code gelernt haben.

00:03:06,730 --> 00:03:09,069
Aber dann kommt auch noch C ins Spiel.

00:03:09,069 --> 00:03:14,530
Und das könnten sowohl die ISE-Studierenden sein,
für die C in ihrer ersten Programmiervorlesung verwendet

00:03:14,530 --> 00:03:15,530
wird.

00:03:15,530 --> 00:03:19,470
Das könnten aber eigentlich auch Schüler sein, die
C an anderen Stellen gelernt haben, zum Beispiel in

00:03:19,470 --> 00:03:20,470
der Schule.

00:03:20,470 --> 00:03:25,379
Mein Sohn, in der 10. Klasse, hat
C in der Schule in den Informatik-Vorlesungen gelernt.

00:03:25,379 --> 00:03:29,200
Das ist also auch hier eine Möglichkeit.

00:03:29,200 --> 00:03:36,480
Jedenfalls sind es jetzt, wie wir sehen,
mehr als 80 % für diese drei Sprachen.

00:03:36,480 --> 00:03:40,060
Und wahrscheinlich wird das Bild
auch dieses Mal ähnlich sein.

00:03:40,060 --> 00:03:46,159
Und selbst unter den Sprachen, die
genannt wurden, sind die meisten Sprachen imperative

00:03:46,159 --> 00:03:47,159
Programmiersprachen.

00:03:47,159 --> 00:03:51,940
Sie unterscheiden sich also definitiv von der Art
von Sprachen, die in diesem Kurs behandelt werden.

00:03:51,940 --> 00:03:58,709
Das ist natürlich
der Hauptpunkt dieses Programmierparadigmen-Kurses.

00:03:58,709 --> 00:04:03,170
Dass etwas anderes gelernt wird als das,
was schon aus den ersten Programmierkursen oder

00:04:03,170 --> 00:04:06,140
auf anderen Wegen bekannt ist.

5 # slide
00:04:06,140 --> 00:04:13,319
Eine weitere Frage, die wir gestellt haben,
war, ob die Studierenden eine Lieblingsprogrammiersprache haben, und

00:04:13,319 --> 00:04:14,659
welche das ist.

00:04:14,659 --> 00:04:18,519
Auf diese Frage haben die
wenigsten Studierenden eine Antwort gegeben.

00:04:18,519 --> 00:04:24,910
Und wie Sie auf dem letzten Bild
sehen können, wird es nun etwas vielfältiger.

00:04:24,910 --> 00:04:33,349
Aber alles ist immer noch sehr
stark auf C/Java-ähnliche Sprachen oder Python ausgerichtet.

00:04:33,349 --> 00:04:38,710
Etwa 15 Studierende im Jahr 2019 gaben an,
dass sie einige Erfahrung mit funktionaler Programmierung haben.


"00:04:38,710 --> 00:04:43,490
Und eine ähnliche Anzahl
erwähnte dasselbe für logische Programmierung.

00:04:43,490 --> 00:04:48,800
Ich glaube nicht, dass irgendjemand eine
funktionale oder logische Programmiersprache als seine Lieblingsprogrammiersprache

00:04:48,800 --> 00:04:50,750
genannt hat.

00:04:50,750 --> 00:04:54,000
Mein Ziel ist es nicht unbedingt,
dies mit diesem Kurs zu ändern.

00:04:54,000 --> 00:04:58,070
Aber zumindest sollten Sie etwas Neues lernen,
zusätzlich zu den Dingen, die Sie bereits

00:04:58,070 --> 00:04:59,070
kennen.

00:04:59,070 --> 00:05:03,349
Also, weder Haskell noch Prolog, die beiden
Sprachen, die Sie lernen werden, müssen Ihre neue

00:05:03,349 --> 00:05:04,349
Lieblingssprache werden.

00:05:04,349 --> 00:05:11,039
Aber zumindest sollten Sie etwas Neues lernen,
das Sie vielleicht später in anderen Sprachen, die

00:05:11,039 --> 00:05:15,990
Sie benutzen werden, anwenden können.

6 # slide
00:05:15,990 --> 00:05:21,779
Natürlich könnten Sie an dieser Stelle fragen,
warum Sie eine weitere Programmiersprache lernen müssen.

00:05:21,779 --> 00:05:25,949
Es scheint, dass alle von
Ihnen schon einmal programmieren gelernt haben.

00:05:25,949 --> 00:05:30,909
Und viele von Ihnen haben mindestens eine
Programmiersprache, in der sie sich sicher fühlen.

00:05:30,909 --> 00:05:32,830
Also, warum sollte das nicht ausreichen?

00:05:32,830 --> 00:05:36,599
Warum müssen Sie
weitere Programmiersprachen lernen?

00:05:36,599 --> 00:05:42,469
Nun, an dieser Stelle wiederhole ich gerne dieses
Zitat eines mittelalterlichen Königs: "Eine weitere Sprache zu

00:05:42,469 --> 00:05:44,569
kennen, bedeutet, eine
zweite Seele zu haben."

00:05:44,569 --> 00:05:50,830
In Anbetracht der Zeit, in der dies gesagt
wurde, bezieht es sich natürlich nicht auf Programmiersprachen.

00:05:50,830 --> 00:05:55,860
Es bezieht sich also auf
natürliche Sprachen, die Menschen sprechen.

00:05:55,860 --> 00:05:59,809
Und es war zu einer Zeit, als es noch
nicht so üblich war wie heute, dass Menschen mehr als

00:05:59,809 --> 00:06:03,039
eine Sprache beherrschen.

00:06:03,039 --> 00:06:10,029
Und was Karl der Große hier erkannt oder
ausgedrückt hat, ist, dass es nicht nur darum geht,

00:06:10,029 --> 00:06:16,309
mit mehr Menschen sprechen zu können, wenn man mindestens eine
zweite oder vielleicht sogar eine dritte Sprache kennt, sondern dass das

00:06:16,309 --> 00:06:18,559
Erlernen einer weiteren Sprache
auch das Denken prägt.

00:06:18,559 --> 00:06:23,719
Wenn man also eine neue Sprache hat, in der
man sich ausdrücken kann, ist man vielleicht auch offener

00:06:23,719 --> 00:06:28,520
für neue Ideen, und man kann Dinge ausdrücken,
die in der normalen Sprache, die man sonst benutzt, nicht

00:06:28,520 --> 00:06:29,550
so leicht auszudrücken sind.

00:06:29,550 --> 00:06:33,249
Und das Gleiche, würde
ich sagen, gilt für Programmiersprachen.

00:06:33,249 --> 00:06:39,680
Wenn man also eine andere Programmiersprache
lernt, eröffnet das neue Möglichkeiten, in

00:06:39,680 --> 00:06:44,180
Bezug auf Algorithmen zu denken, in
Bezug auf Konstrukte oder Ideen auszudrücken.

00:06:44,180 --> 00:06:52,539
Und das ist selbst dann wertvoll, wenn
anschließend hauptsächlich in einer Sprache programmiert wird.

7 # slide
00:06:52,539 --> 00:06:57,789
Das wird auch von
der jüngeren Geschichte unterstützt.

00:06:57,789 --> 00:07:04,169
Also, was wir hier haben, ist ein Bild von
dem Poster, das ich in meinem alten Büro hatte.

00:07:04,169 --> 00:07:08,729
Und es versucht, die
Geschichte der Programmiersprachen darzustellen.

00:07:08,729 --> 00:07:11,059
Natürlich ist es
kein vollständiges Bild.

00:07:11,059 --> 00:07:14,729
Zum einen, weil es aus
einem Buch von 2004 stammt.

00:07:14,729 --> 00:07:21,689
Es ist also schon ziemlich alt,
wiederum nach den Maßstäben der Informatik.

00:07:21,689 --> 00:07:28,339
Und zum anderen ist es eigentlich ein
Bild hauptsächlich der Programmiersprachen, über die der

00:07:28,339 --> 00:07:31,919
jeweilige Verlag
Bücher veröffentlicht hat.

00:07:31,919 --> 00:07:33,119
Es ist also definitiv nicht vollständig.

00:07:33,119 --> 00:07:34,309
Aber das ist nicht wirklich der Punkt.

00:07:34,309 --> 00:07:39,679
Der Punkt ist, dass es am Anfang nur
ein paar Sprachen gab, die sich entwickelt haben, ...

00:07:39,679 --> 00:07:43,669
Wahrscheinlich ist es gar
nicht so einfach, hier hineinzuzoomen.

00:07:43,669 --> 00:07:48,409
Also, wenn Sie es nicht wissen, sollten
Sie vielleicht tatsächlich recherchieren, was die erste

00:07:48,409 --> 00:07:52,520
Programmiersprache war, die als High-Level-Programmiersprache
anerkannt ist, also nicht nur

00:07:52,520 --> 00:07:53,520
Maschinencode.

00:07:53,520 --> 00:07:57,469
Aber wie auch immer, wie wir auch sehen
können, hat sich das im Laufe der Jahre vermehrt.

00:07:57,469 --> 00:08:00,589
Also, es gibt viele
Sprachen, die sich parallel entwickeln.

00:08:00,589 --> 00:08:05,210
Es gibt auch Verbindungen, wo es
scheint, dass eine Sprache eine andere beeinflusst.

00:08:05,210 --> 00:08:12,779
Das wird hier mit diesen dünnen Linien
angedeutet, die zwischen den verschiedenen Bahnen verlaufen.

00:08:12,779 --> 00:08:17,929
Und natürlich könnten wir fragen: Wenn es
gut genug ist, dass alle C, Java oder

00:08:17,929 --> 00:08:21,459
Python kennen, warum brauchen wir
dann all diese verschiedenen Sprachen?

00:08:21,459 --> 00:08:24,110
Warum gibt es diese
Art der parallelen Entwicklung?

00:08:24,110 --> 00:08:28,059
Aber wir sehen natürlich
auch, dass Sprachen aussterben.

00:08:28,059 --> 00:08:33,469
Es gibt Sprachen, die anfangen, und
nach kurzer Zeit scheinen sie wieder zu verschwinden.

00:08:33,469 --> 00:08:36,560
Und es gibt Sprachen, die
ein sehr langes Leben führen.

00:08:36,560 --> 00:08:39,769
Und wieder könnte die Frage
lauten: Warum ist das so?

00:08:39,769 --> 00:08:49,579
Was zeichnet also Programmiersprachen aus, um langfristig
erfolgreich zu sein oder sehr kurzlebig zu sein?"


8 # slide
00:08:49,579 --> 00:08:59,750
Ein anderes Bild, aus einer anderen
Quelle, mit weniger Sprachen, aber besser.

00:08:59,750 --> 00:09:02,710
sichtbaren Abhängigkeiten und
Vererbungsbeziehungen zwischen ihnen.

00:09:02,710 --> 00:09:05,250
Und interessanterweise
mit einer Farbkodierung.

00:09:05,250 --> 00:09:09,139
Hier sehen wir also
einige Bezeichnungen, die verwendet werden.

00:09:09,139 --> 00:09:15,791
Und das könnten wir schon als Paradigmen-Etiketten
sehen, um anzuzeigen, welche Art von Sprache

00:09:15,791 --> 00:09:18,620
wir in jedem spezifischen Fall haben.

00:09:18,620 --> 00:09:27,850
Und in diesem gelb-grünen Bereich finden
Sie zum Beispiel C, Java, Python: imperative

00:09:27,850 --> 00:09:29,150
und/oder
objektorientierte Programmiersprachen.

00:09:29,150 --> 00:09:35,410
Wohingegen die Sprachen, mit denen wir uns beschäftigen
werden, Haskell und Prolog, in den Farben Rot und

00:09:35,410 --> 00:09:36,410
Blau erscheinen.

00:09:36,410 --> 00:09:42,589
Das deutet also schon darauf hin,
dass sie etwas ganz anderes sein müssen.

00:09:42,589 --> 00:09:45,379
als die meisten Sprachen,
die Sie hier sehen.

00:09:45,379 --> 00:09:50,910
Vielleicht ist es auch interessant für Sie, sich dieses
Bild ein wenig anzuschauen und sich zu fragen, ob

00:09:50,910 --> 00:09:57,670
Sie von mehr als 10 der Sprachen,
die hier erwähnt werden, schon einmal gehört haben.

00:09:57,670 --> 00:10:01,800
Vielleicht zählen Sie,
wie weit Sie kommen.

00:10:01,800 --> 00:10:06,130
Und noch ein anderer Aspekt, der hier interessant
ist, vor allem durch den Titel des Artikels,

00:10:06,130 --> 00:10:09,980
aus dem dieses Bild stammt:
Er heißt "The Semicolon Wars".

00:10:09,980 --> 00:10:16,399
Also, das war ein Artikel in einem
populärwissenschaftlichen Magazin, der eigentlich die Leidenschaft kommentierte,

00:10:16,399 --> 00:10:27,850
die manche Leute für die
Programmiersprachen empfinden, die sie benutzen.

9 # slide
00:10:27,850 --> 00:10:30,120
Das drückt sich
auch in Beliebtheitswettbewerben aus.

00:10:30,120 --> 00:10:35,339
Wir haben Sie in der
Umfrage gefragt, ob Sie eine Lieblings-Programmiersprache haben.

00:10:35,339 --> 00:10:39,709
Natürlich wurden die gleiche Art von
Fragen und Experimenten auch im Internet durchgeführt.

00:10:39,709 --> 00:10:45,939
Hier ist also eine spezifische Auswertung, die jemand
auf der Basis von Suchergebnissen und einigen anderen Datensätzen

00:10:45,939 --> 00:10:47,220
gemacht hat, glaube ich.

00:10:47,220 --> 00:10:49,329
Ein nicht sehr überraschendes Bild.

00:10:49,329 --> 00:10:53,329
Also, C, Java, Python
sind nahe der Spitze.

00:10:53,329 --> 00:10:55,500
Es ist schon ein
paar Jahre alt, dieses Bild.

00:10:55,500 --> 00:11:01,430
Ich vermute, dass Python heutzutage weiter oben
wäre, und vielleicht wären einige neue Einträge

00:11:01,430 --> 00:11:05,170
oder Sprachen wie Swift oder
Rust auch nahe der Spitze.

00:11:05,170 --> 00:11:08,790
Also, hier, vor ein paar Jahren, gab
es noch ein sehr beunruhigendes Vorkommen von PHP.

00:11:08,790 --> 00:11:12,880
Ich weiß nicht, wie
das heute aussehen würde.

00:11:12,880 --> 00:11:21,510
Aber gut, das ist das, was den Leuten
irgendwann mal zu gefallen schien, was Programmiersprachen angeht.

10 # slide
00:11:21,510 --> 00:11:29,440
Und, eine letzte Visualisierung, die interessant
ist, vor allem weil sie interaktiv ist.

00:11:29,440 --> 00:11:34,279
Wenn Sie also dem Link folgen, der dort
unten angegeben ist, gelangen Sie zu einer interaktiven Version

00:11:34,279 --> 00:11:37,730
dieses Bildes, wo
Sie hineinzoomen können.

00:11:37,730 --> 00:11:39,009
Sie können nach Paradigmen filtern.

00:11:39,009 --> 00:11:47,189
Sie können diese Grafik erkunden und zum
Beispiel herausfinden, warum die Punkte für die Sprachen

00:11:47,189 --> 00:11:48,199
hier unterschiedlich groß sind.

00:11:48,199 --> 00:11:54,999
Das ist also ein Maß für den Einfluss,
den Sprachen auf andere Sprachen haben, nach einer bestimmten

00:11:54,999 --> 00:11:55,999
Metrik.

00:11:55,999 --> 00:12:00,079
Und dann ist es zum Beispiel interessant, dass
natürlich C sehr einflussreich ist (hier, der große

00:12:00,079 --> 00:12:07,500
blaue Punkt, den Sie sehen), aber zum
Beispiel auch Haskell scheint mäßig einflussreich zu sein.

00:12:07,500 --> 00:12:10,750
Auch wenn es laut der
vorherigen Folie nicht sehr populär ist.

00:12:10,750 --> 00:12:15,130
Also, Haskell und andere funktionale Sprachen
sind vielleicht nicht die populärsten Sprachen, aber

00:12:15,130 --> 00:12:17,199
sie sind einflussreich.

00:12:17,199 --> 00:12:25,210
Und vielleicht werden Sie im weiteren Verlauf dieses Kurses
in der Lage sein, dies in gewissem Maße zu würdigen.

11 # slide
00:12:25,210 --> 00:12:30,110
Wenn wir all diese Bilder beiseite
lassen, bleibt natürlich eine Frage offen.

00:12:30,110 --> 00:12:32,509
Nämlich, warum gibt es
überhaupt eine solche Vielfalt?

00:12:32,509 --> 00:12:35,310
Warum gibt es
so viele Programmiersprachen?

00:12:35,310 --> 00:12:40,589
Ist es so, dass eine oder vielleicht sogar
jede dieser Sprachen mehr kann als einige andere

00:12:40,589 --> 00:12:45,240
von ihnen, sodass es eine
Daseinsberechtigung für jede einzelne Sprache gibt?

00:12:45,240 --> 00:12:49,130
Oder gibt es Probleme, die sich
in bestimmten Sprachen gar nicht lösen lassen?

00:12:49,130 --> 00:12:53,779
Sodass wir deshalb so viele Sprachen
haben müssen, weil wir so viele Probleme haben?

00:12:53,779 --> 00:12:56,470
Oder gibt es eine beste
Sprache, zumindest für einen bestimmten Zweck?

00:12:56,470 --> 00:13:00,660
Oder gibt es vielleicht keine beste Sprache
insgesamt, aber für einen bestimmten Anwendungsbereich könnte

00:13:00,660 --> 00:13:02,540
es eine beste Sprache geben.

00:13:02,540 --> 00:13:07,220
Und da wir verschiedene Anwendungsbereiche
haben, brauchen wir viele Sprachen?

00:13:07,220 --> 00:13:11,120
Und natürlich auch, was
trennt eigentlich diese verschiedenen Programmiersprachen?



00:13:11,120 --> 00:13:16,850
In welchem Sinne unterscheiden sich zwei dieser
vielen Sprachen voneinander, abgesehen von dem offensichtlichen Unterschied.

00:13:16,850 --> 00:13:22,089
in der Syntax, den man kennt, wenn
man zwei Programme in verschiedenen Sprachen sieht?

00:13:22,089 --> 00:13:26,399
Und natürlich sollten Sie für einige
dieser Fragen bereits die Antworten kennen.

00:13:26,399 --> 00:13:29,600
Oder Teilantworten, zumindest
von der theoretischen Seite.

00:13:29,600 --> 00:13:35,970
Sie wissen zum Beispiel, dass
alle Programmiersprachen letztlich in Maschinencode

00:13:35,970 --> 00:13:37,410
übersetzt werden müssen.

00:13:37,410 --> 00:13:42,170
In diesem Sinne können sie also
nicht mehr tun, als Maschinencode tun kann.

00:13:42,170 --> 00:13:48,329
Wenn Sie den Kurs "Berechenbarkeit
und Komplexität" von Prof. König

00:13:48,329 --> 00:13:54,399
besucht haben, dann wissen Sie auch, dass
es das wichtige Konzept der Turing-Leistung gibt,

00:13:54,399 --> 00:13:58,509
das eine Programmiersprache in
ihrer Ausdruckskraft einer Turing-Maschine entspricht.

00:13:58,509 --> 00:14:03,550
Und praktisch alle Sprachen, die in
den vorherigen Folien auftauchten, sind in

00:14:03,550 --> 00:14:04,550
diesem Sinne Turing-äquivalent.

00:14:04,550 --> 00:14:10,029
Aus theoretischer Sicht ist also keine
von ihnen mächtiger als die anderen.

00:14:10,029 --> 00:14:13,720
Natürlich können sie genau
die gleichen mathematischen Probleme lösen.

00:14:13,720 --> 00:14:18,199
Aber dennoch kann es sein, dass für
ein bestimmtes Anwendungsgebiet eine Sprache einfach viel besser

00:14:18,199 --> 00:14:19,360
geeignet ist.

00:14:19,360 --> 00:14:23,569
Das ist ja auch einer der
Gründe, warum es verschiedene Sprachen gibt.

00:14:23,569 --> 00:14:28,459
Also, einige der Sprachen, die Sie gesehen
haben, oder die erwähnt wurden, wurden praktisch

00:14:28,459 --> 00:14:30,959
für einen
Anwendungsbereich maßgeschneidert.

00:14:30,959 --> 00:14:36,850
Und dann wurde natürlich eine Menge Aufwand betrieben,
um sie für diese Anwendungsdomäne schön nutzbar zu

00:14:36,850 --> 00:14:37,850
machen.

00:14:37,850 --> 00:14:41,529
Und in diesem Sinne sind sie vielleicht sogar
die beste Sprache für einen bestimmten Bereich, auch

00:14:41,529 --> 00:14:45,520
wenn sie theoretisch nicht
mächtiger als andere Sprachen sind.

00:14:45,520 --> 00:14:51,630
Und wenn Sie selbst zwei oder drei
oder vier Programmiersprachen kennen, dann haben Sie natürlich

00:14:51,630 --> 00:15:01,379
auch Ihre eigene Meinung zu einigen
dieser Fragen hier, insbesondere auf der

00:15:01,379 --> 00:15:02,379
praktischen Seite.

12 # slide
00:15:02,379 --> 00:15:07,319
Die letzte Frage von der
vorigen Folie zum Thema "Was trennt/unterscheidet

00:15:07,319 --> 00:15:08,319
verschiedene Programmiersprachen":

00:15:08,319 --> 00:15:13,019
Natürlich kann man sich fragen, was sind
relevante Dimensionen oder Unterscheidungen, die man machen kann?

00:15:13,019 --> 00:15:17,959
Wenn man ein wenig darüber nachdenkt,
dann bieten sich natürlich mehrere Dinge an.

00:15:17,959 --> 00:15:20,210
So kann man zum
Beispiel natürlich die Syntax vergleichen.

00:15:20,210 --> 00:15:25,690
Und zwar nicht nur die konkrete Syntax
(wie die Schlüsselwörter in zwei verschiedenen Sprachen heißen),

00:15:25,690 --> 00:15:30,430
sondern zum Beispiel auch, wie syntaktisch
reich oder syntaktisch arm/knapp die Sprachen

00:15:30,430 --> 00:15:31,430
sind.

00:15:31,430 --> 00:15:37,689
Und zwei typische Sprachen, von denen Sie vielleicht noch
nie etwas gehört haben (oder zumindest nicht von beiden),

00:15:37,689 --> 00:15:39,160
sind APL und Lisp.

00:15:39,160 --> 00:15:42,990
Also, die Sprache heißt
APL für Array Processing Language.

00:15:42,990 --> 00:15:46,420
Sie wurde für mathematische
Berechnungen auf Matrizen usw. verwendet.

00:15:46,420 --> 00:15:49,089
Arrays im allgemeinen Sinne.

00:15:49,089 --> 00:15:56,939
Und das Design dieser Sprache war so, dass sie
eine sehr reiche Syntax im Sinne des Ausdrucks mathematischer

00:15:56,939 --> 00:15:59,959
Konzepte durch
mathematische Symbole hatte.

00:15:59,959 --> 00:16:07,070
Um also effizient in APL zu programmieren,
brauchte man eigentlich eine eigene Tastatur, auf der

00:16:07,070 --> 00:16:11,819
all die speziellen Symbole erscheinen, die
man in einem APL-Programm sehen möchte.

00:16:11,819 --> 00:16:19,480
Und auf der anderen Extremseite des Spektrums steht
Lisp, das ebenfalls ein Vorfahre der funktionalen Programmierung ist.

00:16:19,480 --> 00:16:21,519
In Lisp ist die Syntax sehr einfach.

00:16:21,519 --> 00:16:26,089
Es gibt also nur sehr wenige syntaktische
Konstrukte, im Grunde nur Bezeichner und öffnende

00:16:26,089 --> 00:16:29,110
und schließende Klammern, und
daraus wird alles gemacht.

00:16:29,110 --> 00:16:32,769
Keine speziellen Operatoren,
keine speziellen Symbole etc.

00:16:32,769 --> 00:16:34,250
Also: extreme Unterschiede.

00:16:34,250 --> 00:16:37,879
Natürlich leben viele Sprachen
irgendwo in der Mitte.

00:16:37,879 --> 00:16:41,389
Eine weitere Dimension, die man
betrachten könnte, ist die Ausführlichkeit:

00:16:41,389 --> 00:16:45,790
Braucht man also viel Programmtext,
um eine bestimmte Idee auszudrücken?

00:16:45,790 --> 00:16:51,660
Oder ist es umgekehrt, dass sehr
kurze Programme z.B. mathematische Ideen ausdrücken?

00:16:51,660 --> 00:16:53,029
Und wieder gibt es Extreme:

00:16:53,029 --> 00:16:54,699
So ist COBOL eine sehr alte Sprache.

00:16:54,699 --> 00:16:59,350
Sie wurde im kommerziellen Bereich eingesetzt und
wird auch heute noch in einigen Bereichen verwendet.

00:16:59,350 --> 00:17:05,189
Die Idee von COBOL, als es entworfen wurde,
war, der natürlichen Sprache sehr nahe zu kommen.

00:17:05,189 --> 00:17:10,089
In dem Sinne, dass ein Unternehmensberater in der
Lage wäre, ein COBOL-Programm zu lesen, auch wenn

00:17:10,089 --> 00:17:12,900
er kein Programmierer ist.


"00:17:12,900 --> 00:17:18,100
Das führt also zu
einem sehr ausführlichen Programmtext.

00:17:18,100 --> 00:17:20,549
Und auf der anderen extremen Seite könnte
man Haskell sehen, das wir uns ansehen werden.

00:17:20,549 --> 00:17:28,329
Und Sie werden später sehen, dass eine Menge
Ideen in sehr kurzen Haskell-Programmen ausgedrückt werden können.

00:17:28,329 --> 00:17:32,770
Es gibt Unterschiede in Bezug
darauf, wie Sprachen implementiert werden.

00:17:32,770 --> 00:17:37,650
Natürlich ist es nicht wirklich ein Unterschied der
Sprache selbst, sondern der Art, wie sie verwendet wird.

00:17:37,650 --> 00:17:40,730
Also: Compiler vs. Interpreter.

00:17:40,730 --> 00:17:44,460
Im Prinzip kann jede Sprache
entweder kompiliert oder interpretiert werden.

00:17:44,460 --> 00:17:49,220
Aber es gibt Sprachen, die wirklich
für einen dieser beiden Ausführungsmodi gemacht sind.

00:17:49,220 --> 00:17:52,200
C ist eine
typische, rein kompilierte Sprache.

00:17:52,200 --> 00:17:57,399
Im Gegensatz zu Perl, für das ich
nicht einmal weiß, ob es einen Compiler gibt.

00:17:57,399 --> 00:18:02,350
Das beeinflusst auch nicht nur, wie das Programm
läuft, sondern auch, wie die Entwicklung von Programmen

00:18:02,350 --> 00:18:04,270
in der Sprache funktioniert.

00:18:04,270 --> 00:18:10,250
Zum Beispiel gibt es für Interpreter
unterschiedliche Entwicklungsgewohnheiten, die sich die Leute aneignen.

00:18:10,250 --> 00:18:17,409
Dann kann es Unterschiede geben, ob es eine
sehr domänenspezifische oder eine sehr allgemein gehaltene Sprache

00:18:17,409 --> 00:18:18,409
ist.

00:18:18,409 --> 00:18:22,730
So ist SQL, das Sie vielleicht schon gesehen
haben (oder sehen werden, wenn Sie die Vorlesung

00:18:22,730 --> 00:18:30,130
"Datenbanken" besucht haben), ein sehr
typisches Beispiel für eine domänenspezifische Sprache.

00:18:30,130 --> 00:18:36,789
Selbst SQL ist, obwohl es Turing-äquivalent
ist, immer noch domänenspezifisch im folgenden

00:18:36,789 --> 00:18:37,789
Sinne:

00:18:37,789 --> 00:18:41,210
Sie können zwar alles in SQL programmieren,
aber wofür Sie SQL wirklich verwenden sollten, ist

00:18:41,210 --> 00:18:45,630
der Umgang mit relationalen Datenbanken.

00:18:45,630 --> 00:18:50,750
Dafür ist es gemacht und
dafür kann es sinnvoll eingesetzt werden.

00:18:50,750 --> 00:18:55,990
Im Gegensatz zu Sprachen wie Java, die wirklich
nicht für einen bestimmten Zweck gemacht sind, sondern um

00:18:55,990 --> 00:19:00,279
jede beliebige Anwendung zu programmieren,
an der man interessiert ist.

00:19:00,279 --> 00:19:01,820
Aber dann ist
sie auch nicht spezialisiert.

00:19:01,820 --> 00:19:09,220
Sie kann also alles, aber andere Sprachen sind
besser in den Dingen, für die sie entwickelt wurden.

00:19:09,220 --> 00:19:14,480
Es gibt Unterscheidungen wie Sequenzialität
oder Gleichzeitigkeit/Parallelität, die natürlich zu

00:19:14,480 --> 00:19:17,480
einem gewissen Grad
von Hardware-Entwicklungen getrieben werden.

00:19:17,480 --> 00:19:21,390
Zum Beispiel ist JavaScript
eine typische sequenzielle Sprache.

00:19:21,390 --> 00:19:28,770
Es gibt sogar Probleme, sie parallel
zu verwenden, zum Beispiel in einem Browser.

00:19:28,770 --> 00:19:33,340
Im Gegensatz zu Erlang, das eine Sprache
ist, die für die Netzwerkverarbeitung entwickelt wurde.

00:19:33,340 --> 00:19:39,380
Und von Anfang an, von den allerersten
Ideen an, ist sie auf Nebenläufigkeit und

00:19:39,380 --> 00:19:46,250
Parallelität ausgelegt, um mit paralleler
Hardware oder parallelen Netzwerken zurechtzukommen.

00:19:46,250 --> 00:19:50,440
Eine weitere wichtige Unterscheidung ist die
zwischen typisierten (getypten) und nicht typisierten (ungetypten) Sprachen.

00:19:50,440 --> 00:19:56,440
Und das ist auch ein weiterer
Bereich, in dem Leute Sprachkriege beginnen.

00:19:56,440 --> 00:19:59,490
In diesem Kurs werden
wir interessanterweise beides sehen.

00:19:59,490 --> 00:20:07,190
So ist Haskell ein typisches Beispiel für
eine getypte, und zwar sehr stark getypte, Programmiersprache.

00:20:07,190 --> 00:20:10,919
Und das wird auch im
Kurs selbst eine wichtige Rolle spielen.

00:20:10,919 --> 00:20:16,570
Im Gegensatz zu Prolog, das ein
typisches Beispiel für eine ungetypte Programmiersprache ist.

00:20:16,570 --> 00:20:25,222
Das ist also paradigmenübergreifend, diese
Unterscheidung zwischen getypten und ungetypten Sprachen.

00:20:25,222 --> 00:20:27,390
Es gibt dynamische
und statische Sprachen.

00:20:27,390 --> 00:20:31,920
Es ist nicht so
einfach, diese Unterscheidung zu erfassen.

00:20:31,920 --> 00:20:38,680
Aber es gibt Sprachen, bei denen, egal
ob sie kompiliert oder interpretiert sind, aber hauptsächlich

00:20:38,680 --> 00:20:41,360
gilt das für interpretierte
Sprachen, die sehr dynamisch sind.

00:20:41,360 --> 00:20:48,230
Zur Laufzeit können sich also Dinge ändern, Typen können
sich ändern und die Zusammensetzung von Modulen kann sich ändern.

00:20:48,230 --> 00:20:53,130
Ruby ist ein Beispiel, bei dem
diese dynamische Natur sehr ausgeprägt ist.

00:20:53,130 --> 00:21:00,590
Im Gegensatz zu ML, einer anderen funktionalen Sprache, die
eigentlich für die statische Analyse von Programmen gemacht ist.

00:21:00,590 --> 00:21:06,000
Und dann sollte sich zum Beispiel
ihre Zusammensetzung zur Laufzeit nicht ändern.

00:21:06,000 --> 00:21:10,110
Dann gibt es noch
diese Paradigmen: deklarativ vs. imperativ.

00:21:10,110 --> 00:21:14,350
Und das kam schon früher
in einem der Bilder vor.

00:21:14,350 --> 00:21:19,080
Da hatten wir "deklarativ" als Bezeichnung für
Prolog und "imperativ" als Bezeichnung für C.

00:21:19,080 --> 00:21:24,500
Und ich gehe davon aus, dass die meisten Sprachen,
die Sie bisher gelernt haben, oder die Sie bisher

00:21:24,500 --> 00:21:32,039
benutzt haben, imperative Sprachen sind, ob sie
nun explizit gekennzeichnet wurden oder nicht usw.

00:21:32,039 --> 00:21:36,010
Und dann gibt es
noch dieses Etikett der "Objektorientierung."


00:21:36,010 --> 00:21:39,350
Dazu gibt es
nicht wirklich ein Gegenteil.

00:21:39,350 --> 00:21:45,210
Und ich würde sogar sagen, dass "objektorientiert"
eher etwas ist, das einem Paradigma hinzugefügt wird.

00:21:45,210 --> 00:21:48,970
So sind objektorientierte Sprachen oft imperative
Programmiersprachen, ob sie nun explizit als solche

00:21:48,970 --> 00:21:49,970
gekennzeichnet waren, als man
sie gelernt hat oder nicht.

00:21:49,970 --> 00:21:50,970
Aber das muss nicht der Fall sein.

00:21:50,970 --> 00:21:53,980
Es gibt z.B.
auch objektorientierte funktionale Programmiersprachen.

00:21:53,980 --> 00:21:57,740
Haskell gehört nicht dazu, also
werden wir das auch nicht betrachten.

00:21:57,740 --> 00:22:04,059
Aber Objektorientierung ist etwas anderes als ein
Paradigma, und es wird in diesem Kurs

00:22:04,059 --> 00:22:06,399
keine Rolle spielen.

00:22:06,399 --> 00:22:12,810
Es könnten noch andere Unterscheidungen getroffen werden, aber
das sind nur einige Beispiele, um Sie vielleicht auch

00:22:12,810 --> 00:22:15,280
dazu zu bringen, über die
Sprachen nachzudenken, die Sie bereits kennen.

00:22:15,280 --> 00:22:23,370
Wie sie in
diese verschiedenen Unterscheidungen fallen.

13 # slide
00:22:23,370 --> 00:22:27,350
Trotz all dieser Unterschiede, die auf der vorherigen
Folie erwähnt wurden, gibt es natürlich auch gemeinsame

00:22:27,350 --> 00:22:31,059
Prinzipien, die den
verschiedenen Programmiersprachen zugrunde liegen.

00:22:31,059 --> 00:22:36,019
Wenn wir zum Beispiel eine Programmiersprache haben, müssen
wir in der Lage sein, die Syntax und

00:22:36,019 --> 00:22:39,860
Semantik zu beschreiben und
natürlich auch Implementierungsstrategien zu diskutieren.

00:22:39,860 --> 00:22:44,950
Das sind Dinge, die wir in diesem Kurs
nicht so sehr in den Vordergrund rücken werden.

00:22:44,950 --> 00:22:48,510
Natürlich müssen wir über
Syntax und Semantik sprechen.

00:22:48,510 --> 00:22:52,640
Aber wir werden das nicht sehr formal
tun, und wir werden keine Sprachen implementieren.

00:22:52,640 --> 00:23:00,170
Diese Aspekte sind also Dinge,
die z.B. in der Vorlesung "Compilerbau"

00:23:00,170 --> 00:23:05,840
vorkommen, die ich im Masterstudiengang
halte, aber nicht im Bachelorstudiengang.

00:23:05,840 --> 00:23:11,820
Noch ein Hinweis: Es gibt natürlich
Sprachkonzepte, die auch in verschiedenen Sprachen

00:23:11,820 --> 00:23:15,590
vorkommen und vielleicht auch
in verschiedenen Sprachen unterschiedlich vorkommen.

00:23:15,590 --> 00:23:19,780
So hat z.B. jede Programmiersprache,
die ich kenne, Variablen und einige

00:23:19,780 --> 00:23:20,780
Bindungskonstrukte.

00:23:20,780 --> 00:23:22,680
Aber die Rolle kann unterschiedlich sein.

00:23:22,680 --> 00:23:28,580
Wie Sie sehen werden, sind Variablen in Haskell
etwas völlig anderes als Variablen in C oder

00:23:28,580 --> 00:23:29,580
Java.

00:23:29,580 --> 00:23:31,630
Und in Prolog ist
es wieder eine andere Geschichte.

00:23:31,630 --> 00:23:34,880
Also, es gibt Variablen, aber
ihre Rolle ist eine andere.

00:23:34,880 --> 00:23:40,230
Und in ähnlicher Weise gibt es Konstrukte wie
die Typisierung, die wiederum eine andere Rolle in

00:23:40,230 --> 00:23:42,480
verschiedenen Sprachen spielen, wenn
die Sprachen überhaupt getypt sind.

00:23:42,480 --> 00:23:48,210
Java ist also eine getypte Programmiersprache, aber
die Typen dort unterscheiden sich deutlich von den

00:23:48,210 --> 00:23:50,760
Typen in Haskell, zum Beispiel.

00:23:50,760 --> 00:23:57,409
Und ebenso Kontrollstrukturen, wie Programme
organisiert sind, Abstraktionsmerkmale, wie man

00:23:57,409 --> 00:23:58,740
Programme modularisiert.

00:23:58,740 --> 00:24:04,700
Das ist in allen Sprachen wichtig,
aber es ist in verschiedenen Sprachen unterschiedlich.

00:24:04,700 --> 00:24:12,299
Und wir werden versuchen, das auch nach
vorne zu bringen, indem wir solche Unterscheidungen diskutieren.

00:24:12,299 --> 00:24:17,500
Es gibt diese Idee, Sprachen
nach den Paradigmen zu bezeichnen.

00:24:17,500 --> 00:24:23,200
Wir sagen also, dass Java und C imperative
Sprachen sind, und Haskell und ML sind zum

00:24:23,200 --> 00:24:24,630
Beispiel funktionale Sprachen.

00:24:24,630 --> 00:24:31,440
Eigentlich ist es nicht ganz einfach, dies zu
definieren, aber die Aspekte, die hier diskutiert und

00:24:31,440 --> 00:24:34,600
auf der Folie erwähnt wurden,
tragen zu diesen Unterscheidungen bei.

00:24:34,600 --> 00:24:40,899
Auf jeden Fall kann man solche Aspekte am
besten einschätzen, wenn man mehrere verschiedene Sprachen kennt.

00:24:40,899 --> 00:24:44,190
Und das ist eines
der Ziele dieses Kurses.

14 # slide
00:24:44,190 --> 00:24:48,590
Was ist also der
Plan für diese Vorlesung?

00:24:48,590 --> 00:24:53,860
Wir werden uns auf zwei
Paradigmen konzentrieren: funktionale und logische Programmierung.

00:24:53,860 --> 00:25:00,019
Ich gehe davon aus, dass dies zwei neue
Paradigmen für die meisten von Ihnen sind, und das

00:25:00,019 --> 00:25:03,000
wird auch durch
die bisherigen Umfrageergebnisse bestätigt.

00:25:03,000 --> 00:25:09,669
Wir werden zwei bestimmte Sprachen auswählen: Haskell
für die funktionale Programmierung und Prolog für die

00:25:09,669 --> 00:25:11,760
logische Programmierung.

00:25:11,760 --> 00:25:14,840
Im Fall der funktionalen Programmierung
hätten wir eine Wahl gehabt.

00:25:14,840 --> 00:25:22,260
So gibt es eine lange Geschichte
und auch verschiedene Beispielsprachen für funktionale Programmierung.

00:25:22,260 --> 00:25:28,559
Und wir haben uns für Haskell entschieden, weil es
uns erlaubt, alle Aspekte, die wir abdecken wollen, zu

00:25:28,559 --> 00:25:29,559
diskutieren.

00:25:29,559 --> 00:25:33,940
Und auf der Prolog-Seite ist die Situation
ein wenig anders, weil Prolog wirklich die einzige

00:25:33,940 --> 00:25:37,420
große logische Programmiersprache
ist, die überhaupt existiert.

00:25:37,420 --> 00:25:43,630
Es gibt also nicht viel Auswahl,
um eine andere logische Programmiersprache zu nehmen.



00:25:43,630 --> 00:25:51,130
In beiden Fällen betrachten wir die eigentlichen Programmierkonzepte,
und wir werden auch Aspekte diskutieren, die mit

00:25:51,130 --> 00:25:52,370
der Semantik zusammenhängen.

00:25:52,370 --> 00:25:55,519
Also, Auswertung im Fall von
Haskell, Auflösung im Fall von Prolog.

00:25:55,519 --> 00:26:01,820
Einiges davon wird Ihnen bereits
aus der "Logik"-Vorlesung bekannt sein.

00:26:01,820 --> 00:26:05,279
Bei Haskell beschäftigen
wir uns mit Typkonzepten.

00:26:05,279 --> 00:26:08,809
Ich habe bereits erwähnt, dass
Haskell eine sehr starke Typdisziplin hat.

00:26:08,809 --> 00:26:16,659
Das erlaubt uns, Aspekte wie: Inferenz, Generizität,
Polymorphismus in einer disziplinierteren Art und Weise

00:26:16,659 --> 00:26:21,160
zu diskutieren, als es z. B. mit einer
Sprache wie Java möglich wäre (obwohl es auch

00:26:21,160 --> 00:26:23,070
eine getypte Sprache ist).

00:26:23,070 --> 00:26:25,960
Für Prolog spielen Typen keine Rolle.

00:26:25,960 --> 00:26:30,909
Und in jedem Fall werden wir Konzepte diskutieren und
vergleichen, wie ich bereits auf der vorherigen Folie erwähnt

00:26:30,909 --> 00:26:37,039
habe: Variablen, die Unterscheidung zwischen Ausdrücken
und Befehlen, und andere Aspekte über

00:26:37,039 --> 00:26:42,490
Sprachen hinweg (sowohl über Haskell und Prolog
hinweg, als auch im Vergleich zu imperativen

00:26:42,490 --> 00:26:44,800
Programmiersprachen).

15 # slide
00:26:44,800 --> 00:26:54,470
Bevor ich über mögliche Literatur spreche, in
zwei Folien, zunächst ein paar abschließende Bemerkungen

00:26:54,470 --> 00:26:56,049
zur Motivation.

00:26:56,049 --> 00:27:02,070
Oder eigentlich, zuerst, ein paar
Kommentare zum Begriff der deklarativen Programmierung.

00:27:02,070 --> 00:27:08,960
Diese Bezeichnung kam schon in einer der
früheren Abbildungen als Unterscheidung von Prolog vor.

00:27:08,960 --> 00:27:15,130
Eigentlich wird deklarative (oder auch deskriptive)
Programmierung oft als Überbegriff für sowohl

00:27:15,130 --> 00:27:19,380
funktionale als auch
logische Programmierung verwendet.

00:27:19,380 --> 00:27:25,389
Der Grund dafür ist, dass sie die Idee
teilen, dass Programmierer mehr in Begriffen des "Was"

00:27:25,389 --> 00:27:26,519
statt des "Wie" denken sollten.

00:27:26,519 --> 00:27:33,570
Ursprünglich also die Idee, dass die Programmierung
mehr aus der Spezifikation eines Problems bestehen sollte,

00:27:33,570 --> 00:27:38,549
als aus der Planung eines
bestimmten Berechnungsprozesses in einzelnen Schritten.

00:27:38,549 --> 00:27:46,669
Dann kam in gewisser Weise
die logische Programmierung in Mode.

00:27:46,669 --> 00:27:48,100
Diese war noch anspruchsvoller.

00:27:48,100 --> 00:27:51,960
Die Idee war damals, dass Programmierer
sich überhaupt keine Gedanken über Berechnungsprozesse machen

00:27:51,960 --> 00:27:52,960
sollten.

00:27:52,960 --> 00:27:58,450
Sie sollten nur spezifizieren und
das würde irgendwie alle Probleme lösen.

00:27:58,450 --> 00:28:00,539
Das war etwas überambitioniert.

00:28:00,539 --> 00:28:08,809
Aber die allgemeine Idee, sich mehr auf
die Spezifikation von Problemen zu konzentrieren als auf

00:28:08,809 --> 00:28:16,090
deren detaillierte Lösung/Berechnung, hat in Form
der funktionalen und logischen Programmierung überlebt.

00:28:16,090 --> 00:28:18,630
Das bedeutet natürlich nicht, dass
irgendeine Magie im Spiel ist.

00:28:18,630 --> 00:28:23,380
Es ist also immer noch notwendig,
dass der Programmierer über Algorithmen nachdenkt.

00:28:23,380 --> 00:28:26,440
Und das ist natürlich
eine gute und nützliche Sache.

00:28:26,440 --> 00:28:31,490
Aber ich denke, dass es
in einer deklarativen Umgebung schöner ist.

00:28:31,490 --> 00:28:32,630
Warum ist das so?

00:28:32,630 --> 00:28:40,029
Das liegt vor allem daran, dass die deklarative
Programmierung in der Regel auf einem hohen Niveau

00:28:40,029 --> 00:28:42,909
stattfindet und sich
etwas mathematisch anfühlt.

00:28:42,909 --> 00:28:48,480
Im Fall der logischen Programmierung ist
der mathematische Aspekt natürlich die Logik.

00:28:48,480 --> 00:28:53,269
Im Fall der funktionalen Programmierung hingegen ist
die Mathematik, um die es geht, hauptsächlich die

00:28:53,269 --> 00:28:59,590
Algebra: der Umgang mit
Ausdrücken und deren Transformationen.

00:28:59,590 --> 00:29:08,559
Das führt zu Behauptungen und oft zu
Beobachtungen, dass funktionale oder logische Programme kürzer (bis

00:29:08,559 --> 00:29:16,309
zu einem gewissen Grad), lesbarer (wenn man die
Sprachen kennt) und häufiger korrekt sind, als Programme,

00:29:16,309 --> 00:29:18,850
die in einem
konventionellen Stil geschrieben sind.

00:29:18,850 --> 00:29:24,309
Und ein Grund dafür ist, dass die
Ausführung und das Denken über Programme in einer

00:29:24,309 --> 00:29:30,590
deklarativen oder beschreibenden Sprache viel näher beieinander
liegen als in einer normalen imperativen Sprache.

00:29:30,590 --> 00:29:39,140
Wir werden dies auch diskutieren, wenn wir
Beobachtungen über Ausdrücke, Befehle und andere Sprachkonstrukte

00:29:39,140 --> 00:29:40,140
machen.

00:29:40,140 --> 00:29:43,290
Wie sie in
den verschiedenen Paradigmen ausfallen.

00:29:43,290 --> 00:29:48,320
Ein Nebeneffekt von deklarativen Sprachen ist,
dass sie oft eine reduzierte Syntax haben.

00:29:48,320 --> 00:29:55,050
Das hat natürlich mit all den Beobachtungen zu
tun, die ich über kürzere Programme gemacht habe.

00:29:55,050 --> 00:30:01,570
Aber auch die Art und Weise, wie
Programme ausgedrückt werden, ist oft konzeptionell einfacher.

00:30:01,570 --> 00:30:06,429
Denn es gibt z. B.
weniger Schlüsselwörter, dafür aber eine reichhaltigere

00:30:06,429 --> 00:30:07,429
Ausdruckssprache.

00:30:07,429 --> 00:30:15,620
Aber das werden wir sehen,
wenn wir auf Beispiele stoßen.

16 # slide
00:30:15,620 --> 00:30:23,130
Warum sollten Sie sich letztlich
überhaupt mit diesen neuen Paradigmen beschäftigen?



00:30:23,130 --> 00:30:30,700
Nun, eine einfache und vielleicht etwas unbefriedigende Antwort
ist, dass dies für viele von Ihnen ein

00:30:30,700 --> 00:30:31,720
Pflichtfach ist.

00:30:31,720 --> 00:30:37,110
Sie müssen sich also einfach mit diesem
Material beschäftigen, um die erforderlichen Credits zu bekommen.

00:30:37,110 --> 00:30:41,899
Ein tieferer Grund ist, dass das
Erlernen verschiedener Sprachen es Ihnen später leichter

00:30:41,899 --> 00:30:43,889
machen wird, neue Sprachen zu lernen.

00:30:43,889 --> 00:30:50,490
Es ist sehr unwahrscheinlich, dass Sie
während Ihrer Karriere als Informatiker nie wieder

00:30:50,490 --> 00:30:52,340
eine neue Sprache lernen müssen.

00:30:52,340 --> 00:30:56,100
Viel wahrscheinlicher ist, dass Sie alle
paar Jahre neue Sprachen lernen müssen.

00:30:56,100 --> 00:31:00,289
Nicht nur syntaktisch neue
Sprachen, sondern auch neue Sprachideen.

00:31:00,289 --> 00:31:03,470
Dann hilft dieser
Kurs, Sie darauf vorzubereiten.

00:31:03,470 --> 00:31:10,179
Auch haben in der Vergangenheit immer
wieder bestimmte Features und Konzepte aus

00:31:10,179 --> 00:31:15,590
Sprachen, die einst als eher exotisch
galten, ihren Weg in gängigere Programmiersprachen gefunden.

00:31:15,590 --> 00:31:17,290
Und das wird
wahrscheinlich auch wieder passieren.

00:31:17,290 --> 00:31:23,400
Beispiele aus der Vergangenheit wären
die Comprehension-Syntax oder Lambda-Ausdrücke, die

00:31:23,400 --> 00:31:28,629
in Sprachen wie Java übernommen wurden.

00:31:28,629 --> 00:31:33,899
Außerdem gibt es in einigen
Anwendungsdomänen eine erhöhte Nachfrage nach mathematikbasierten

00:31:33,899 --> 00:31:38,570
Sprachen, nach disziplinierten
und konzeptionell ausdrucksstarken Sprachen.

00:31:38,570 --> 00:31:43,490
Das gilt zum Beispiel für Domänen,
in denen die formale Verifikation immer wichtiger

00:31:43,490 --> 00:31:44,490
wird.

00:31:44,490 --> 00:31:50,030
Es zeigt sich, dass sowohl logische als
auch funktionale Programme leichter zu verifizieren sind.

00:31:50,030 --> 00:31:57,679
Generell, wie bereits erwähnt, erhöht
die Kenntnis neuer oder weiterer Paradigmen

00:31:57,679 --> 00:31:59,590
die Fähigkeit, Ideen auszudrücken.

00:31:59,590 --> 00:32:06,990
Selbst wenn Sie also in der Praxis nie
wieder funktionale oder logische Programme schreiben werden, werden die

00:32:06,990 --> 00:32:13,840
Ideen, die Sie bei der Beschäftigung mit diesem
Material erwerben, hoffentlich Ihre Reichweite auch in anderen

00:32:13,840 --> 00:32:15,190
Sprachen erhöhen.

00:32:15,190 --> 00:32:22,460
Und schließlich ist ein Aspekt, dass Sie,
wenn Sie im weiteren Verlauf Ihres Studiums eine

00:32:22,460 --> 00:32:28,740
Bachelor- oder Masterarbeit in meiner Gruppe schreiben
wollen, sehr wahrscheinlich das Material aus diesem Kurs

00:32:28,740 --> 00:32:29,769
verwenden müssen.

00:32:29,769 --> 00:32:36,629
Ich würde also schätzen, dass in 90 %
der Fälle, in denen ein/e Studierende/r eine Bachelorarbeit

00:32:36,629 --> 00:32:41,600
in meiner Gruppe schreiben
will, er Haskell verwenden muss.

17 # slide
00:32:41,600 --> 00:32:48,279
Wie ich am Anfang des Videos erwähnt habe, möchte
ich mit ein paar Worten über Literatur schließen, insbesondere

00:32:48,279 --> 00:32:51,679
über Bücher, die Sie
für den Kurs verwenden können.

00:32:51,679 --> 00:32:57,440
Eine Sache, die ich sagen muss, ist, dass es
nicht ein bestimmtes Buch gibt, das genau diesen Kurs

00:32:57,440 --> 00:32:58,440
abdeckt.

00:32:58,440 --> 00:33:04,120
Es gibt also kein Buch "Programmierparadigmen",
das irgendwie genau dem Kurs entsprechen

00:33:04,120 --> 00:33:05,330
würde, den ich gebe.

00:33:05,330 --> 00:33:09,390
Aber es gibt mehrere Bücher, sowohl für
den Haskell- als auch für den Prolog-Teil, die

00:33:09,390 --> 00:33:10,750
nützlich wären.

00:33:10,750 --> 00:33:16,879
Alle Bücher, die ich auf den nächsten beiden
Folien erwähnen werde, sind in unserer Bibliothek verfügbar.

00:33:16,879 --> 00:33:22,690
Natürlich ist das für Sie in der aktuellen
Situation nur von begrenztem Nutzen, aber das könnte

00:33:22,690 --> 00:33:23,809
sich in ein paar Wochen ändern.

00:33:23,809 --> 00:33:26,139
Vielleicht öffnet die
Bibliothek dann wieder zuverlässiger.

00:33:26,139 --> 00:33:31,100
Und auch in der Zwischenzeit gibt es
bestimmte Bücher, die auch online verfügbar sind.

00:33:31,100 --> 00:33:35,610
Und tatsächlich habe ich die Bibliothek letztes
Jahr gebeten, ein paar mehr E-Books anzuschaffen.

00:33:35,610 --> 00:33:47,840
Es sollte also zusätzliche
Möglichkeiten/Verfügbarkeit von E-Books geben.

18 # slide
00:33:47,840 --> 00:33:54,350
Auf der Haskell-Seite ist das Buch, das wahrscheinlich dem,
was ich in diesem Kurs mache, am nächsten kommt,

00:33:54,350 --> 00:33:56,309
das Buch "Programming in
Haskell" von Graham Hutton.

00:33:56,309 --> 00:33:57,830
Es gibt eine erste
und eine zweite Auflage.

00:33:57,830 --> 00:34:02,679
Ich habe hier die zweite Auflage erwähnt, aber
eigentlich ist die erste Auflage auch sehr nützlich für

00:34:02,679 --> 00:34:03,679
den Kurs.

00:34:03,679 --> 00:34:06,380
Sie können also
beide Ausgaben verwenden.

00:34:06,380 --> 00:34:13,270
Dann gibt es noch ein umfangreicheres und
viel dickeres Buch von Simon Thompson: "Haskell

00:34:13,270 --> 00:34:14,780
- The Craft of Functional Programming".

00:34:14,780 --> 00:34:21,630
Es ist bereits in der dritten Auflage, und
es enthält all die Dinge, die wir auf

00:34:21,630 --> 00:34:23,200
der konzeptionellen
Haskell-Seite machen werden.

00:34:23,200 --> 00:34:26,010
Und es deckt darüber
hinaus eine Menge ab.

00:34:26,010 --> 00:34:31,530
Es deckt also definitiv mehr Material
ab, als wir in diesem Kurs machen.

00:34:31,530 --> 00:34:36,400
Dann gibt es dieses sehr
schöne Buch, "Thinking Functionally with Haskell".

00:34:36,400 --> 00:34:42,070
Darin wird ein etwas mathematischerer Ansatz für
die Programmierung in Haskell gewählt, der vielleicht nicht.



00:34:42,070 --> 00:34:44,770
für alle Leser geeignet ist.

00:34:44,770 --> 00:34:51,250
Aber vielleicht gibt es einige unter Ihnen, die
von dieser Art der Herangehensweise profitieren und profitieren würden.

00:34:51,250 --> 00:34:57,600
Dann, wenn Sie ein deutsches Buch bevorzugen
(denn alle anderen drei bisher genannten Bücher sind

00:34:57,600 --> 00:35:03,310
englische Bücher), gibt es dieses
Buch: "Haskell-Intensivkurs" von diesen beiden Autoren.

00:35:03,310 --> 00:35:10,490
Und beides, das Buch von Richard Bird und
"Haskell-Intensivkurs", sind Bücher, die Sie bereits jetzt online und

00:35:10,490 --> 00:35:11,600
kostenlos lesen können.

00:35:11,600 --> 00:35:20,130
Wenn Sie sich aus dem
Universitätsnetz oder per VPN einloggen.

00:35:20,130 --> 00:35:22,660
Und es gibt noch ein weiteres
deutsches Buch, aber es ist vergriffen.

00:35:22,660 --> 00:35:27,490
Es ist also in der Bibliothek vorhanden, aber
ich bin mir nicht sicher, ob Sie es anderswo

00:35:27,490 --> 00:35:29,550
finden, wenn Sie zum
Beispiel ein Buch kaufen wollen.

00:35:29,550 --> 00:35:35,250
Und insgesamt finden Sie im Moodle-Kurs sowohl
für den Haskell- als auch für den Prolog-Teil

00:35:35,250 --> 00:35:45,290
einige Links zu weiteren Büchern aus
der Bibliothek, in denen Sie stöbern können.

19 # slide
00:35:45,290 --> 00:35:49,540
Für den Prolog-Teil des Kurses
würde ich hauptsächlich dieses Buch empfehlen.

00:35:49,540 --> 00:35:53,530
Es ist auch ein Buch,
das kostenlos online verfügbar ist.

00:35:53,530 --> 00:35:57,750
Sie können es also online lesen,
aber Sie können auch eine Papierversion bestellen.

00:35:57,750 --> 00:36:01,350
Und es sollte auch
Exemplare in der Bibliothek geben.

00:36:01,350 --> 00:36:07,110
Und es gibt tatsächlich sehr viele weitere
Prolog-Bücher in der Bibliothek, sowohl in Englisch als

00:36:07,110 --> 00:36:08,790
auch in Deutsch.

00:36:08,790 --> 00:36:15,570
Einige von ihnen sind ziemlich alt, und die meisten von
ihnen decken viel mehr Material ab, als wir in diesem

00:36:15,570 --> 00:36:16,570
Kurs machen werden.

00:36:16,570 --> 00:36:20,790
Aber natürlich wären sie trotzdem nützlich, auch
um die einführenden Konzepte zu lernen, mit

00:36:20,790 --> 00:36:29,470
denen wir uns beschäftigen werden.

