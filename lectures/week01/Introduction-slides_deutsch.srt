2 # slide
00:00:18,810 --> 00:00:24,470
Ich werde nun über die Motivation für diesen Kurs
sprechen, worum es bei Programmierparadigmen geht.

00:00:24,470 --> 00:00:29,590
Und worauf wir uns dieses Jahr, wie auch in den
vergangenen Jahren, speziell konzentrieren werden.

00:00:29,590 --> 00:00:32,820
Und ich werde auch einige Literatur nennen,
die Sie vielleicht verwenden möchten.

00:00:32,820 --> 00:00:38,760
Zunächst möchte ich ein paar Ergebnisse der
Moodle-Umfrage zeigen, die wir 2019 durchgeführt haben.

00:00:38,760 --> 00:00:43,540
Wahrscheinlich haben Sie die aktuelle Moodle-Umfrage
schon gesehen oder daran teilgenommen.

00:00:43,540 --> 00:00:50,260
Aber da die Ergebnisse daraus noch nicht vollständig
sind, werde ich stattdessen ein paar Ergebnisse aus 2019

00:00:50,260 --> 00:00:52,020
zeigen und ein wenig darüber sprechen.

00:00:52,020 --> 00:00:57,860
Und ich denke, dass einige der Aspekte in Ihren
Antworten ähnlich sein werden, wenn sie für

00:00:57,860 --> 00:01:01,290
den aktuellen Kurs abgeschlossen sind.

3 # slide
00:01:01,290 --> 00:01:07,479
Eine Frage, die wir gestellt haben, ist die nach der Sprache, in
der die Studierenden den Kurs "Grundlegende Programmiertechniken"

00:01:07,479 --> 00:01:08,530
absolviert haben.

00:01:08,530 --> 00:01:14,080
Das ist also eine Frage, die nur für die
Studierenden der "Angewandten Informatik" Sinn

00:01:14,080 --> 00:01:17,570
macht, weil sie für die ISE-Studierenden
nicht wirklich zutrifft.

00:01:17,570 --> 00:01:23,490
Für uns ist diese Frage relevant, da ich an einigen
Stellen im Kurs Vergleiche zwischen Sprachkonstrukten

00:01:23,490 --> 00:01:28,630
von neuen Sprachen, die Sie lernen werden,
und Sprachen, von denen wir erwarten,

00:01:28,630 --> 00:01:30,990
dass Sie sie
bereits kennen, anstellen werde.

00:01:30,990 --> 00:01:40,020
Wir wissen natürlich auch, dass die GPT-Vorlesung von der
Vermittlung von Java auf die Vermittlung von Python hauptsächlich

00:01:40,020 --> 00:01:41,310
umgestellt hat.

00:01:41,310 --> 00:01:46,650
Im Jahr 2019 war es, wie Sie hier sehen, noch
so, dass zwei Drittel der Studierenden in

00:01:46,650 --> 00:01:52,190
unserem Kurs GPT
mit Java-Vorlesungen hatten.

00:01:52,190 --> 00:01:57,170
Ich gehe davon aus, dass sich dieses
Verhältnis nun etwas verändert hat.

00:01:57,170 --> 00:02:02,570
Aber auch aus den ersten Antworten in der Umfrage,
die wir schon sehen konnten, ist es auch so,

00:02:02,570 --> 00:02:06,729
dass es immer noch recht viele Studierende gibt,
für die Java die Sprache war, die Sie in GPT

00:02:06,729 --> 00:02:07,729
gelernt haben.

00:02:07,729 --> 00:02:10,759
Wir werden also tatsächlich
versuchen, beidem gerecht zu werden.

00:02:10,759 --> 00:02:18,870
Wir werden solche Vergleiche so ansprechen, dass
Sie, egal ob Ihre erste oder dominante imperative

00:02:18,870 --> 00:02:23,580
Programmiersprache Java oder Python ist, in
der Lage sein sollten, die Vergleiche, die

00:02:23,580 --> 00:02:27,290
ich anstellen werde, zu schätzen.

4 # slide
00:02:27,290 --> 00:02:33,560
Dann haben wir auch danach gefragt, in welcher
Sprache sich die Studierenden am sichersten fühlen.

00:02:33,560 --> 00:02:39,610
Das heißt, welche Sprache sie am besten beherrschen
oder mit der sie am sichersten umgehen können.

00:02:39,610 --> 00:02:41,530
Nicht alle Studierenden
gaben darauf eine Antwort.

00:02:41,530 --> 00:02:47,970
Aber unter denjenigen, die eine Antwort gegeben haben, ist es
wahrscheinlich nicht sehr überraschend, wenn wir bedenken, dass die

00:02:47,970 --> 00:02:55,120
meisten Studierenden vorher Java in GPT gelernt haben,
dass auch hier Java die am häufigsten genannte Sprache

00:02:55,120 --> 00:02:56,120
war.

00:02:56,120 --> 00:03:03,340
Und natürlich ist auch wieder Python dabei,
wahrscheinlich oft von Schülern, die GPT

00:03:03,340 --> 00:03:06,730
mit Python-Code gelernt haben.

00:03:06,730 --> 00:03:09,069
Aber dann kommt auch noch C ins Spiel.

00:03:09,069 --> 00:03:14,530
Und das könnten sowohl die ISE-Studierenden sein, für
die C in ihrer ersten Programmiervorlesung verwendet

00:03:14,530 --> 00:03:15,530
wird.

00:03:15,530 --> 00:03:19,470
Das könnten aber eigentlich auch Schüler sein, die
C an anderen Stellen gelernt haben, zum Beispiel in

00:03:19,470 --> 00:03:20,470
der Schule.

00:03:20,470 --> 00:03:25,379
Mein Sohn, in der 10. Klasse, hat C in der
Schule in den Informatik-Vorlesungen gelernt.

00:03:25,379 --> 00:03:29,200
Das ist also auch hier eine Möglichkeit.

00:03:29,200 --> 00:03:36,480
Jedenfalls sind es jetzt, wie wir sehen,
mehr als 80 % für diese drei Sprachen.

00:03:36,480 --> 00:03:40,060
Und wahrscheinlich wird das Bild
auch dieses Mal ähnlich sein.

00:03:40,060 --> 00:03:46,159
Und selbst unter den Sprachen, die genannt
wurden, sind die meisten Sprachen imperative

00:03:46,159 --> 00:03:47,159
Programmiersprachen.

00:03:47,159 --> 00:03:51,940
Sie unterscheiden sich also definitiv von der Art
von Sprachen, die in diesem Kurs behandelt werden.

00:03:51,940 --> 00:03:58,709
Das ist natürlich der Hauptpunkt
dieses Programmierparadigmen-Kurses.

00:03:58,709 --> 00:04:03,170
Dass etwas anderes gelernt wird als das, was
schon aus den ersten Programmierkursen oder

00:04:03,170 --> 00:04:06,140
auf anderen Wegen bekannt ist.

5 # slide
00:04:06,140 --> 00:04:13,319
Eine weitere Frage, die wir gestellt haben, war, ob die
Studierenden eine Lieblingsprogrammiersprache haben, und

00:04:13,319 --> 00:04:14,659
welche das ist.

00:04:14,659 --> 00:04:18,519
Auf diese Frage haben die wenigsten
Studierenden eine Antwort gegeben.

00:04:18,519 --> 00:04:24,910
Und wie Sie auf dem letzten Bild sehen
können, wird es nun etwas vielfältiger.

00:04:24,910 --> 00:04:33,349
Aber alles ist immer noch sehr stark auf
C/Java-ähnliche Sprachen oder Python ausgerichtet.

00:04:33,349 --> 00:04:38,710
Etwa 15 Studierende im Jahr 2019 gaben an, dass sie
einige Erfahrung mit funktionaler Programmierung haben.

00:04:38,710 --> 00:04:43,490
Und eine ähnliche Anzahl erwähnte
dasselbe für logische Programmierung.

00:04:43,490 --> 00:04:48,800
Ich glaube nicht, dass irgendjemand eine funktionale oder
logische Programmiersprache als seine Lieblingsprogrammiersprache

00:04:48,800 --> 00:04:50,750
genannt hat.

00:04:50,750 --> 00:04:54,000
Mein Ziel ist es nicht unbedingt,
dies mit diesem Kurs zu ändern.

00:04:54,000 --> 00:04:58,070
Aber zumindest sollten Sie etwas Neues lernen,
zusätzlich zu den Dingen, die Sie bereits

00:04:58,070 --> 00:04:59,070
kennen.

00:04:59,070 --> 00:05:03,349
Also, weder Haskell noch Prolog, die beiden
Sprachen, die Sie lernen werden, müssen Ihre neue

00:05:03,349 --> 00:05:04,349
Lieblingssprache werden.

00:05:04,349 --> 00:05:11,039
Aber zumindest sollten Sie etwas Neues lernen,
das Sie vielleicht später in anderen Sprachen, die

00:05:11,039 --> 00:05:15,990
Sie benutzen werden, anwenden können.

6 # slide
00:05:15,990 --> 00:05:21,779
Natürlich könnten Sie an dieser Stelle fragen, warum
Sie eine weitere Programmiersprache lernen müssen.

00:05:21,779 --> 00:05:25,949
Es scheint, dass alle von Ihnen schon
einmal programmieren gelernt haben.

00:05:25,949 --> 00:05:30,909
Und viele von Ihnen haben mindestens eine
Programmiersprache, in der sie sich sicher fühlen.

00:05:30,909 --> 00:05:32,830
Also, warum sollte das nicht ausreichen?

00:05:32,830 --> 00:05:36,599
Warum müssen Sie weitere
Programmiersprachen lernen?

00:05:36,599 --> 00:05:42,469
Nun, an dieser Stelle wiederhole ich gerne dieses Zitat
eines mittelalterlichen Königs: "Eine weitere Sprache zu

00:05:42,469 --> 00:05:44,569
kennen, bedeutet, eine
zweite Seele zu haben."

00:05:44,569 --> 00:05:50,830
In Anbetracht der Zeit, in der dies gesagt wurde,
bezieht es sich natürlich nicht auf Programmiersprachen.

00:05:50,830 --> 00:05:55,860
Es bezieht sich also auf natürliche
Sprachen, die Menschen sprechen.

00:05:55,860 --> 00:05:59,809
Und es war zu einer Zeit, als es noch nicht so
üblich war wie heute, dass Menschen mehr als

00:05:59,809 --> 00:06:03,039
eine Sprache beherrschen.

00:06:03,039 --> 00:06:10,029
Und was Karl der Große hier erkannt oder
ausgedrückt hat, ist, dass es nicht nur darum geht,

00:06:10,029 --> 00:06:16,309
mit mehr Menschen sprechen zu können, wenn man mindestens eine zweite
oder vielleicht sogar eine dritte Sprache kennt, sondern dass das

00:06:16,309 --> 00:06:18,559
Erlernen einer weiteren
Sprache auch das Denken prägt.

00:06:18,559 --> 00:06:23,719
Wenn man also eine neue Sprache hat, in der man sich
ausdrücken kann, ist man vielleicht auch offener

00:06:23,719 --> 00:06:28,520
für neue Ideen, und man kann Dinge ausdrücken, die
in der normalen Sprache, die man sonst benutzt, nicht

00:06:28,520 --> 00:06:29,550
so leicht auszudrücken sind.

00:06:29,550 --> 00:06:33,249
Und das Gleiche, würde ich sagen,
gilt für Programmiersprachen.

00:06:33,249 --> 00:06:39,680
Wenn man also eine andere Programmiersprache
lernt, eröffnet das neue Möglichkeiten, in

00:06:39,680 --> 00:06:44,180
Bezug auf Algorithmen zu denken, in Bezug
darauf, Konstrukte oder Ideen auszudrücken.

00:06:44,180 --> 00:06:52,539
Und das ist selbst dann wertvoll, wenn anschließend
hauptsächlich in einer Sprache programmiert wird.

7 # slide
00:06:52,539 --> 00:06:57,789
Das wird auch von der jüngeren
Geschichte unterstützt.

00:06:57,789 --> 00:07:04,169
Also, was wir hier haben, ist ein Bild von dem
Poster, das ich in meinem alten Büro hatte.

00:07:04,169 --> 00:07:08,729
Und es versucht, die Geschichte der
Programmiersprachen darzustellen.

00:07:08,729 --> 00:07:11,059
Natürlich ist es
kein vollständiges Bild.

00:07:11,059 --> 00:07:14,729
Zum einen, weil es aus
einem Buch von 2004 stammt.

00:07:14,729 --> 00:07:21,689
Es ist also schon ziemlich alt, wiederum
nach den Maßstäben der Informatik.

00:07:21,689 --> 00:07:28,339
Und zum anderen ist es eigentlich ein Bild
hauptsächlich der Programmiersprachen, über die der

00:07:28,339 --> 00:07:31,919
jeweilige Verlag
Bücher veröffentlicht hat.

00:07:31,919 --> 00:07:33,119
Es ist also definitiv nicht vollständig.

00:07:33,119 --> 00:07:34,309
Aber das ist nicht wirklich der Punkt.

00:07:34,309 --> 00:07:39,679
Der Punkt ist, dass es am Anfang nur ein paar
Sprachen gab, die sich entwickelt haben, ...

00:07:39,679 --> 00:07:43,669
Wahrscheinlich ist es gar nicht
so einfach, hier hineinzuzoomen.

00:07:43,669 --> 00:07:48,409
Also, wenn Sie es nicht wissen, sollten Sie
vielleicht tatsächlich recherchieren, was die erste

00:07:48,409 --> 00:07:52,520
Programmiersprache war, die als
High-Level-Programmiersprache anerkannt ist, also nicht nur

00:07:52,520 --> 00:07:53,520
Maschinencode.

00:07:53,520 --> 00:07:57,469
Aber wie auch immer, wie wir auch sehen können,
hat sich das im Laufe der Jahre vermehrt.

00:07:57,469 --> 00:08:00,589
Also, es gibt viele Sprachen,
die sich parallel entwickeln.

00:08:00,589 --> 00:08:05,210
Es gibt auch Verbindungen, wo es scheint,
dass eine Sprache eine andere beeinflusst.

00:08:05,210 --> 00:08:12,779
Das wird hier mit diesen dünnen Linien angedeutet,
die zwischen den verschiedenen Bahnen verlaufen.

00:08:12,779 --> 00:08:17,929
Und natürlich könnten wir fragen: Wenn
es gut genug ist, dass alle C, Java oder

00:08:17,929 --> 00:08:21,459
Python kennen, warum brauchen wir
dann all diese verschiedenen Sprachen?

00:08:21,459 --> 00:08:24,110
Warum gibt es diese Art
der parallelen Entwicklung?

00:08:24,110 --> 00:08:28,059
Aber wir sehen natürlich auch,
dass Sprachen aussterben.

00:08:28,059 --> 00:08:33,469
Es gibt Sprachen, die tauchen auf, und nach
kurzer Zeit scheinen sie wieder zu verschwinden.

00:08:33,469 --> 00:08:36,560
Und es gibt Sprachen, die
ein sehr langes Leben führen.

00:08:36,560 --> 00:08:39,769
Und wieder könnte die Frage
lauten: Warum ist das so?

00:08:39,769 --> 00:08:49,579
Was zeichnet also Programmiersprachen aus, um langfristig
erfolgreich zu sein oder sehr kurzlebig zu sein?

8 # slide
00:08:49,579 --> 00:08:59,750
Ein anderes Bild, aus einer anderen
Quelle, mit weniger Sprachen, aber besser

00:08:59,750 --> 00:09:02,710
sichtbaren Abhängigkeiten und
Vererbungsbeziehungen zwischen ihnen.

00:09:02,710 --> 00:09:05,250
Und interessanterweise
mit einer Farbkodierung.

00:09:05,250 --> 00:09:09,139
Hier sehen wir also einige
Bezeichnungen, die verwendet werden.

00:09:09,139 --> 00:09:15,791
Und das könnten wir schon als Paradigmen-Etiketten
sehen, um anzuzeigen, welche Art von Sprache

00:09:15,791 --> 00:09:18,620
wir in jedem spezifischen Fall haben.

00:09:18,620 --> 00:09:27,850
Und in diesem gelb-grünen Bereich finden
Sie zum Beispiel C, Java, Python: imperative

00:09:27,850 --> 00:09:29,150
und/oder
objektorientierte Programmiersprachen.

00:09:29,150 --> 00:09:35,410
Wohingegen die Sprachen, mit denen wir uns beschäftigen
werden, Haskell und Prolog, in den Farben Rot und

00:09:35,410 --> 00:09:36,410
Blau erscheinen.

00:09:36,410 --> 00:09:42,589
Das deutet also schon darauf hin, dass
sie etwas ganz anderes sein müssen

00:09:42,589 --> 00:09:45,379
als die meisten Sprachen,
die Sie hier sehen.

00:09:45,379 --> 00:09:50,910
Vielleicht ist es auch interessant für Sie, sich dieses
Bild ein wenig anzuschauen und sich zu fragen, ob

00:09:50,910 --> 00:09:57,670
Sie von mehr als 10 der Sprachen, die hier
erwähnt werden, schon einmal gehört haben.

00:09:57,670 --> 00:10:01,800
Vielleicht zählen Sie,
wie weit Sie kommen.

00:10:01,800 --> 00:10:06,130
Und noch ein anderer Aspekt, der hier interessant
ist, vor allem durch den Titel des Artikels,

00:10:06,130 --> 00:10:09,980
aus dem dieses Bild stammt:
Er heißt "The Semicolon Wars".

00:10:09,980 --> 00:10:16,399
Also, das war ein Artikel in einem populärwissenschaftlichen
Magazin, der eigentlich die Leidenschaft kommentierte,

00:10:16,399 --> 00:10:27,850
die manche Leute für die Programmiersprachen
empfinden, die sie benutzen.

9 # slide
00:10:27,850 --> 00:10:30,120
Das drückt sich auch in
Beliebtheitswettbewerben aus.

00:10:30,120 --> 00:10:35,339
Wir haben Sie in der Umfrage gefragt, ob
Sie eine Lieblings-Programmiersprache haben.

00:10:35,339 --> 00:10:39,709
Natürlich wurden die gleiche Art von Fragen
und Experimenten auch im Internet durchgeführt.

00:10:39,709 --> 00:10:45,939
Hier ist also eine spezifische Auswertung, die jemand auf
der Basis von Suchergebnissen und einigen anderen Datensätzen

00:10:45,939 --> 00:10:47,220
gemacht hat, glaube ich.

00:10:47,220 --> 00:10:49,329
Ein nicht sehr überraschendes Bild.

00:10:49,329 --> 00:10:53,329
Also, C, Java, Python
sind nahe der Spitze.

00:10:53,329 --> 00:10:55,500
Es ist schon ein
paar Jahre alt, dieses Bild.

00:10:55,500 --> 00:11:01,430
Ich vermute, dass Python heutzutage weiter oben
wäre, und vielleicht wären einige neue Einträge

00:11:01,430 --> 00:11:05,170
oder Sprachen wie Swift oder
Rust auch nahe der Spitze.

00:11:05,170 --> 00:11:08,790
Also, hier, vor ein paar Jahren, gab es noch
ein sehr beunruhigendes Vorkommen von PHP.

00:11:08,790 --> 00:11:12,880
Ich weiß nicht, wie
das heute aussehen würde.

00:11:12,880 --> 00:11:21,510
Aber gut, das ist das, was den Leuten irgendwann mal
zu gefallen schien, was Programmiersprachen angeht.

10 # slide
00:11:21,510 --> 00:11:29,440
Und, eine letzte Visualisierung, die interessant
ist, vor allem weil sie interaktiv ist.

00:11:29,440 --> 00:11:34,279
Wenn Sie also dem Link folgen, der dort unten angegeben
ist, gelangen Sie zu einer interaktiven Version

00:11:34,279 --> 00:11:37,730
dieses Bildes, wo
Sie hineinzoomen können.

00:11:37,730 --> 00:11:39,009
Sie können nach Paradigmen filtern.

00:11:39,009 --> 00:11:47,189
Sie können diese Grafik erkunden und zum Beispiel
herausfinden, warum die Punkte für die Sprachen

00:11:47,189 --> 00:11:48,199
hier unterschiedlich groß sind.

00:11:48,199 --> 00:11:54,999
Das ist also ein Maß für den Einfluss, den Sprachen
auf andere Sprachen haben, nach einer bestimmten

00:11:54,999 --> 00:11:55,999
Metrik.

00:11:55,999 --> 00:12:00,079
Und dann ist es zum Beispiel interessant, dass
natürlich C sehr einflussreich ist (hier, der große

00:12:00,079 --> 00:12:07,500
blaue Punkt, den Sie sehen), aber zum Beispiel
auch Haskell scheint mäßig einflussreich zu sein.

00:12:07,500 --> 00:12:10,750
Auch wenn es laut der vorherigen
Folie nicht sehr populär ist.

00:12:10,750 --> 00:12:15,130
Also, Haskell und andere funktionale Sprachen sind
vielleicht nicht die populärsten Sprachen, aber

00:12:15,130 --> 00:12:17,199
sie sind einflussreich.

00:12:17,199 --> 00:12:25,210
Und vielleicht werden Sie im weiteren Verlauf dieses Kurses
in der Lage sein, dies in gewissem Maße zu würdigen.

11 # slide
00:12:25,210 --> 00:12:30,110
Wenn wir all diese Bilder beiseite
lassen, bleibt natürlich eine Frage offen.

00:12:30,110 --> 00:12:32,509
Nämlich, warum gibt es
überhaupt eine solche Vielfalt?

00:12:32,509 --> 00:12:35,310
Warum gibt es
so viele Programmiersprachen?

00:12:35,310 --> 00:12:40,589
Ist es so, dass eine oder vielleicht sogar jede
dieser Sprachen mehr kann als einige andere

00:12:40,589 --> 00:12:45,240
von ihnen, sodass es eine Daseinsberechtigung
für jede einzelne Sprache gibt?

00:12:45,240 --> 00:12:49,130
Oder gibt es Probleme, die sich in
bestimmten Sprachen gar nicht lösen lassen?

00:12:49,130 --> 00:12:53,779
Sodass wir deshalb so viele Sprachen haben
müssen, weil wir so viele Probleme haben?

00:12:53,779 --> 00:12:56,470
Oder gibt es eine beste Sprache,
zumindest für einen bestimmten Zweck?

00:12:56,470 --> 00:13:00,660
Oder gibt es vielleicht keine beste Sprache insgesamt,
aber für einen bestimmten Anwendungsbereich könnte

00:13:00,660 --> 00:13:02,540
es eine beste Sprache geben.

00:13:02,540 --> 00:13:07,220
Und da wir verschiedene Anwendungsbereiche
haben, brauchen wir viele Sprachen?

00:13:07,220 --> 00:13:11,120
Und natürlich auch, was trennt eigentlich
diese verschiedenen Programmiersprachen?

00:13:11,120 --> 00:13:16,850
In welchem Sinne unterscheiden sich zwei dieser vielen Sprachen
voneinander, abgesehen von dem offensichtlichen Unterschied

00:13:16,850 --> 00:13:22,089
in der Syntax, den man erkennt, wenn man zwei
Programme in verschiedenen Sprachen sieht?

00:13:22,089 --> 00:13:26,399
Und natürlich sollten Sie für einige
dieser Fragen bereits die Antworten kennen.

00:13:26,399 --> 00:13:29,600
Oder Teilantworten, zumindest
von der theoretischen Seite.

00:13:29,600 --> 00:13:35,970
Sie wissen zum Beispiel, dass alle
Programmiersprachen letztlich in Maschinencode

00:13:35,970 --> 00:13:37,410
übersetzt werden müssen.

00:13:37,410 --> 00:13:42,170
In diesem Sinne können sie also nicht
mehr tun, als Maschinencode tun kann.

00:13:42,170 --> 00:13:48,329
Wenn Sie den Kurs "Berechenbarkeit
und Komplexität" von Prof. König

00:13:48,329 --> 00:13:54,399
besucht haben, dann wissen Sie auch, dass es das
wichtige Konzept der Turing-Vollständigkeit gibt,

00:13:54,399 --> 00:13:58,509
wenn eine Programmiersprache in ihrer
Ausdruckskraft einer Turing-Maschine entspricht.

00:13:58,509 --> 00:14:03,550
Und praktisch alle Sprachen, die in den
vorherigen Folien auftauchten, sind in

00:14:03,550 --> 00:14:04,550
diesem Sinne Turing-äquivalent.

00:14:04,550 --> 00:14:10,029
Aus theoretischer Sicht ist also keine
von ihnen mächtiger als die anderen.

00:14:10,029 --> 00:14:13,720
Natürlich können sie genau die
gleichen mathematischen Probleme lösen.

00:14:13,720 --> 00:14:18,199
Aber dennoch kann es sein, dass für ein bestimmtes
Anwendungsgebiet eine Sprache einfach viel besser

00:14:18,199 --> 00:14:19,360
geeignet ist.

00:14:19,360 --> 00:14:23,569
Das ist ja auch einer der Gründe,
warum es verschiedene Sprachen gibt.

00:14:23,569 --> 00:14:28,459
Also, einige der Sprachen, die Sie gesehen
haben, oder die erwähnt wurden, wurden praktisch

00:14:28,459 --> 00:14:30,959
für einen
Anwendungsbereich maßgeschneidert.

00:14:30,959 --> 00:14:36,850
Und dann wurde natürlich eine Menge Aufwand betrieben,
um sie für diese Anwendungsdomäne schön nutzbar zu

00:14:36,850 --> 00:14:37,850
machen.

00:14:37,850 --> 00:14:41,529
Und in diesem Sinne sind sie vielleicht sogar die
beste Sprache für einen bestimmten Bereich, auch

00:14:41,529 --> 00:14:45,520
wenn sie theoretisch nicht
mächtiger als andere Sprachen sind.

00:14:45,520 --> 00:14:51,630
Und wenn Sie selbst zwei oder drei oder vier
Programmiersprachen kennen, dann haben Sie natürlich

00:14:51,630 --> 00:15:01,379
auch Ihre eigene Meinung zu einigen
dieser Fragen hier, insbesondere auf der

00:15:01,379 --> 00:15:02,379
praktischen Seite.

12 # slide
00:15:02,379 --> 00:15:07,319
Die letzte Frage von der vorigen Folie
zum Thema "Was trennt/unterscheidet

00:15:07,319 --> 00:15:08,319
verschiedene Programmiersprachen":

00:15:08,319 --> 00:15:13,019
Natürlich kann man sich fragen, was sind relevante
Dimensionen oder Unterscheidungen, die man machen kann?

00:15:13,019 --> 00:15:17,959
Wenn man ein wenig darüber nachdenkt, dann
bieten sich natürlich mehrere Dinge an.

00:15:17,959 --> 00:15:20,210
So kann man zum Beispiel
natürlich die Syntax vergleichen.

00:15:20,210 --> 00:15:25,690
Und zwar nicht nur die konkrete Syntax (wie die
Schlüsselwörter in zwei verschiedenen Sprachen heißen),

00:15:25,690 --> 00:15:30,430
sondern zum Beispiel auch, wie syntaktisch
reich oder syntaktisch arm/knapp die Sprachen

00:15:30,430 --> 00:15:31,430
sind.

00:15:31,430 --> 00:15:37,689
Und zwei typische Sprachen, von denen Sie vielleicht noch
nie etwas gehört haben (oder zumindest nicht von beiden),

00:15:37,689 --> 00:15:39,160
sind APL und Lisp.

00:15:39,160 --> 00:15:42,990
Also, die Sprache heißt APL
für Array Processing Language.

00:15:42,990 --> 00:15:46,420
Sie wurde für mathematische Berechnungen
auf Matrizen usw. verwendet.

00:15:46,420 --> 00:15:49,089
Arrays im allgemeinen Sinne.

00:15:49,089 --> 00:15:56,939
Und das Design dieser Sprache war so, dass sie eine
sehr reiche Syntax im Sinne des Ausdrucks mathematischer

00:15:56,939 --> 00:15:59,959
Konzepte durch
mathematische Symbole hatte.

00:15:59,959 --> 00:16:07,070
Um also effizient in APL zu programmieren, brauchte
man eigentlich eine eigene Tastatur, auf der

00:16:07,070 --> 00:16:11,819
all die speziellen Symbole erscheinen, die
man in einem APL-Programm sehen möchte.

00:16:11,819 --> 00:16:19,480
Und auf der anderen Extremseite des Spektrums steht Lisp, das
ebenfalls ein Vorfahre der funktionalen Programmierung ist.

00:16:19,480 --> 00:16:21,519
In Lisp ist die Syntax sehr einfach.

00:16:21,519 --> 00:16:26,089
Es gibt also nur sehr wenige syntaktische
Konstrukte, im Grunde nur Bezeichner und öffnende

00:16:26,089 --> 00:16:29,110
und schließende Klammern, und
daraus wird alles gemacht.

00:16:29,110 --> 00:16:32,769
Keine speziellen Operatoren,
keine speziellen Symbole etc.

00:16:32,769 --> 00:16:34,250
Also: extreme Unterschiede.

00:16:34,250 --> 00:16:37,879
Natürlich leben viele Sprachen
irgendwo in der Mitte.

00:16:37,879 --> 00:16:41,389
Eine weitere Dimension, die man betrachten
könnte, ist die Ausführlichkeit:

00:16:41,389 --> 00:16:45,790
Braucht man also viel Programmtext,
um eine bestimmte Idee auszudrücken?

00:16:45,790 --> 00:16:51,660
Oder ist es umgekehrt, dass sehr kurze
Programme z.B. mathematische Ideen ausdrücken?

00:16:51,660 --> 00:16:53,029
Und wieder gibt es Extreme:

00:16:53,029 --> 00:16:54,699
So ist COBOL eine sehr alte Sprache.

00:16:54,699 --> 00:16:59,350
Sie wurde im kommerziellen Bereich eingesetzt und
wird auch heute noch in einigen Bereichen verwendet.

00:16:59,350 --> 00:17:05,189
Die Idee von COBOL, als es entworfen wurde, war,
der natürlichen Sprache sehr nahe zu kommen.

00:17:05,189 --> 00:17:10,089
In dem Sinne, dass ein Unternehmensberater in der
Lage wäre, ein COBOL-Programm zu lesen, auch wenn

00:17:10,089 --> 00:17:12,900
er kein Programmierer ist.

00:17:12,900 --> 00:17:18,100
Das führt also zu einem sehr
ausführlichen Programmtext.

00:17:18,100 --> 00:17:20,549
Und auf der anderen extremen Seite könnte man
Haskell sehen, das wir uns ansehen werden.

00:17:20,549 --> 00:17:28,329
Und Sie werden später sehen, dass eine Menge Ideen in
sehr kurzen Haskell-Programmen ausgedrückt werden können.

00:17:28,329 --> 00:17:32,770
Es gibt Unterschiede in Bezug darauf,
wie Sprachen implementiert werden.

00:17:32,770 --> 00:17:37,650
Natürlich ist es nicht wirklich ein Unterschied der
Sprache selbst, sondern der Art, wie sie verwendet wird.

00:17:37,650 --> 00:17:40,730
Also: Compiler vs. Interpreter.

00:17:40,730 --> 00:17:44,460
Im Prinzip kann jede Sprache entweder
kompiliert oder interpretiert werden.

00:17:44,460 --> 00:17:49,220
Aber es gibt Sprachen, die wirklich für einen
dieser beiden Ausführungsmodi gemacht sind.

00:17:49,220 --> 00:17:52,200
C ist eine
typische, rein kompilierte Sprache.

00:17:52,200 --> 00:17:57,399
Im Gegensatz zu Perl, für das ich nicht
einmal weiß, ob es einen Compiler gibt.

00:17:57,399 --> 00:18:02,350
Das beeinflusst auch nicht nur, wie das Programm
läuft, sondern auch, wie die Entwicklung von Programmen

00:18:02,350 --> 00:18:04,270
in der Sprache funktioniert.

00:18:04,270 --> 00:18:10,250
Zum Beispiel gibt es für Interpreter unterschiedliche
Entwicklungsgewohnheiten, die sich die Leute aneignen.

00:18:10,250 --> 00:18:17,409
Dann kann es Unterschiede geben, ob es eine sehr
domänenspezifische oder eine sehr allgemein gehaltene Sprache

00:18:17,409 --> 00:18:18,409
ist.

00:18:18,409 --> 00:18:22,730
So ist SQL, das Sie vielleicht schon gesehen
haben (oder sehen werden, wenn Sie die Vorlesung

00:18:22,730 --> 00:18:30,130
"Datenbanken" besucht haben), ein sehr typisches
Beispiel für eine domänenspezifische Sprache.

00:18:30,130 --> 00:18:36,789
Selbst SQL ist, obwohl es Turing-äquivalent
ist, immer noch domänenspezifisch im folgenden

00:18:36,789 --> 00:18:37,789
Sinne:

00:18:37,789 --> 00:18:41,210
Sie können zwar alles in SQL programmieren, aber
wofür Sie SQL wirklich verwenden sollten, ist

00:18:41,210 --> 00:18:45,630
der Umgang mit relationalen Datenbanken.

00:18:45,630 --> 00:18:50,750
Dafür ist es gemacht und dafür
kann es sinnvoll eingesetzt werden.

00:18:50,750 --> 00:18:55,990
Im Gegensatz zu Sprachen wie Java, die wirklich nicht
für einen bestimmten Zweck gemacht sind, sondern um

00:18:55,990 --> 00:19:00,279
jede beliebige Anwendung zu programmieren,
an der man interessiert ist.

00:19:00,279 --> 00:19:01,820
Aber dann ist
sie auch nicht spezialisiert.

00:19:01,820 --> 00:19:09,220
Sie kann also alles, aber andere Sprachen sind
besser in den Dingen, für die sie entwickelt wurden.

00:19:09,220 --> 00:19:14,480
Es gibt Unterscheidungen wie Sequenzialität oder
Gleichzeitigkeit/Parallelität, die natürlich zu

00:19:14,480 --> 00:19:17,480
einem gewissen Grad von
Hardware-Entwicklungen getrieben werden.

00:19:17,480 --> 00:19:21,390
Zum Beispiel ist JavaScript eine
typische sequenzielle Sprache.

00:19:21,390 --> 00:19:28,770
Es gibt sogar Probleme, sie parallel zu
verwenden, zum Beispiel in einem Browser.

00:19:28,770 --> 00:19:33,340
Im Gegensatz zu Erlang, das eine Sprache ist, die
für die Netzwerkverarbeitung entwickelt wurde.

00:19:33,340 --> 00:19:39,380
Und von Anfang an, von den allerersten
Ideen an, ist sie auf Nebenläufigkeit und

00:19:39,380 --> 00:19:46,250
Parallelität ausgelegt, um mit paralleler Hardware
oder parallelen Netzwerken zurechtzukommen.

00:19:46,250 --> 00:19:50,440
Eine weitere wichtige Unterscheidung ist die zwischen typisierten
(getypten) und nicht typisierten (ungetypten) Sprachen.

00:19:50,440 --> 00:19:56,440
Und das ist auch ein weiterer Bereich,
in dem Leute Sprachkriege beginnen.

00:19:56,440 --> 00:19:59,490
In diesem Kurs werden wir
interessanterweise beides sehen.

00:19:59,490 --> 00:20:07,190
So ist Haskell ein typisches Beispiel für eine getypte,
und zwar sehr stark getypte, Programmiersprache.

00:20:07,190 --> 00:20:10,919
Und das wird auch im Kurs selbst
eine wichtige Rolle spielen.

00:20:10,919 --> 00:20:16,570
Im Gegensatz zu Prolog, das ein typisches Beispiel
für eine ungetypte Programmiersprache ist.

00:20:16,570 --> 00:20:25,222
Das ist also paradigmenübergreifend, diese
Unterscheidung zwischen getypten und ungetypten Sprachen.

00:20:25,222 --> 00:20:27,390
Es gibt dynamische
und statische Sprachen.

00:20:27,390 --> 00:20:31,920
Es ist nicht so einfach, diese
Unterscheidung zu erfassen.

00:20:31,920 --> 00:20:38,680
Aber es gibt Sprachen, bei denen, egal ob sie
kompiliert oder interpretiert sind, aber hauptsächlich

00:20:38,680 --> 00:20:41,360
gilt das für interpretierte
Sprachen, die sehr dynamisch sind.

00:20:41,360 --> 00:20:48,230
Zur Laufzeit können sich also Dinge ändern, Typen können sich
ändern und die Zusammensetzung von Modulen kann sich ändern.

00:20:48,230 --> 00:20:53,130
Ruby ist ein Beispiel, bei dem diese
dynamische Natur sehr ausgeprägt ist.

00:20:53,130 --> 00:21:00,590
Im Gegensatz zu ML, einer anderen funktionalen Sprache, die
eigentlich für die statische Analyse von Programmen gemacht ist.

00:21:00,590 --> 00:21:06,000
Und dann sollte sich zum Beispiel ihre
Zusammensetzung zur Laufzeit nicht ändern.

00:21:06,000 --> 00:21:10,110
Dann gibt es noch diese Paradigmen:
deklarativ vs. imperativ.

00:21:10,110 --> 00:21:14,350
Und das kam schon früher
in einem der Bilder vor.

00:21:14,350 --> 00:21:19,080
Da hatten wir "deklarativ" als Bezeichnung für
Prolog und "imperativ" als Bezeichnung für C.

00:21:19,080 --> 00:21:24,500
Und ich gehe davon aus, dass die meisten Sprachen,
die Sie bisher gelernt haben, oder die Sie bisher

00:21:24,500 --> 00:21:32,039
benutzt haben, imperative Sprachen sind, ob sie
nun explizit gekennzeichnet wurden oder nicht usw.

00:21:32,039 --> 00:21:36,010
Und dann gibt es noch dieses
Etikett der "Objektorientierung".

00:21:36,010 --> 00:21:39,350
Dazu gibt es
nicht wirklich ein Gegenteil.

00:21:39,350 --> 00:21:45,210
Und ich würde sogar sagen, dass "objektorientiert"
eher etwas ist, das einem Paradigma hinzugefügt wird.

00:21:45,210 --> 00:21:48,970
So sind objektorientierte Sprachen oft imperative
Programmiersprachen, ob sie nun explizit als solche

00:21:48,970 --> 00:21:49,970
gekennzeichnet waren, als man
sie gelernt hat oder nicht.

00:21:49,970 --> 00:21:50,970
Aber das muss nicht der Fall sein.

00:21:50,970 --> 00:21:53,980
Es gibt z.B. auch objektorientierte
funktionale Programmiersprachen.

00:21:53,980 --> 00:21:57,740
Haskell gehört nicht dazu, also
werden wir das auch nicht betrachten.

00:21:57,740 --> 00:22:04,059
Aber Objektorientierung ist etwas anderes als
ein Paradigma, und es wird in diesem Kurs

00:22:04,059 --> 00:22:06,399
keine Rolle spielen.

00:22:06,399 --> 00:22:12,810
Es könnten noch andere Unterscheidungen getroffen werden,
aber das sind nur einige Beispiele, um Sie vielleicht auch

00:22:12,810 --> 00:22:15,280
dazu zu bringen, über die Sprachen
nachzudenken, die Sie bereits kennen.

00:22:15,280 --> 00:22:23,370
Wie sie in diese verschiedenen
Unterscheidungen fallen.

13 # slide
00:22:23,370 --> 00:22:27,350
Trotz all dieser Unterschiede, die auf der vorherigen
Folie erwähnt wurden, gibt es natürlich auch gemeinsame

00:22:27,350 --> 00:22:31,059
Prinzipien, die den verschiedenen
Programmiersprachen zugrunde liegen.

00:22:31,059 --> 00:22:36,019
Wenn wir zum Beispiel eine Programmiersprache
haben, müssen wir in der Lage sein, die Syntax und

00:22:36,019 --> 00:22:39,860
Semantik zu beschreiben und natürlich auch
Implementierungsstrategien zu diskutieren.

00:22:39,860 --> 00:22:44,950
Das sind Dinge, die wir in diesem Kurs nicht
so sehr in den Vordergrund rücken werden.

00:22:44,950 --> 00:22:48,510
Natürlich müssen wir über
Syntax und Semantik sprechen.

00:22:48,510 --> 00:22:52,640
Aber wir werden das nicht sehr formal tun,
und wir werden keine Sprachen implementieren.

00:22:52,640 --> 00:23:00,170
Diese Aspekte sind also Dinge, die
z.B. in der Vorlesung "Compilerbau"

00:23:00,170 --> 00:23:05,840
vorkommen, die ich im Masterstudiengang
halte, aber nicht im Bachelorstudiengang.

00:23:05,840 --> 00:23:11,820
Noch ein Hinweis: Es gibt natürlich
Sprachkonzepte, die auch in verschiedenen Sprachen

00:23:11,820 --> 00:23:15,590
vorkommen und vielleicht auch in verschiedenen
Sprachen unterschiedlich vorkommen.

00:23:15,590 --> 00:23:19,780
So hat z.B. jede Programmiersprache,
die ich kenne, Variablen und einige

00:23:19,780 --> 00:23:20,780
Bindungskonstrukte.

00:23:20,780 --> 00:23:22,680
Aber die Rolle kann unterschiedlich sein.

00:23:22,680 --> 00:23:28,580
Wie Sie sehen werden, sind Variablen in Haskell
etwas völlig anderes als Variablen in C oder

00:23:28,580 --> 00:23:29,580
Java.

00:23:29,580 --> 00:23:31,630
Und in Prolog ist es wieder
eine andere Geschichte.

00:23:31,630 --> 00:23:34,880
Also, es gibt Variablen, aber
ihre Rolle ist eine andere.

00:23:34,880 --> 00:23:40,230
Und in ähnlicher Weise gibt es Konstrukte wie die
Typisierung, die wiederum eine andere Rolle in

00:23:40,230 --> 00:23:42,480
verschiedenen Sprachen spielen, wenn
die Sprachen überhaupt getypt sind.

00:23:42,480 --> 00:23:48,210
Java ist also eine getypte Programmiersprache, aber
die Typen dort unterscheiden sich deutlich von den

00:23:48,210 --> 00:23:50,760
Typen in Haskell, zum Beispiel.

00:23:50,760 --> 00:23:57,409
Und ebenso Kontrollstrukturen, wie Programme
organisiert sind, Abstraktionsmerkmale, wie man

00:23:57,409 --> 00:23:58,740
Programme modularisiert.

00:23:58,740 --> 00:24:04,700
Das ist in allen Sprachen wichtig, aber es
ist in verschiedenen Sprachen unterschiedlich.

00:24:04,700 --> 00:24:12,299
Und wir werden versuchen, das auch nach vorne zu
bringen, indem wir solche Unterscheidungen diskutieren.

00:24:12,299 --> 00:24:17,500
Es gibt diese Idee, Sprachen nach
den Paradigmen zu bezeichnen.

00:24:17,500 --> 00:24:23,200
Wir sagen also, dass Java und C imperative
Sprachen sind, und Haskell und ML sind zum

00:24:23,200 --> 00:24:24,630
Beispiel funktionale Sprachen.

00:24:24,630 --> 00:24:31,440
Eigentlich ist es nicht ganz einfach, dies zu
definieren, aber die Aspekte, die hier diskutiert und

00:24:31,440 --> 00:24:34,600
auf der Folie erwähnt wurden, tragen
zu diesen Unterscheidungen bei.

00:24:34,600 --> 00:24:40,899
Auf jeden Fall kann man solche Aspekte am besten
einschätzen, wenn man mehrere verschiedene Sprachen kennt.

00:24:40,899 --> 00:24:44,190
Und das ist eines
der Ziele dieses Kurses.

14 # slide
00:24:44,190 --> 00:24:48,590
Was ist also der
Plan für diese Vorlesung?

00:24:48,590 --> 00:24:53,860
Wir werden uns auf zwei Paradigmen konzentrieren:
funktionale und logische Programmierung.

00:24:53,860 --> 00:25:00,019
Ich gehe davon aus, dass dies zwei neue
Paradigmen für die meisten von Ihnen sind, und das

00:25:00,019 --> 00:25:03,000
wird auch durch die bisherigen
Umfrageergebnisse bestätigt.

00:25:03,000 --> 00:25:09,669
Wir werden zwei bestimmte Sprachen auswählen: Haskell
für die funktionale Programmierung und Prolog für die

00:25:09,669 --> 00:25:11,760
logische Programmierung.

00:25:11,760 --> 00:25:14,840
Im Fall der funktionalen Programmierung
hätten wir eine Wahl gehabt.

00:25:14,840 --> 00:25:22,260
So gibt es eine lange Geschichte und auch verschiedene
Beispielsprachen für funktionale Programmierung.

00:25:22,260 --> 00:25:28,559
Und wir haben uns für Haskell entschieden, weil es
uns erlaubt, alle Aspekte, die wir abdecken wollen, zu

00:25:28,559 --> 00:25:29,559
diskutieren.

00:25:29,559 --> 00:25:33,940
Und auf der Prolog-Seite ist die Situation ein
wenig anders, weil Prolog wirklich die einzige

00:25:33,940 --> 00:25:37,420
große logische Programmiersprache
ist, die überhaupt existiert.

00:25:37,420 --> 00:25:43,630
Es gibt also nicht viel Auswahl, um eine
andere logische Programmiersprache zu nehmen.

00:25:43,630 --> 00:25:51,130
In beiden Fällen betrachten wir die eigentlichen Programmierkonzepte,
und wir werden auch Aspekte diskutieren, die mit

00:25:51,130 --> 00:25:52,370
der Semantik zusammenhängen.

00:25:52,370 --> 00:25:55,519
Also, Auswertung im Fall von Haskell,
Auflösung im Fall von Prolog.

00:25:55,519 --> 00:26:01,820
Einiges davon wird Ihnen bereits aus
der "Logik"-Vorlesung bekannt sein.

00:26:01,820 --> 00:26:05,279
Bei Haskell beschäftigen
wir uns mit Typkonzepten.

00:26:05,279 --> 00:26:08,809
Ich habe bereits erwähnt, dass Haskell
eine sehr starke Typdisziplin hat.

00:26:08,809 --> 00:26:16,659
Das erlaubt uns, Aspekte wie: Inferenz, Generizität,
Polymorphismus in einer disziplinierteren Art und Weise

00:26:16,659 --> 00:26:21,160
zu diskutieren, als es z. B. mit einer
Sprache wie Java möglich wäre (obwohl es auch

00:26:21,160 --> 00:26:23,070
eine getypte Sprache ist).

00:26:23,070 --> 00:26:25,960
Für Prolog spielen Typen keine Rolle.

00:26:25,960 --> 00:26:30,909
Und in jedem Fall werden wir Konzepte diskutieren und
vergleichen, wie ich bereits auf der vorherigen Folie erwähnt

00:26:30,909 --> 00:26:37,039
habe: Variablen, die Unterscheidung zwischen
Ausdrücken und Befehlen, und andere Aspekte über

00:26:37,039 --> 00:26:42,490
Sprachen hinweg (sowohl über Haskell und Prolog
hinweg, als auch im Vergleich zu imperativen

00:26:42,490 --> 00:26:44,800
Programmiersprachen).

15 # slide
00:26:44,800 --> 00:26:54,470
Bevor ich über mögliche Literatur spreche, in zwei
Folien, zunächst ein paar abschließende Bemerkungen

00:26:54,470 --> 00:26:56,049
zur Motivation.

00:26:56,049 --> 00:27:02,070
Oder eigentlich, zuerst, ein paar Kommentare
zum Begriff der deklarativen Programmierung.

00:27:02,070 --> 00:27:08,960
Diese Bezeichnung kam schon in einer der früheren
Abbildungen als Unterscheidung von Prolog vor.

00:27:08,960 --> 00:27:15,130
Eigentlich wird deklarative (oder auch deskriptive)
Programmierung oft als Überbegriff für sowohl

00:27:15,130 --> 00:27:19,380
funktionale als auch logische
Programmierung verwendet.

00:27:19,380 --> 00:27:25,389
Der Grund dafür ist, dass sie die Idee teilen,
dass Programmierer mehr in Begriffen des "Was"

00:27:25,389 --> 00:27:26,519
statt des "Wie" denken sollten.

00:27:26,519 --> 00:27:33,570
Ursprünglich also die Idee, dass die Programmierung mehr
aus der Spezifikation eines Problems bestehen sollte,

00:27:33,570 --> 00:27:38,549
als aus der Planung eines bestimmten
Berechnungsprozesses in einzelnen Schritten.

00:27:38,549 --> 00:27:46,669
Dann kam in gewisser Weise die
logische Programmierung in Mode.

00:27:46,669 --> 00:27:48,100
Diese war noch anspruchsvoller.

00:27:48,100 --> 00:27:51,960
Die Idee war damals, dass Programmierer sich überhaupt
keine Gedanken über Berechnungsprozesse machen

00:27:51,960 --> 00:27:52,960
sollten.

00:27:52,960 --> 00:27:58,450
Sie sollten nur spezifizieren und das
würde irgendwie alle Probleme lösen.

00:27:58,450 --> 00:28:00,539
Das war etwas überambitioniert.

00:28:00,539 --> 00:28:08,809
Aber die allgemeine Idee, sich mehr auf die
Spezifikation von Problemen zu konzentrieren als auf

00:28:08,809 --> 00:28:16,090
deren detaillierte Lösung/Berechnung, hat in Form der
funktionalen und logischen Programmierung überlebt.

00:28:16,090 --> 00:28:18,630
Das bedeutet natürlich nicht, dass
irgendeine Magie im Spiel ist.

00:28:18,630 --> 00:28:23,380
Es ist also immer noch notwendig, dass der
Programmierer über Algorithmen nachdenkt.

00:28:23,380 --> 00:28:26,440
Und das ist natürlich eine
gute und nützliche Sache.

00:28:26,440 --> 00:28:31,490
Aber ich denke, dass es in einer
deklarativen Umgebung schöner ist.

00:28:31,490 --> 00:28:32,630
Warum ist das so?

00:28:32,630 --> 00:28:40,029
Das liegt vor allem daran, dass die deklarative
Programmierung in der Regel auf einem hohen Niveau

00:28:40,029 --> 00:28:42,909
stattfindet und sich
etwas mathematisch anfühlt.

00:28:42,909 --> 00:28:48,480
Im Fall der logischen Programmierung ist der
mathematische Aspekt natürlich die Logik.

00:28:48,480 --> 00:28:53,269
Im Fall der funktionalen Programmierung hingegen ist
die Mathematik, um die es geht, hauptsächlich die

00:28:53,269 --> 00:28:59,590
Algebra: der Umgang mit Ausdrücken
und deren Transformationen.

00:28:59,590 --> 00:29:08,559
Das führt zu Behauptungen und oft zu Beobachtungen,
dass funktionale oder logische Programme kürzer (bis

00:29:08,559 --> 00:29:16,309
zu einem gewissen Grad), lesbarer (wenn man die Sprachen
kennt) und häufiger korrekt sind, als Programme,

00:29:16,309 --> 00:29:18,850
die in einem konventionellen
Stil geschrieben sind.

00:29:18,850 --> 00:29:24,309
Und ein Grund dafür ist, dass die Ausführung
und das Denken über Programme in einer

00:29:24,309 --> 00:29:30,590
deklarativen oder beschreibenden Sprache viel näher
beieinander liegen als in einer normalen imperativen Sprache.

00:29:30,590 --> 00:29:39,140
Wir werden dies auch diskutieren, wenn wir Beobachtungen
über Ausdrücke, Befehle und andere Sprachkonstrukte

00:29:39,140 --> 00:29:40,140
machen.

00:29:40,140 --> 00:29:43,290
Wie sie in den verschiedenen
Paradigmen ausfallen.

00:29:43,290 --> 00:29:48,320
Ein Nebeneffekt von deklarativen Sprachen ist,
dass sie oft eine reduzierte Syntax haben.

00:29:48,320 --> 00:29:55,050
Das hat natürlich mit all den Beobachtungen zu
tun, die ich über kürzere Programme gemacht habe.

00:29:55,050 --> 00:30:01,570
Aber auch die Art und Weise, wie Programme
ausgedrückt werden, ist oft konzeptionell einfacher.

00:30:01,570 --> 00:30:06,429
Denn es gibt z. B. weniger Schlüsselwörter,
dafür aber eine reichhaltigere

00:30:06,429 --> 00:30:07,429
Ausdruckssprache.

00:30:07,429 --> 00:30:15,620
Aber das werden wir sehen,
wenn wir auf Beispiele stoßen.

16 # slide
00:30:15,620 --> 00:30:23,130
Warum sollten Sie sich letztlich überhaupt
mit diesen neuen Paradigmen beschäftigen?

00:30:23,130 --> 00:30:30,700
Nun, eine einfache und vielleicht etwas unbefriedigende
Antwort ist, dass dies für viele von Ihnen ein

00:30:30,700 --> 00:30:31,720
Pflichtfach ist.

00:30:31,720 --> 00:30:37,110
Sie müssen sich also einfach mit diesem Material
beschäftigen, um die erforderlichen Credits zu bekommen.

00:30:37,110 --> 00:30:41,899
Ein tieferer Grund ist, dass das Erlernen
verschiedener Sprachen es Ihnen später leichter

00:30:41,899 --> 00:30:43,889
machen wird, neue Sprachen zu lernen.

00:30:43,889 --> 00:30:50,490
Es ist sehr unwahrscheinlich, dass Sie während
Ihrer Karriere als Informatiker nie wieder

00:30:50,490 --> 00:30:52,340
eine neue Sprache lernen müssen.

00:30:52,340 --> 00:30:56,100
Viel wahrscheinlicher ist, dass Sie alle
paar Jahre neue Sprachen lernen müssen.

00:30:56,100 --> 00:31:00,289
Nicht nur syntaktisch neue Sprachen,
sondern auch neue Sprachideen.

00:31:00,289 --> 00:31:03,470
Dann hilft dieser
Kurs, Sie darauf vorzubereiten.

00:31:03,470 --> 00:31:10,179
Auch haben in der Vergangenheit immer
wieder bestimmte Features und Konzepte aus

00:31:10,179 --> 00:31:15,590
Sprachen, die einst als eher exotisch galten, ihren
Weg in gängigere Programmiersprachen gefunden.

00:31:15,590 --> 00:31:17,290
Und das wird wahrscheinlich
auch wieder passieren.

00:31:17,290 --> 00:31:23,400
Beispiele aus der Vergangenheit wären die
Comprehension-Syntax oder Lambda-Ausdrücke, die

00:31:23,400 --> 00:31:28,629
in Sprachen wie Java übernommen wurden.

00:31:28,629 --> 00:31:33,899
Außerdem gibt es in einigen Anwendungsdomänen
eine erhöhte Nachfrage nach mathematikbasierten

00:31:33,899 --> 00:31:38,570
Sprachen, nach disziplinierten und
konzeptionell ausdrucksstarken Sprachen.

00:31:38,570 --> 00:31:43,490
Das gilt zum Beispiel für Domänen, in denen
die formale Verifikation immer wichtiger

00:31:43,490 --> 00:31:44,490
wird.

00:31:44,490 --> 00:31:50,030
Es zeigt sich, dass sowohl logische als auch
funktionale Programme leichter zu verifizieren sind.

00:31:50,030 --> 00:31:57,679
Generell, wie bereits erwähnt, erhöht die
Kenntnis neuer oder weiterer Paradigmen

00:31:57,679 --> 00:31:59,590
die Fähigkeit, Ideen auszudrücken.

00:31:59,590 --> 00:32:06,990
Selbst wenn Sie also in der Praxis nie wieder funktionale
oder logische Programme schreiben werden, werden die

00:32:06,990 --> 00:32:13,840
Ideen, die Sie bei der Beschäftigung mit diesem Material
erwerben, hoffentlich Ihre Reichweite auch in anderen

00:32:13,840 --> 00:32:15,190
Sprachen erhöhen.

00:32:15,190 --> 00:32:22,460
Und schließlich ist ein Aspekt, dass Sie, wenn
Sie im weiteren Verlauf Ihres Studiums eine

00:32:22,460 --> 00:32:28,740
Bachelor- oder Masterarbeit in meiner Gruppe schreiben
wollen, sehr wahrscheinlich das Material aus diesem Kurs

00:32:28,740 --> 00:32:29,769
verwenden müssen.

00:32:29,769 --> 00:32:36,629
Ich würde also schätzen, dass in 90 % der Fälle,
in denen ein/e Studierende/r eine Bachelorarbeit

00:32:36,629 --> 00:32:41,600
in meiner Gruppe schreiben
will, er Haskell verwenden muss.

17 # slide
00:32:41,600 --> 00:32:48,279
Wie ich am Anfang des Videos erwähnt habe, möchte ich mit
ein paar Worten über Literatur schließen, insbesondere

00:32:48,279 --> 00:32:51,679
über Bücher, die Sie für
den Kurs verwenden können.

00:32:51,679 --> 00:32:57,440
Eine Sache, die ich sagen muss, ist, dass es nicht
ein bestimmtes Buch gibt, das genau diesen Kurs

00:32:57,440 --> 00:32:58,440
abdeckt.

00:32:58,440 --> 00:33:04,120
Es gibt also kein Buch "Programmierparadigmen",
das irgendwie genau dem Kurs entsprechen

00:33:04,120 --> 00:33:05,330
würde, den ich gebe.

00:33:05,330 --> 00:33:09,390
Aber es gibt mehrere Bücher, sowohl für den
Haskell- als auch für den Prolog-Teil, die

00:33:09,390 --> 00:33:10,750
nützlich wären.

00:33:10,750 --> 00:33:16,879
Alle Bücher, die ich auf den nächsten beiden Folien
erwähnen werde, sind in unserer Bibliothek verfügbar.

00:33:16,879 --> 00:33:22,690
Natürlich ist das für Sie in der aktuellen
Situation nur von begrenztem Nutzen, aber das könnte

00:33:22,690 --> 00:33:23,809
sich in ein paar Wochen ändern.

00:33:23,809 --> 00:33:26,139
Vielleicht öffnet die Bibliothek
dann wieder zuverlässiger.

00:33:26,139 --> 00:33:31,100
Und auch in der Zwischenzeit gibt es bestimmte
Bücher, die auch online verfügbar sind.

00:33:31,100 --> 00:33:35,610
Und tatsächlich habe ich die Bibliothek letztes
Jahr gebeten, ein paar mehr E-Books anzuschaffen.

00:33:35,610 --> 00:33:47,840
Es sollte also zusätzliche
Möglichkeiten/Verfügbarkeit von E-Books geben.

18 # slide
00:33:47,840 --> 00:33:54,350
Auf der Haskell-Seite ist das Buch, das wahrscheinlich
dem, was ich in diesem Kurs mache, am nächsten kommt,

00:33:54,350 --> 00:33:56,309
das Buch "Programming in
Haskell" von Graham Hutton.

00:33:56,309 --> 00:33:57,830
Es gibt eine erste
und eine zweite Auflage.

00:33:57,830 --> 00:34:02,679
Ich habe hier die zweite Auflage erwähnt, aber
eigentlich ist die erste Auflage auch sehr nützlich für

00:34:02,679 --> 00:34:03,679
den Kurs.

00:34:03,679 --> 00:34:06,380
Sie können also
beide Ausgaben verwenden.

00:34:06,380 --> 00:34:13,270
Dann gibt es noch ein umfangreicheres und viel
dickeres Buch von Simon Thompson: "Haskell

00:34:13,270 --> 00:34:14,780
- The Craft of Functional Programming".

00:34:14,780 --> 00:34:21,630
Es ist bereits in der dritten Auflage,
und es enthält all die Dinge, die wir auf

00:34:21,630 --> 00:34:23,200
der konzeptionellen
Haskell-Seite machen werden.

00:34:23,200 --> 00:34:26,010
Und es deckt darüber
hinaus eine Menge ab.

00:34:26,010 --> 00:34:31,530
Es deckt also definitiv mehr Material
ab, als wir in diesem Kurs machen.

00:34:31,530 --> 00:34:36,400
Dann gibt es dieses sehr schöne Buch,
"Thinking Functionally with Haskell".

00:34:36,400 --> 00:34:42,070
Darin wird ein etwas mathematischerer Ansatz für die
Programmierung in Haskell gewählt, der vielleicht nicht

00:34:42,070 --> 00:34:44,770
für alle Leser geeignet ist.

00:34:44,770 --> 00:34:51,250
Aber vielleicht gibt es einige unter Ihnen, die von dieser
Art der Herangehensweise profitieren und profitieren würden.

00:34:51,250 --> 00:34:57,600
Dann, wenn Sie ein deutsches Buch bevorzugen (denn
alle anderen drei bisher genannten Bücher sind

00:34:57,600 --> 00:35:03,310
englische Bücher), gibt es dieses Buch:
"Haskell-Intensivkurs" von diesen beiden Autoren.

00:35:03,310 --> 00:35:10,490
Und beides, das Buch von Richard Bird und "Haskell-Intensivkurs",
sind Bücher, die Sie bereits jetzt online und

00:35:10,490 --> 00:35:11,600
kostenlos lesen können.

00:35:11,600 --> 00:35:20,130
Wenn Sie sich aus dem Universitätsnetz
oder per VPN einloggen.

00:35:20,130 --> 00:35:22,660
Und es gibt noch ein weiteres
deutsches Buch, aber es ist vergriffen.

00:35:22,660 --> 00:35:27,490
Es ist also in der Bibliothek vorhanden, aber
ich bin mir nicht sicher, ob Sie es anderswo

00:35:27,490 --> 00:35:29,550
finden, wenn Sie zum Beispiel
ein Buch kaufen wollen.

00:35:29,550 --> 00:35:35,250
Und insgesamt finden Sie im Moodle-Kurs sowohl
für den Haskell- als auch für den Prolog-Teil

00:35:35,250 --> 00:35:45,290
einige Links zu weiteren Büchern aus der
Bibliothek, in denen Sie stöbern können.

19 # slide
00:35:45,290 --> 00:35:49,540
Für den Prolog-Teil des Kurses würde
ich hauptsächlich dieses Buch empfehlen.

00:35:49,540 --> 00:35:53,530
Es ist auch ein Buch, das
kostenlos online verfügbar ist.

00:35:53,530 --> 00:35:57,750
Sie können es also online lesen, aber Sie
können auch eine Papierversion bestellen.

00:35:57,750 --> 00:36:01,350
Und es sollte auch Exemplare
in der Bibliothek geben.

00:36:01,350 --> 00:36:07,110
Und es gibt tatsächlich sehr viele weitere
Prolog-Bücher in der Bibliothek, sowohl in Englisch als

00:36:07,110 --> 00:36:08,790
auch in Deutsch.

00:36:08,790 --> 00:36:15,570
Einige von ihnen sind ziemlich alt, und die meisten von
ihnen decken viel mehr Material ab, als wir in diesem

00:36:15,570 --> 00:36:16,570
Kurs machen werden.

00:36:16,570 --> 00:36:20,790
Aber natürlich wären sie trotzdem nützlich, auch
um die einführenden Konzepte zu lernen, mit

00:36:20,790 --> 00:36:29,470
denen wir uns beschäftigen werden.
