0:00:01.680,0:00:05.040
Willkommen zurück zu einem
wahrscheinlich sehr kurzen Video.

0:00:05.040,0:00:10.880
Also, ich möchte zum einen etwas ausprobieren. Ich
hatte (gestern) diese Probleme mit meinem Set-up, dass

0:00:10.880,0:00:15.920
der interaktive Puffer immer langsamer wurde, was ich
normalerweise auf meinem lokalen Rechner nicht habe.

0:00:15.920,0:00:20.720
Aber irgendwie tritt es während der Aufzeichnung auf.
Also möchte ich testweise etwas anderes ausprobieren.

0:00:20.720,0:00:24.400
Und gleichzeitig gibt es noch zwei
oder drei Dinge, die ich noch

0:00:24.400,0:00:28.720
über QuickCheck sagen wollte und die ich in
dem anderen kurzen Video zuvor vergessen habe.

0:00:28.720,0:00:30.640
Lassen Sie mich also diese Gelegenheit nutzen.

0:00:32.000,0:00:33.360
Okay, rekapitulieren wir also.

0:00:33.360,0:00:37.920
Wir hatten diese Sortierfunktion, die zunächst
falsch war, und wir haben sie korrigiert.

0:00:37.920,0:00:43.680
Und wir hatten diese Gleichungen, um die
Eigenschaften dieser Funktion auszudrücken.

0:00:43.680,0:00:48.160
Und ich sprach über diesen Paradigmenwechsel, nicht
nur beim Programmieren, sondern auch beim Testen.

0:00:48.160,0:00:53.120
Anstatt also Unit-Tests zu schreiben,
ermutigt der deklarative Ansatz von Haskell

0:00:53.680,0:00:58.560
dazu, über Gleichungen nachzudenken. Denn
alles ist ein Ausdruck, und so können wir

0:00:59.120,0:01:04.160
Verhalten oder die Semantik unseres Programms
ausdrücken, indem wir über Gleichungen sprechen.

0:01:04.160,0:01:08.240
Und so ist es eine gute Praxis, statt nur
Unit-Tests zu schreiben, die Eigenschaften in

0:01:08.240,0:01:13.520
Form von Gleichungen aufzuschreiben und dann zum Beispiel
mit QuickCheck oder anderen Tools zu versuchen, die

0:01:13.520,0:01:17.440
Eingabedaten zum Beispiel mit zufälligen Auswahlmöglichkeiten zu
füllen und dann zu überprüfen, ob diese Eigenschaften zutreffen.

0:01:17.440,0:01:21.440
Und wir haben auch gesehen, dass wir Gegenbeispiele
erhalten, wenn eine Eigenschaft nicht zutrifft.

0:01:22.720,0:01:26.000
Eine Sache, die ich nicht gezeigt
habe, war, wie man es interpretiert,

0:01:26.000,0:01:31.040
oder wie die Ausgabe aussehen wird, wenn man mehr
als eine Sache hat, über die man quantifiziert.

0:01:31.040,0:01:34.240
Richtig, ich habe einige Beispiele
für diese Eigenschaften gezeigt.

0:01:34.240,0:01:38.880
Und wenn sie fehlschlugen, bekamen wir die
Eingabeliste, die die Eigenschaft fehlschlagen ließ.

0:01:38.880,0:01:43.840
Aber ich habe Ihnen nicht gezeigt, was passiert oder wie
es zu sehen ist, wenn wir mehr als eine Eingabe haben.

0:01:43.840,0:01:45.280
Und das könnte relevant sein,

0:01:45.280,0:01:49.120
denn Sie müssen vielleicht auch Funktionen
mit mehreren Parametern schreiben.

0:01:49.120,0:01:54.000
Und dann müssen Sie auch ein Gegenbeispiel mit
mehr als einem Eingabewert interpretieren können.

0:01:54.000,0:01:55.600
Okay, also das ist eine
Sache, die ich zeigen möchte.

0:01:56.160,0:02:00.000
Und erstens mache ich das nicht, indem
ich einen Fehler im Programm mache.

0:02:00.000,0:02:03.520
Ich mache das tatsächlich, indem ich
einfach eine falsche Eigenschaft einführe.

0:02:03.520,0:02:08.640
Nehmen wir also diese letzte Eigenschaft, ich könnte alle
Eigenschaften ausführen und die Prüfung wäre in Ordnung.

0:02:08.640,0:02:13.360
Aber lassen Sie mich die letzte Zeile irgendwie
zerstören, um etwas zu schreiben, das unsinnig ist.

0:02:14.160,0:02:22.080
Wenn ich das also jetzt ausführe, sollte ich
erhalten, dass es ein Gegenbeispiel gibt.

0:02:22.080,0:02:23.120
Okay, machen wir das.

0:02:23.840,0:02:26.240
Rufen wir den Interpreter hier auf.

0:02:31.280,0:02:33.680
Und lassen wir die Testsuite laufen.

0:02:34.240,0:02:37.200
Dann haben wir zunächst einige
Dinge, die in Ordnung sind.

0:02:37.200,0:02:42.720
Richtig, Sie sehen das, die ersten vier Eigenschaften
sind in Ordnung, sie bestehen alle 100 Tests.

0:02:42.720,0:02:44.880
Und dann sehen wir ein "Failed".

0:02:45.600,0:02:48.000
Es besagt, dass der Test fehlgeschlagen
ist, nach drei Tests und zwei Schrumpfungen,

0:02:48.000,0:02:50.400
Wir werden uns auch ansehen, was
das Schrumpfen hier bedeutet.

0:02:50.400,0:02:52.480
Aber lassen Sie uns zuerst
das Ergebnis interpretieren.

0:02:52.480,0:02:53.500
Und was erhalten wir?

0:02:53.500,0:02:54.640
Hier erhalten wir zwei Listen.

0:02:55.680,0:02:59.360
Und das entspricht der Tatsache, dass
diese Eigenschaft, die fehlschlägt,

0:02:59.360,0:03:02.960
zwei Eingabewerte hat, xs und ys.

0:03:02.960,0:03:06.240
Die Art und Weise, dies hier zu interpretieren,
ist: ein Gegenbeispiel. Richtig ist,

0:03:06.240,0:03:10.320
dass das Erste, was gedruckt wird, der
erste Parameter der Eigenschaft ist.

0:03:10.320,0:03:13.600
Und das Zweite ist der zweite,
wahrscheinlich verschiedene Eigenschaften.

0:03:13.600,0:03:15.120
Wenn Sie so etwas sehen, bedeutet das,

0:03:15.120,0:03:20.800
xs ist gleich der leeren Liste [], ys ist gleich dieser
Liste [1,0], was gegen diese Eigenschaft verstößt.

0:03:20.800,0:03:24.800
Und tatsächlich, wenn Sie jetzt die linke
Seite und die rechte Seite dieser beiden

0:03:26.320,0:03:30.160
Eingabedaten hier ausführen, würden wir
sehen, dass sie nicht dasselbe sind,

0:03:30.160,0:03:32.960
denn die Sortierfunktion ist korrekt,
aber diese Eigenschaft ist unsinnig.

0:03:33.920,0:03:38.160
Okay, das war also eine Sache, die ich zeigen
wollte, wie das einfach zu interpretieren ist.

0:03:38.160,0:03:40.320
Dann zum Schrumpfen, wie können
wir sehen, was hier passiert?

0:03:40.320,0:03:44.720
Ich habe ja schon erwähnt, dass QuickCheck
immer versucht, kleine Gegenbeispiele zu finden.

0:03:44.720,0:03:47.120
Also, selbst wenn das erste
Beispiel, das es findet

0:03:47.120,0:03:50.960
größer ist, versucht es kleinere, weil
es zunächst mit zufälligen Daten beginnt.

0:03:52.160,0:03:58.800
Die Hoffnung ist also, für QuickCheck und auch für die
Benutzer, dass man aussagekräftige kleine Gegenbeispiele erhält.

0:03:58.800,0:04:00.720
Denn die sind in der Regel
besser für die Fehlersuche.

0:04:00.720,0:04:03.600
Wenn Sie also eine Verletzung einer Eigenschaft
haben, wollen Sie wissen, was falsch ist.

0:04:03.600,0:04:04.560
Ist die Eigenschaft falsch?

0:04:04.560,0:04:05.600
Ist das Programm falsch?

0:04:05.600,0:04:08.320
Und fügen Sie dazu weitere Daten hinzu.

0:04:08.320,0:04:14.160
Und Sie können dies in Aktion sehen, wenn Sie
quickCheck wieder durch verboseCheck ersetzen,

0:04:14.160,0:04:21.760
denn dann sehen wir, was genau getestet wurde.

0:04:23.760,0:04:30.800
Hier, lassen Sie mich das ein wenig vergrößern, und in
diesem Fall haben wir vielleicht nicht viel geschrumpft,

0:04:31.360,0:04:35.760
weil tatsächlich, zufällig, das erste
was als Gegenbeispiel gefunden wurde,

0:04:36.320,0:04:38.000
bereits ein sehr kleiner Fall ist.

0:04:39.120,0:04:42.320
Aber das war reiner Zufall.

0:04:42.320,0:04:43.440
Versuchen wir es also noch einmal.

0:04:44.240,0:04:46.640
Und dann sehen wir zum
Beispiel, wenn wir zurückgehen,

0:04:47.440,0:04:53.920
dass das Erste hier, zum Beispiel,
das erste Ding, das erste Eingabepaar

0:04:53.920,0:04:58.480
das die Eigenschaft nicht erfüllte, dieses hier war,
das durch eine Zufallsstichprobe gewonnen wurde.

0:04:58.480,0:04:58.980
Das ist gut.

0:04:59.360,0:05:02.960
Und dann ist das etwas, das

0:05:04.080,0:05:08.080
QuickCheck auch schon hätte zeigen können: Die
Eigenschaft ist für diese beiden Eingaben falsch.

0:05:08.080,0:05:11.920
Natürlich würde das vielleicht ein bisschen zu viel
Nachdenken erfordern, um zu sehen, was falsch ist.

0:05:11.920,0:05:16.080
Also, eigentlich versucht QuickCheck jetzt
ein kleineres Gegenbeispiel zu finden.

0:05:16.080,0:05:19.200
So sehen Sie zum Beispiel hier im nächsten
Schritt anscheinend einfach versucht, na ja,

0:05:19.200,0:05:23.040
was wäre, wenn ich die erste Liste durch die leere
Liste ersetze, ist das immer noch ein Gegenbeispiel?

0:05:23.040,0:05:24.160
Und auch das ist fehlgeschlagen.

0:05:24.160,0:05:26.960
Also, jetzt wird QuickCheck dies
als Gegenbeispiel betrachten.

0:05:26.960,0:05:29.600
Dann versucht es, na ja,
vielleicht kann ich auch die

0:05:29.600,0:05:32.080
zweite Liste zu einer leeren Liste
machen, das wird immer noch fehlschlagen.

0:05:32.080,0:05:33.200
Also, als Nächstes versuchen wir das.

0:05:33.200,0:05:34.960
Aber das hat leider bestanden.

0:05:34.960,0:05:36.960
Also, das ist kein gutes Gegenbeispiel.

0:05:36.960,0:05:40.320
Dies ist also das bisher beste Beispiel für
ein Gegenbeispiel, das QuickCheck gefunden hat.

0:05:41.040,0:05:44.720
Und dann probieren wir ein paar andere Dinge aus.

0:05:44.720,0:05:51.200
So wird etwa diese Liste ausprobiert, aber auch diese
geht, dann versucht es diese Liste, aber – und diese –,

0:05:51.200,0:05:57.120
ja richtig, kürzt diese, aber dann versucht es die
zweite Hälfte dieser Liste, aber die hat bestanden,

0:05:57.120,0:06:02.800
also versucht es die erste Hälfte der Liste, diese ist
fehlgeschlagen, also ist es das neue beste Gegenbeispiel.

0:06:04.000,0:06:07.120
Und dann versucht er es noch
einmal, um das zu verkleinern,

0:06:07.120,0:06:09.600
also leere Liste, leere Liste
wurde eigentlich schon getestet.

0:06:09.600,0:06:15.920
Also, natürlich, es geht wieder durch, dann versucht
es vielleicht, nimmt den zweiten Teil dieser Liste,

0:06:15.920,0:06:20.720
aber das geht auch, also kann es kein kleines
Gegenbeispiel sein, et cetera, et cetera.

0:06:20.720,0:06:25.120
Also, dann versucht das System...

0:06:25.120,0:06:27.680
Wie könnte ich dieses Beispiel noch vereinfachen?

0:06:27.680,0:06:32.080
Anscheinend hat es versucht, statt was wäre,
wenn ich statt minus eins nur eins nehme.

0:06:32.880,0:06:35.760
Ist es immer noch ein Gegenbeispiel?

0:06:35.760,0:06:36.560
Ja, das ist es.

0:06:36.560,0:06:39.120
Und dann versucht es wahrscheinlich
auch die -3 loszuwerden.

0:06:39.680,0:06:44.880
Und irgendwann hat es gemerkt, na ja, [0,3] geht.

0:06:44.880,0:06:46.240
Also ist das kein Gegenbeispiel.

0:06:47.680,0:06:52.160
Aber minus zwei geht auch nicht, et cetera.

0:06:52.160,0:06:59.520
Und dann, irgendwann,
beschließt QuickCheck, na ja,

0:06:59.520,0:07:04.320
das ist das kleinste Gegenbeispiel, das ich finden kann,
das kleinste, in dem Sinne, dass es eine kurze Liste ist,

0:07:04.320,0:07:08.240
zumindest die erste ist leer, und
die zweite hat nur zwei Elemente.

0:07:08.240,0:07:12.080
Und es hat auch versucht, die Werte
klein zu machen, es konnte nicht null

0:07:12.080,0:07:15.200
und eins nehmen, denn das hätte den Wert
aber es kann null und minus eins nehmen.

0:07:15.200,0:07:16.960
Und das ist irgendwie das konzeptionell

0:07:16.960,0:07:22.880
kleinste Gegenbeispiel, zu der Eigenschaft,
die wir behauptet haben, die aber falsch war.

0:07:23.600,0:07:25.680
Und natürlich sieht man normalerweise nicht alle

0:07:25.680,0:07:28.960
diese unmittelbaren Schritte, weil wir
quickCheck anstelle von verboseCheck verwenden.

0:07:28.960,0:07:32.000
Aber gut, zumindest an diesen
Punkten können Sie sehen, wie sehr

0:07:32.960,0:07:35.120
QuickCheck versucht hat, ein
kleines Gegenbeispiel zu finden.

0:07:35.120,0:07:40.320
So ist es auf dieses erste Listenpaar nicht gestoßen,
die nach fünf Tests jeweils vier Elemente hatten,

0:07:40.320,0:07:42.320
und dann hat es mehrere
Schrumpfungen durchgeführt,

0:07:42.320,0:07:47.040
und schließlich kam es zu diesem
als sein bestes Gegenbeispiel.

0:07:47.040,0:07:50.800
Und das wird dann gezeigt, zum
Beispiel, um – wenn eine Ihrer

0:07:52.160,0:07:55.920
Funktionen gegen eine Eigenschaft verstößt,
die wir von Ihrer Lösung erwarten.

0:07:56.880,0:07:58.000
Das ist gut.

0:07:58.000,0:08:01.600
Und natürlich würde ich hier nicht wirklich
diese falsche Eigenschaft hier hinschreiben.

0:08:01.600,0:08:06.160
Lassen Sie mich also zurück zur richtigen
Eigenschaft und dann können Sie sie überprüfen.

0:08:07.440,0:08:12.480
Diese hier ist natürlich richtig.

0:08:16.320,0:08:17.760
Ich muss natürlich neu laden.

0:08:19.280,0:08:20.720
Dann lasse ich es laufen.

0:08:21.280,0:08:24.080
Und das ist wieder richtig.

0:08:24.080,0:08:28.000
Aber jetzt wissen Sie auch,
wie diese Gegenbeispiele

0:08:28.560,0:08:37.520
zustande kommen und wie sie Ihnen zum Beispiel
innerhalb des Autotools präsentiert werden.
