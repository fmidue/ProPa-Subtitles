70 # slide
00:00:01,780 --> 00:00:08,250
Okay, ich wollte damit beginnen,
einige Beobachtungen aus den Übungen zu geben.

00:00:08,250 --> 00:00:17,580
Und in gewissem Maße habe ich
das natürlich schon im vorherigen Video getan.

71 # slide
00:00:17,580 --> 00:00:26,180
Insbesondere habe ich dort über den Aspekt
der Eta-Reduktion gesprochen, vor dem Autotool oder HLint

00:00:26,180 --> 00:00:27,180
manchmal warnen.

00:00:27,180 --> 00:00:28,180
Einige von Ihnen haben das
schon in ihren eigenen Einreichungen gesehen.

00:00:28,180 --> 00:00:34,540
Ich muss das hier in dieser Folie nicht
noch einmal durchsprechen, weil es im vorherigen Video

00:00:34,540 --> 00:00:35,540
steht.

00:00:35,540 --> 00:00:41,909
Hier haben Sie also nur ein weiteres
Beispiel, etwas, das wahrscheinlich letztes Jahr aufgetreten ist.

00:00:41,909 --> 00:00:49,249
Also, wieder die gleiche Idee: eine Funktion zu
haben, die ein Argument nimmt, das sie einfach an

00:00:49,249 --> 00:00:52,839
eine andere Funktion weitergibt.

00:00:52,839 --> 00:00:56,449
Jemand hat also eine Ball-Funktion definiert, die
eine "time" annimmt und ein Bild liefert.

00:00:56,449 --> 00:00:57,749
Und wie ist "ball" definiert?

00:00:57,749 --> 00:01:04,089
Zu jedem Zeitpunkt t gibt sie einen Vollkreis mit
dem Radius t, was genau dasselbe ist, wie einfach

00:01:04,089 --> 00:01:06,600
zu sagen: "ball
ist diese solidCircle-Funktion".

00:01:06,600 --> 00:01:12,330
Definiert man "ball" als Alias, einen anderen
Namen für die solidCircle-Funktion, dann drückt das die gleiche

00:01:12,330 --> 00:01:20,130
Idee aus, als würde man sagen: "ball zu einem
gegebenen Zeitpunkt t ist solidCircle zu diesem gegebenen Zeitpunkt t".

00:01:20,130 --> 00:01:23,810
Und die zweite Version
ist etwas eleganter.

00:01:23,810 --> 00:01:27,289
Schon rein pragmatisch
gesehen, könnte man sagen:

00:01:27,289 --> 00:01:29,689
Wenigstens muss man sich keine
Gedanken über den Parameternamen machen.

00:01:29,689 --> 00:01:35,030
In diesem Fall ist vielleicht t die offensichtliche Wahl;
aber in einer anderen Situation haben Sie vielleicht keine

00:01:35,030 --> 00:01:36,550
gute Idee, wie Sie
Ihren Parameter benennen sollen.

00:01:36,550 --> 00:01:44,110
Nun, wenn Sie die Eta-Reduktion verwenden,
müssen Sie die Parameter nicht immer benennen.

00:01:44,110 --> 00:01:52,210
Und dieses Beispiel haben wir auch in der
aufgezeichneten Videodemonstration mit dem sich öffnenden Rechteck gesehen.

00:01:52,210 --> 00:01:58,960
Und ich möchte hier betonen, dass die flip-Funktion, die
ich dort verwendet habe, um dies in ein Rechteck

00:01:58,960 --> 00:02:02,400
zu verwandeln, das sich in die
andere Richtung öffnet, keine Picture-spezifische Primitive war.

00:02:02,400 --> 00:02:05,020
Es wurde also nicht das Bild gespiegelt.

00:02:05,020 --> 00:02:06,450
Es wurde
die rectangle-Funktion gespiegelt.

00:02:06,450 --> 00:02:09,700
Es würde also auf jede
Funktion mit zwei Argumenten zutreffen.

00:02:09,700 --> 00:02:14,650
In diesem Fall, für die rectangle-Funktion,
hat es genau den Effekt, dass

00:02:14,650 --> 00:02:19,959
die Form des Rechtecks geometrisch gespiegelt wird,
weil wir die Parameterargumente der rectangle-Funktion gespiegelt

00:02:19,959 --> 00:02:20,959
haben.

00:02:20,959 --> 00:02:23,760
Aber die flip-Funktion selbst ist keine
Funktion, die nur auf Bilder wirkt.

00:02:23,760 --> 00:02:28,040
Sie ist eine Funktion, die auf andere
Funktionen wirkt; in diesem Fall auf die rectangle-Funktion.

00:02:28,040 --> 00:02:34,989
Und Sie haben das in Aktion gesehen,
was das eigentlich bedeutet, für diesen Fall.

00:02:34,989 --> 00:02:38,140
Und eine weitere Bemerkung
vielleicht an dieser Stelle ist:

00:02:38,140 --> 00:02:44,260
Die Tatsache, dass wir die Eta-Reduktion haben, beziehungsweise dass
diese angewendet werden kann, hat auch einen gewissen Einfluss

00:02:44,260 --> 00:02:46,890
auf das Design von APIs in Haskell.

00:02:46,890 --> 00:02:54,540
Wenn Sie also darüber nachdenken müssen, wie zum
Beispiel die Parameterreihenfolge Ihrer selbst definierten Funktion sein

00:02:54,540 --> 00:02:59,599
soll, lohnt es sich, darüber nachzudenken, welches
der Parameter ist, der vielleicht oft an

00:02:59,599 --> 00:03:00,769
eine andere Stelle weitergegeben wird.

00:03:00,769 --> 00:03:04,439
Denn dann würde es Sinn ergeben, diesen
Parameter zum letzten Parameter zu machen, weil

00:03:04,439 --> 00:03:08,489
Sie dann diesen Trick,
dieses Eta-Reduktions-Refactoring anwenden können.

00:03:08,489 --> 00:03:14,720
Das ist eigentlich auch der Grund, so
könnte man argumentieren, warum CodeWorld in den

00:03:14,720 --> 00:03:16,879
Transformationsfunktionen immer das Bild
als letztes Argument hat.

00:03:16,879 --> 00:03:22,780
Wenn Sie zum Beispiel an die
translated-Funktion denken, sie nimmt zwei Koordinaten und

00:03:22,780 --> 00:03:23,780
das Bild.

00:03:23,780 --> 00:03:27,010
Sie könnte auch das Bild und dann die
beiden Koordinaten nehmen, aber dann könnte man in manchen

00:03:27,010 --> 00:03:31,060
Situationen, in denen es sinnvoll
ist, nicht die Eta-Reduktion anwenden.

00:03:31,060 --> 00:03:37,430
Es macht also Sinn, beim Entwurf einer
API, beim Entwurf der Funktionstypen einer Bibliothek, z. B.

00:03:37,430 --> 00:03:42,870
in Haskell oder anderen ähnlichen Sprachen,
das Datenstrukturargument (das in diesem Fall

00:03:42,870 --> 00:03:46,909
das Picture-Argument ist, und nicht die
Parameterargumente für das Bewegen in x- und

00:03:46,909 --> 00:03:53,930
y-Richtung) immer als
letztes Argument zu setzen.

00:03:53,930 --> 00:03:57,160
Denn das eröffnet Möglichkeiten,
die Eta-Reduktion gut zu nutzen.

00:03:57,160 --> 00:04:01,980
Es ist für Sie im Moment nicht super relevant,
weil Sie keine eigenen Bibliotheken definieren oder Bibliotheken

00:04:01,980 --> 00:04:05,030
für den Verbrauch von anderen entwerfen.

00:04:05,030 --> 00:04:11,049
Aber es ist vielleicht trotzdem interessant,
sich zumindest dieser Wahl bewusst zu sein.

72 # slide
00:04:12,049 --> 00:04:24,380
Dann noch eine weitere Beobachtung, die auch
immer wieder auftaucht, insbesondere auch in Aufgabe 8.

00:04:24,380 --> 00:04:33,530
Das war aus einigen Ihrer Einreichungen
ersichtlich, nämlich die übermäßige Verwendung von access-by-index.

00:04:33,530 --> 00:04:39,680
Als Faustregel in Haskell gilt: Wenn man auf
eine Datenstruktur per Index zugreift, dann war das meist

00:04:39,680 --> 00:04:41,210
nicht die beste Wahl des Ausdrucks.

00:04:41,210 --> 00:04:44,419
Und manchmal werden wir
das sogar aktiv verhindern.

00:04:44,419 --> 00:04:51,440
Und das habe ich im Fall von Aufgabe 8
mit meiner Moodle-Nachricht vor ein paar Tagen (anderes Jahr) versucht zu verhindern.

00:04:51,440 --> 00:04:56,440
Ich habe erklärt, dass man wirklich mit der
Liste als Ganzes arbeiten sollte, und nicht mit

00:04:56,440 --> 00:04:57,820
bestimmten Spezialfällen.

00:04:57,820 --> 00:05:03,400
Ich habe gesehen, dass einige Studierende Indexzugriffe verwenden, was
in Haskell zwar möglich ist, aber normalerweise nicht die beste

00:05:03,400 --> 00:05:04,400
Wahl ist.

00:05:04,400 --> 00:05:09,710
Und selbst die Aufgabenbeschreibung wies in diesem Fall darauf
hin, dass man versuchen sollte, eine List Comprehension zu

00:05:09,710 --> 00:05:10,710
verwenden.

00:05:10,710 --> 00:05:12,500
Was meine ich also damit?

00:05:12,500 --> 00:05:15,860
Stellen Sie sich etwas wie folgt vor:

00:05:15,860 --> 00:05:22,620
Man nimmt eine Liste, aus dieser
Liste entnimmt man nacheinander einige Argumente.

00:05:22,620 --> 00:05:26,250
Irgendein Argument wird aus dieser Liste gezogen, und
dann berechnen wir etwas aus diesem Argument, stellen alle

00:05:26,250 --> 00:05:29,020
Ergebnisse in eine Liste, und dann machen
wir, was auch immer mit dieser Liste.

00:05:29,020 --> 00:05:36,770
Das ist also ein schöner, reichhaltiger Ausdruck in der
Form, wie ich ihn auch letzte Woche in Beispielen vorgestellt

00:05:36,770 --> 00:05:38,400
habe.

00:05:38,400 --> 00:05:44,160
Natürlich könnten Sie, und manche Studierende haben
das auch getan, stattdessen Code wie diesen schreiben.

00:05:44,160 --> 00:05:46,090
Also, was sagt das aus?

00:05:46,090 --> 00:05:47,729
Es besagt:

00:05:47,729 --> 00:05:53,110
Gib mir die Liste und ich nehme die Länge
und dann baue ich einen Index von null auf

00:05:53,110 --> 00:05:58,460
(denn, wie Sie feststellen werden, beginnt die
Listenindizierung in Haskell mit dem Index null).

00:05:58,460 --> 00:06:08,830
Berechnen Sie also den Index als jeden Wert von null
bis zur Länge der Liste -1, und greifen Sie dann

00:06:08,830 --> 00:06:13,729
mit diesem Index auf die Listenelemente zu, berechnen
Sie daraus etwas und machen Sie, was auch

00:06:13,729 --> 00:06:14,729
immer damit.

00:06:14,729 --> 00:06:20,010
Die Ausdrücke, die Sie hier sehen, sind
äquivalent in dem Sinne, dass sie das Gleiche

00:06:20,010 --> 00:06:21,560
berechnen, aber der
erste ist der idiomatische.

00:06:21,560 --> 00:06:23,950
Der erste ist das,
was wirklich die Absicht ausdrückt.

00:06:23,950 --> 00:06:31,139
Der zweite arbeitet irgendwie künstlich mit Indizes
und ist nicht sehr elegant und auch

00:06:31,139 --> 00:06:32,740
nicht sehr gut wartbar.

00:06:32,740 --> 00:06:43,690
Dies wird manchmal Indexitis genannt (die
Krankheit, zu viele Indizes zu verwenden).

00:06:43,690 --> 00:06:51,141
Das mag in einigen anderen Sprachen die
einzige Möglichkeit sein, mit Datenstrukturen zu arbeiten, aber

00:06:51,141 --> 00:06:52,479
sicher nicht in Haskell.

00:06:52,479 --> 00:06:58,479
Versuchen Sie also, im Sinne
des ersten Beispiels hier zu arbeiten.

73 # slide
00:06:58,479 --> 00:07:04,560
Das bringt uns auch zu
einem allgemeineren Arbeiten mit Listen.

00:07:04,560 --> 00:07:10,460
Dies wird also das Thema der nächsten paar Folien
und wahrscheinlich auch des größten Teils dieses Videos sein.

00:07:10,460 --> 00:07:14,669
Natürlich können Sie in Haskell nicht nur
mit List Comprehensions arbeiten, wenn Sie mit Listen

00:07:14,669 --> 00:07:15,669
arbeiten.

00:07:15,669 --> 00:07:16,669
Es gibt noch andere Funktionen.

00:07:16,669 --> 00:07:20,710
Es gibt tatsächlich eine kleine, aber
mächtige Bibliothek von Funktionen auf Listen.

00:07:20,710 --> 00:07:26,020
Aber selbst dann ist
die Listenindizierung der letzte Ausweg.

00:07:26,020 --> 00:07:29,050
Also, normalerweise ist es keine
gute Idee, mit Listenindizes zu arbeiten.

00:07:29,050 --> 00:07:30,889
Ich kann das nicht genug betonen.

00:07:30,889 --> 00:07:39,599
Dennoch zunächst ein paar allgemeinere Anmerkungen
zu Listen und dann werde ich einige

00:07:39,599 --> 00:07:45,620
der Funktionen vorstellen, die Sie vielleicht
für einige der nächsten Übungsaufgaben verwenden möchten.

74 # slide
00:07:45,620 --> 00:07:53,240
Generell fällt auf, wenn Sie sich die
nächsten paar Vorlesungen und Übungen anschauen, dass wir

00:07:53,240 --> 00:07:58,509
von nun an in den Beispielen in Vorlesungen
und Übungen sehr viel mit Listen arbeiten werden.

00:07:58,509 --> 00:08:02,129
Bislang haben wir die meisten
Beispiele mit der CodeWorld-Bibliothek gemacht.

00:08:02,129 --> 00:08:07,970
Sie haben also den Typ 'Picture'
und alle möglichen Operationen darauf kennengelernt.

00:08:07,970 --> 00:08:14,600
Und in ähnlicher Weise wird es im nächsten
Material hauptsächlich um Listen und Funktionen gehen, die auf

00:08:14,600 --> 00:08:15,840
Listen arbeiten.

00:08:15,840 --> 00:08:22,090
Wir haben hier also
zwei etwas gegensätzliche Fälle.

00:08:22,090 --> 00:08:27,319
In gewissem Sinne ist der 'Picture'-Typ nicht abstrakt, weil
Sie ihn tatsächlich zeichnen können und eine Menge darüber sehen,

00:08:27,319 --> 00:08:33,230
was Ihr Code macht, aber er ist in dem Sinne
abstrakt, dass Sie nicht wirklich Operationen haben, um in das

00:08:33,230 --> 00:08:34,270
Innere des Picture zu schauen.

00:08:34,270 --> 00:08:36,870
Alle Operationen, die Sie durchgeführt
haben, sind also *auf* Bildern.


00:08:36,870 --> 00:08:38,710
Sie haben nie
*innerhalb* eines Picture geschaut.

00:08:38,710 --> 00:08:40,480
Bei Listen ist das Gegenteil der Fall.

00:08:40,480 --> 00:08:46,320
Für Listen werden wir uns verschiedene Möglichkeiten
der Fallunterscheidung und des Einblicks in das Innere

00:08:46,320 --> 00:08:49,420
von Listen ansehen.

00:08:49,420 --> 00:08:57,950
Denn sie sind einer der grundlegenden zerlegbaren
Typen in Haskell, anders als der Typ

00:08:57,950 --> 00:08:59,850
'Picture'.

00:08:59,850 --> 00:09:03,470
Warum dieser Fokus auf Listen?

00:09:03,470 --> 00:09:05,580
Nicht, weil Listen immer
die beste Datenstruktur sind.

00:09:05,580 --> 00:09:11,070
Das sind sie sicherlich nicht so oft, insbesondere
wenn Sie mehr Code in der realen Welt schreiben.

00:09:11,070 --> 00:09:16,880
Es gibt geeignetere Datenstrukturen, um
etwas in Haskell zu tun.

00:09:16,880 --> 00:09:21,100
Und bis zu einem gewissen Grad werden Sie
auch sehen, wie Sie Ihre eigenen Datentypen definieren können.

00:09:21,100 --> 00:09:22,770
Aber das ist nicht
das, womit wir anfangen werden.

00:09:22,770 --> 00:09:26,900
Wir werden jetzt mit Listen beginnen, weil
es sie schon gibt, sie haben syntaktische

00:09:26,900 --> 00:09:30,200
Unterstützung wie List Comprehensions,
aber auch andere Funktionen.

00:09:30,200 --> 00:09:37,210
Wir werden also, hauptsächlich aus didaktischen Gründen,
um schnell Beispiele schreiben zu können, mit Listen

00:09:37,210 --> 00:09:38,210
arbeiten.

00:09:38,210 --> 00:09:40,000
Nicht, weil Sie
immer Listen verwenden sollten.

00:09:40,000 --> 00:09:45,810
Das ist eine wichtige andere Lektion,
die ich im Voraus machen möchte.

00:09:45,810 --> 00:09:50,130
Es gibt eine
Menge Listenunterstützung in Haskell.

00:09:50,130 --> 00:09:53,460
Sie sehen das schon an
der speziellen Syntax wie List Comprehensions.

00:09:53,460 --> 00:09:58,470
In gewissem Sinne ist das
teilweise auf historische Präzedenzfälle zurückzuführen.

00:09:58,470 --> 00:10:03,700
Ich habe, ich glaube in der ersten
Vorlesung, Lisp als eine alte funktionale Sprache erwähnt.

00:10:03,700 --> 00:10:09,890
In gewissem Sinne könnte man es also als Vorgänger
von Haskell sehen, auch wenn es eine Menge Unterschiede gibt.

00:10:09,890 --> 00:10:11,950
Der Name Lisp
kommt von "Listenprozessor".

00:10:11,950 --> 00:10:17,690
Dort waren also Listen das A und O.

00:10:17,690 --> 00:10:26,000
Auch Haskell hat eine Menge Unterstützung
für Listenverarbeitung, trotz meiner vorherigen Bemerkungen,

00:10:26,000 --> 00:10:30,380
dass man eigentlich oft
andere Datenstrukturen verwenden sollte.

00:10:30,380 --> 00:10:36,340
Ich habe bereits erwähnt, dass es eine
spezielle syntaktische Unterstützung gibt, die auch für unsere

00:10:36,340 --> 00:10:38,290
Beispielbetrachtungen hilfreich ist.

00:10:38,290 --> 00:10:42,570
Für alle anderen Datenstrukturen
trifft das nicht zu.

00:10:42,570 --> 00:10:49,600
Eine weitere Sache, die ich
wiederholen möchte, ist: Haskell-Listen sind homogen.

00:10:49,600 --> 00:10:50,730
Das ist anders als bei Lisp.

00:10:50,730 --> 00:10:55,710
In Lisp könnten Sie alles in dieselbe
Liste packen, während in Haskell Listen homogen sind.

00:10:55,710 --> 00:11:00,530
Das bedeutet, dass Sie keine unterschiedlichen Typen
von Elementen in derselben Liste haben können.

00:11:00,530 --> 00:11:04,160
Sie können eine Liste von Zeichen haben, Sie können
eine Liste von Zeichenketten haben, Sie können eine Liste von

00:11:04,160 --> 00:11:07,390
Zahlen haben, Sie können eine Liste von Paaren von
Zeichenketten und Zeichen haben; aber Sie können keine Liste

00:11:07,390 --> 00:11:11,770
haben, in der verschiedene
Arten von Werten gemischt sind.

00:11:11,770 --> 00:11:14,910
Es gibt andere Datenstrukturen, die
das erlauben, aber nicht Listen.

00:11:14,910 --> 00:11:20,610
Das müssen Sie also immer im Hinterkopf
haben, wenn Sie zum Beispiel über die Funktionen

00:11:20,610 --> 00:11:27,330
nachdenken, die ich
Ihnen jetzt zeigen werde.

75 # slide
00:11:27,330 --> 00:11:32,750
Ich möchte Ihnen ein paar Funktionen
aus der Standardbibliothek für Listen vorstellen.

00:11:32,750 --> 00:11:39,450
In gewissem Sinne könnte man diese als eine
kleine domänenspezifische Sprache von Funktionen auf Listen betrachten.

00:11:39,450 --> 00:11:43,100
Es ist eine
domänenspezifische Sprache auf Listen.

00:11:43,100 --> 00:11:48,860
Und zu einem guten Teil sind es Accessor-Funktionen,
also: etwas aus einer Liste herausholen; genau die

00:11:48,860 --> 00:11:52,060
Art von Funktionen, die
Sie für Pictures nicht haben.

00:11:52,060 --> 00:11:55,450
Denn für Bilder konnten Sie nur neue
Bilder konstruieren, Sie konnten ein Bild nicht

00:11:55,450 --> 00:11:57,840
auseinandernehmen.

00:11:57,840 --> 00:12:03,460
Ich werde diese Funktionen nicht vorstellen, indem
ich die Definitionen zeige oder die Semantik in

00:12:03,460 --> 00:12:04,730
irgendeinem mathematischen Sinn erkläre.

00:12:04,730 --> 00:12:11,040
Ich werde einfach Beispiele und die Namen
der Funktionen nennen, und dann sollten diese

00:12:11,040 --> 00:12:14,450
Beispiele deutlich genug sein, um Ihnen
zu sagen, was die Funktion tut.

00:12:14,450 --> 00:12:18,820
Sie können diese Funktionen also
fortan beim Schreiben Ihrer Übungsaufgaben verwenden.

00:12:18,820 --> 00:12:20,200
Also, was haben wir?

00:12:20,200 --> 00:12:25,080
Wir haben etwa eine Funktion,
die auf einen Präfix einer Liste zugreift.

00:12:25,080 --> 00:12:27,900
Sagen wir also, wir haben eine
Liste mit den Werten 1 bis 10.

00:12:27,900 --> 00:12:29,440
Wir wollen die
ersten drei Elemente nehmen.

00:12:29,440 --> 00:12:31,831
Wir können einfach sagen:
"take 3" aus dieser Liste.

00:12:31,831 --> 00:12:36,020
Und was wir erhalten, ist genau das,
was Sie hier auf der rechten Seite sehen.

00:12:36,020 --> 00:12:42,840
Ich zeige links immer einen Ausdruck
auf Listen (unter Verwendung einiger der Listenfunktionen),



00:12:42,840 --> 00:12:48,280
und rechts sehen Sie dann, wozu
dieser auswertet (wenn Sie diesen Ausdruck z. B.

00:12:48,280 --> 00:12:54,740
in den Haskell-Interpreter
GHCi eingeben würden).

00:12:54,740 --> 00:12:57,620
Sie können also einen Präfix nehmen.

00:12:57,620 --> 00:12:59,010
Sie können einen Präfix weglassen.

00:12:59,010 --> 00:13:02,830
Wenn Sie die ersten drei Elemente von 1
bis 10 weglassen, dann erhalten Sie die Liste, die

00:13:02,830 --> 00:13:06,970
aus allen Elementen von 4 bis 10 besteht.

00:13:06,970 --> 00:13:08,570
Das ist nicht überraschend.

00:13:08,570 --> 00:13:11,110
Und Sie können prüfen,
ob eine Liste leer ist.

00:13:11,110 --> 00:13:14,140
Dies ist also die Null-Funktion.

00:13:14,140 --> 00:13:17,880
Man könnte sie auch für "isNull"
halten, aber eigentlich heißt sie nur "null".

00:13:17,880 --> 00:13:19,500
Also, wir geben ihr die Liste.

00:13:19,500 --> 00:13:21,910
Und wenn Sie ihr eine leere
Liste geben, dann gibt sie True zurück.

00:13:21,910 --> 00:13:26,580
Und wenn Sie ihr eine nicht-leere Liste geben, zum
Beispiel eine nicht-leere Zeichenkette (wovon wir wissen, dass sie einfach

00:13:26,580 --> 00:13:35,100
eine Liste von Zeichen ist), dann wird die
Ausgabe False sein, weil dies keine leere Liste ist.

00:13:35,100 --> 00:13:40,490
Im Allgemeinen können Sie nicht nur prüfen, ob eine Liste
leer ist oder nicht, sondern auch die Länge einer Liste berechnen.

00:13:40,490 --> 00:13:41,910
Auch dies ist nicht überraschend.

00:13:41,910 --> 00:13:48,460
Gegeben eine Liste, gibt das Ihnen die Anzahl der
Elemente in der Liste; in diesem Fall die Anzahl der

00:13:48,460 --> 00:13:50,340
Zeichen, natürlich nicht nur
die Anzahl der eindeutigen Elemente.

00:13:50,340 --> 00:13:53,450
Wenn Sie also fünf 'a's
haben, gibt es Ihnen auch 5.

00:13:53,450 --> 00:13:55,960
Es wird nicht zählen,
wie viele verschiedene Elemente vorkamen.

00:13:55,960 --> 00:13:57,990
Es wird einfach sagen,
wie lang die Liste ist.

00:13:57,990 --> 00:14:01,760
In diesem Fall ist die Antwort also 5.

00:14:01,760 --> 00:14:04,970
Sie können auf das
erste Element einer Liste zugreifen.

00:14:04,970 --> 00:14:10,750
Es ist etwas ähnlich wie "take 1",
aber "take 1" würde das Ergebnis als Liste zurückgeben.

00:14:10,750 --> 00:14:16,250
Also wäre "take 1" dieser Liste die Singleton-Liste,
die 1 enthält (etwa so: [1]), während "head

00:14:16,250 --> 00:14:18,420
[1..10]" nur 1 ist (etwa so: 1).

00:14:18,420 --> 00:14:23,510
Oder im Fall einer Zeichenkette ist head "abcde"
nicht eine Zeichenkette, die aus dem Buchstaben 'a' besteht

00:14:23,510 --> 00:14:26,200
(wie hier: "a"), sondern das
Zeichen 'a' (wie hier: 'a').
(Achtung: 'a' ist ein Char, "a" ist ein String, also [Char].)

00:14:26,200 --> 00:14:34,350
Denn dieser String ist eine Liste von
Zeichen, und dies ist das erste Zeichen darin.

00:14:34,350 --> 00:14:36,530
Sie können auch auf
das letzte Element zugreifen.

00:14:36,530 --> 00:14:44,440
In diesem Fall wäre last [1..10] die
Zahl 10, und last "abcde" ist das

00:14:44,440 --> 00:14:47,510
Zeichen 'e'.

00:14:47,510 --> 00:14:49,950
Dann können Sie auf
den "tail" einer Liste zugreifen.

00:14:49,950 --> 00:14:55,180
Also, "head" bedeutet, dass Sie das erste Element der
Liste erhalten, und "tail" bedeutet, dass Sie den ganzen

00:14:55,180 --> 00:14:56,180
Rest erhalten.

00:14:56,180 --> 00:15:02,170
Wenn Sie also das erste Element
wegnehmen, bleibt die Liste "bcde" übrig.

00:15:02,170 --> 00:15:08,520
Wir könnten auch "tail" auf
[1..10] anwenden und würden [2..10] erhalten.

00:15:08,520 --> 00:15:11,690
In diesem Sinne
korrespondiert "tail" zu "head".

00:15:11,690 --> 00:15:15,270
Es gibt Ihnen das, was übrig
bleibt, wenn Sie den Kopf wegnehmen.

00:15:15,270 --> 00:15:17,140
Und etwas Ähnliches gibt es für "last".

00:15:17,140 --> 00:15:19,890
Also gibt "last" das letzte
Element in der Liste an.

00:15:19,890 --> 00:15:22,870
Und "init" liefert die
Liste ohne dieses letzte Element.

00:15:22,870 --> 00:15:26,230
Hier ergibt "last" also
"e", und "init" ergibt "abcd".

00:15:26,230 --> 00:15:28,470
Natürlich sind dies Listen
und nicht nur Zeichen.

00:15:28,470 --> 00:15:32,770
Hier bekommen wir ein Zeichen, weil es ein
Element aus der Liste ist, aber "tail" und

00:15:32,770 --> 00:15:34,220
"init" müssen immer Listen zurückgeben.

00:15:34,220 --> 00:15:38,840
In diesem Fall ist es also
eine Liste von Zeichen, ein String.

00:15:38,840 --> 00:15:46,870
Dann gibt es noch ausgefallenere Möglichkeiten, eine Liste aufzuteilen,
und zwar nicht nur in den Kopf und den Rest,

00:15:46,870 --> 00:15:51,970
oder das Letzte und das, was
davor kommt, sondern an irgendeinem beliebigen Punkt.

00:15:51,970 --> 00:15:56,270
Sie könnten also sagen, ich habe eine Zeichenkette /
Liste und möchte sie an einem beliebigen Punkt aufteilen.

00:15:56,270 --> 00:16:02,170
Und das bedeutet dann, dass Sie so viele
Elemente vom Anfang der Liste nehmen, wie die

00:16:02,170 --> 00:16:03,170
Zahl sagt.

00:16:03,170 --> 00:16:06,900
In diesem Fall also "abc", und der
Rest wird in ein zweites Ergebnis gepackt.

00:16:06,900 --> 00:16:12,810
In gewissem Sinne könnte man dies also
als eine Kombination aus "take" und "drop" sehen.

00:16:12,810 --> 00:16:19,800
Sie erhalten "take 3" und Sie erhalten "drop 3",
aber beide werden von einer Funktion zurückgegeben, anstatt zwei

00:16:19,800 --> 00:16:22,840
verschiedene Funktionen für
diese Aufgabe zu haben.

00:16:22,840 --> 00:16:27,310
Dann gibt es
noch den berüchtigten Index-Zugriff.

00:16:27,310 --> 00:16:33,300
Man kann also in Haskell mit diesem Operator '!!'
auf ein Element an einem bestimmten Index zugreifen.

00:16:33,300 --> 00:16:35,100
Die Zählung beginnt bei 0.

00:16:35,100 --> 00:16:41,080
Aber wie ich schon sagte, ist ein solcher
Index-Zugriff in Code, den Sie in Ihren Übungen

00:16:41,080 --> 00:16:42,640
schreiben, fast verboten.



00:16:42,640 --> 00:16:47,580
Sie sollen also normalerweise Ihren
Code ohne den Index-Operator schreiben.

00:16:47,580 --> 00:16:52,040
Einfach, weil es in Haskell eine
sehr schlechte Angewohnheit ist, diesen zu benutzen.

00:16:52,040 --> 00:16:54,560
Normalerweise gibt es einen besseren Weg.

00:16:54,560 --> 00:17:00,720
Dann gibt es noch andere Operationen, die
auf einer Liste als Ganzes arbeiten, anstatt auf

00:17:00,720 --> 00:17:02,030
Teile davon zuzugreifen.

00:17:02,030 --> 00:17:04,630
Zum Beispiel ist
die Funktion "reverse" nützlich.

00:17:04,630 --> 00:17:07,660
Sie nimmt eine Liste und
gibt sie in umgekehrter Reihenfolge zurück.

00:17:07,660 --> 00:17:14,020
Bei einer Zeichenkette erzeugt sie also einfach die
Zeichenkette, als ob Sie sie rückwärts lesen würden.

00:17:14,020 --> 00:17:16,060
Ich denke, das ist sehr natürlich.

00:17:16,060 --> 00:17:18,800
Die Umkehrung der leeren
Liste ist die leere Liste.

00:17:18,800 --> 00:17:21,750
Die Umkehrung des leeren Strings
ist natürlich auch der leere String.

00:17:21,750 --> 00:17:24,880
Dann können Sie Listen
oder Strings miteinander kombinieren (mit '++').

00:17:24,880 --> 00:17:28,770
Hier wieder für Strings geschrieben, aber es
funktioniert auch mit anderen Arten von Listen.

00:17:28,770 --> 00:17:31,650
Aber beides muss natürlich die
gleiche Art von Listen sein.

00:17:31,650 --> 00:17:36,860
Sie können also nicht den String
"abc" und die Liste [1..10] verketten.

00:17:36,860 --> 00:17:39,580
Aber Sie könnten z. B.
diese beiden Listen konkatenieren.

00:17:39,580 --> 00:17:41,490
Und was macht es?

00:17:41,490 --> 00:17:44,750
Es gibt die kombinierte
Liste oder Zeichenkette zurück.

00:17:44,750 --> 00:17:48,950
Dann gibt es noch andere
Möglichkeiten, zwei Listen zu kombinieren.

00:17:48,950 --> 00:17:51,330
Zum Beispiel können
Sie zwei Listen "zippen" (mit der zip-Funktion).

00:17:51,330 --> 00:17:56,010
Das bedeutet, dass sie nicht
verkettet (hintereinander) werden, sondern paarweise

00:17:56,010 --> 00:17:57,310
kombiniert werden.

00:17:57,310 --> 00:18:03,310
In diesem Fall ergibt das Zippen der Zeichenkette "abc"
und der Zeichenkette "def" also eine Liste von Paaren,

00:18:03,310 --> 00:18:07,820
in der das erste Zeichen aus der ersten
Liste und das erste Zeichen aus der zweiten Liste

00:18:07,820 --> 00:18:08,820
kombiniert werden.

00:18:08,820 --> 00:18:15,480
Also 'a' und 'd', dann das zweite
Element des ersten Arguments und das zweite Element

00:18:15,480 --> 00:18:18,040
des zweiten Arguments, ('b', 'e'), und so weiter.

00:18:18,040 --> 00:18:21,701
Wenn eine der beiden Listen kürzer ist
als die andere, dann wird vorzeitig abgebrochen.

00:18:21,701 --> 00:18:30,040
Es hört an dem Punkt auf, an dem
eine der beiden Listen keine weiteren Elemente mehr hat.

00:18:30,040 --> 00:18:32,270
Und es gibt eine Version von
++, die mit verschachtelten Listen arbeitet.

00:18:32,270 --> 00:18:36,420
Also, diese Verkettung (++) nimmt
zwei Listen und verkettet sie.

00:18:36,420 --> 00:18:41,420
Aber manchmal haben Sie den Fall, dass
Sie mehr als zwei Listen haben und

00:18:41,420 --> 00:18:42,420
alle verketten wollen.

00:18:42,420 --> 00:18:44,630
Dann können Sie
die Funktion "concat" verwenden.

00:18:44,630 --> 00:18:50,940
Sie nimmt eine Liste von Listen (es könnte
auch eine Liste von Strings sein) und verkettet

00:18:50,940 --> 00:18:52,020
alle inneren Listen.

00:18:52,020 --> 00:18:57,010
Sie setzt also gewissermaßen die "++"-Operation
zwischen all diesen Stellen, an denen vorher

00:18:57,010 --> 00:18:58,250
ein Komma stand.

00:18:58,250 --> 00:19:02,130
Sie erhalten also [1, 2] ++ [] ++ [3].

00:19:02,130 --> 00:19:11,030
Und die leere Liste trägt nicht zur
Verkettung bei, also würden Sie in diesem

00:19:11,030 --> 00:19:13,649
Fall die Ausgabeliste [1, 2, 3] erhalten.

00:19:13,649 --> 00:19:18,990
Und mit diesen Funktionen können Sie
schon eine ganze Menge Code schreiben.

00:19:18,990 --> 00:19:24,250
Insbesondere könnten Sie am Anfang den Test
auf Leere ("null"), den Zugriff auf den

00:19:24,250 --> 00:19:31,810
Kopf ("head") und den Rest einer Liste oder eines
Strings ("tail") verwenden, um Code zu schreiben, der eine

00:19:31,810 --> 00:19:32,810
Liste rekursiv zerlegt.

00:19:32,810 --> 00:19:35,460
Ich weiß, dass einige von Ihnen bereits
über Pattern-Matching Bescheid wissen, da wir dies in

00:19:35,460 --> 00:19:37,070
den Übungsaufgaben gesehen haben.

00:19:37,070 --> 00:19:43,280
Aber eigentlich können Sie bis zu dem Punkt,
an dem wir Pattern-Matching in der Vorlesung vorstellen,

00:19:43,280 --> 00:19:47,740
davon ausgehen, dass alle Übungsaufgaben, die
Sie schreiben, eine Lösung ohne Pattern-Matching haben.

00:19:47,740 --> 00:19:52,860
Wenn Sie also Pattern-Matching verwenden, ist das nicht
verboten, es sei denn, es wird durch Autotool

00:19:52,860 --> 00:19:53,860
tatsächlich verhindert.

00:19:53,860 --> 00:20:00,020
Aber in jedem Fall können Sie, solange
wir Pattern-Matching in der Vorlesung nicht behandelt haben,

00:20:00,020 --> 00:20:07,530
davon ausgehen, dass die Übungsaufgaben Lösungen
haben, die ohne Pattern-Matching sein sollen.

76 # slide
00:20:07,530 --> 00:20:15,280
Wir haben nun verschiedene Wahlmöglichkeiten,
wenn wir eine Listenfunktion schreiben.

00:20:15,280 --> 00:20:20,620
Wir können zum Beispiel entscheiden, ob wir
mit Fallunterscheidung und Rekursion arbeiten oder ob wir

00:20:20,620 --> 00:20:27,340
einfach einige der Funktionen, die wir gerade
gesehen haben, kombinieren oder eventuell List Comprehensions

00:20:27,340 --> 00:20:28,340
verwenden.

00:20:28,340 --> 00:20:30,850
Lassen Sie mich dies an einem
Beispiel aus einer früheren Übung diskutieren.

00:20:30,850 --> 00:20:36,830
Dort bestand die Aufgabe darin, zu entscheiden,
ob ein bestimmter String ein Palindrom ist.

00:20:36,830 --> 00:20:40,150
Das Prädikat "is-a-palindrome?"


plaintext
00:20:40,150 --> 00:20:48,300
Und eine Möglichkeit, darüber nachzudenken, ist, sich zunächst
zu überlegen, dass ein Palindrom mit Sicherheit vorliegt.

00:20:48,300 --> 00:20:56,150
Wenn Sie eine sehr kurze Zeichenkette haben,
die nur null oder ein Element enthält.

00:20:56,150 --> 00:21:01,620
Man prüft also die Länge dieses Strings
(was möglich ist, weil Strings Listen sind), und prüft,

00:21:01,620 --> 00:21:03,460
ob sie kleiner als 2 ist.

00:21:03,460 --> 00:21:08,840
Und wenn ja, dann wird True zurückgegeben,
denn dann ist der String gesichert ein Palindrom.

00:21:08,840 --> 00:21:12,910
Und wenn sie nicht so kurz ist, dann
entweder durch Pattern-Matching (was ich gerade gesagt habe,

00:21:12,910 --> 00:21:17,770
werde ich noch nicht zeigen) oder durch die Verwendung
der head- und last-Funktionen, also Prüfung, ob das erste

00:21:17,770 --> 00:21:23,780
Element und das letzte Element dieser Zeichenkette das
gleiche Zeichen sind. Und wenn ja, dann auch prüfen,

00:21:23,780 --> 00:21:29,300
ob, wenn Sie dieses erste und letzte Element
entfernen (was Sie mit "init" und "tail" tun könnten),

00:21:29,300 --> 00:21:31,050
dann auch der Rest ein Palindrom ist.

00:21:31,050 --> 00:21:35,740
Dies ist also durchaus eine gültige Definition, um
zu prüfen, ob eine Zeichenkette ein Palindrom ist.

00:21:35,740 --> 00:21:38,430
Sie verwendet keine Indizierung.

00:21:38,430 --> 00:21:47,490
Es ist keine sehr idiomatische Lösung für diese Aufgabe,
aber sie vermeidet zumindest die Verwendung von Listenindizierung (welche

00:21:47,490 --> 00:21:50,730
man bei der Lösung
dieser Aufgabe auch verwenden könnte).

00:21:50,730 --> 00:21:56,081
Aber es lohnt sich, darüber nachzudenken, ob wir
mit einigen der vorhandenen Funktionen dieses Prädikat / diese

00:21:56,081 --> 00:21:57,760
Eigenschaft viel
einfacher ausdrücken können.

00:21:57,760 --> 00:21:59,150
Und tatsächlich, das können wir.

00:21:59,150 --> 00:22:01,790
Wir können einfach
etwas wie folgt schreiben.

00:22:01,790 --> 00:22:07,190
Wir können sagen, was viel deklarativer ist, dass ein
String ein Palindrom ist, wenn es der Fall ist, dass

00:22:07,190 --> 00:22:09,620
die Umkehrung des
Strings ihn nicht verändert.

00:22:09,620 --> 00:22:13,300
Nun, eigentlich "verändert" die Umkehrung einer Zeichenkette
sie nie; sie gibt nur eine andere

00:22:13,300 --> 00:22:15,870
Zeichenkette zurück, die die
Umkehrung der ursprünglichen Zeichenkette ist.

00:22:15,870 --> 00:22:19,850
Aber dann können wir prüfen, ob die
Umkehrung des Strings gleich dem String selbst ist.

00:22:19,850 --> 00:22:22,440
Das ist eine
Definition von "isPalindrome".

00:22:22,440 --> 00:22:27,140
Und sie ist sicherlich besser als die
Definition, die wir hier oben gesehen haben.

00:22:27,140 --> 00:22:30,530
Man könnte meinen, dass die erste Version
effizienter ist, weil man hier zuerst den String

00:22:30,530 --> 00:22:35,940
umdrehen muss, was sicherlich
eine teure Berechnung ist.

00:22:35,940 --> 00:22:37,560
Aber eigentlich wissen Sie das nicht.

00:22:37,560 --> 00:22:43,730
Die meisten von Ihnen haben wahrscheinlich noch
kein sehr klares Bild vom Kostenmodell von Haskell.

00:22:43,730 --> 00:22:45,760
Sie sollten also nicht
mit solchen Vorurteilen arbeiten.

00:22:45,760 --> 00:22:53,040
Versuchen Sie, bei den Übungsaufgaben die elegante
und ausdrucksstarke Version zu wählen und nicht die,

00:22:53,040 --> 00:22:57,980
bei der Sie (mit einer gewissen
imperativen Programmiermentalität) denken, dass dies die effizientere

00:22:57,980 --> 00:22:59,460
Version sein muss.

00:22:59,460 --> 00:23:03,440
Das können Sie im Moment noch
nicht wirklich erkennen, würde ich sagen.

00:23:03,440 --> 00:23:06,930
Versuchen Sie also, im
Sinne dieser Aufgabe zu denken.

00:23:06,930 --> 00:23:19,660
Hier hätte ich diese
Einreichung eindeutig der obigen vorgezogen.

77 # slide
00:23:19,660 --> 00:23:26,380
Eine vielleicht etwas überraschende Beobachtung ist, dass
wir in Haskell sogar mit unendlichen Listen arbeiten

00:23:26,380 --> 00:23:27,380
können.

00:23:27,380 --> 00:23:30,880
So gibt es Ausdrücke und
Werte, die unendliche Listen repräsentieren.

00:23:30,880 --> 00:23:32,930
Etwa das, was Sie hier sehen.

00:23:32,930 --> 00:23:39,860
Wir haben schon einmal etwas Ähnliches gesehen, wo
wir einen Ausdruck wie [1..10] oder [1,3..9] verwendet haben,

00:23:39,860 --> 00:23:46,309
wo wir alle ungeraden Zahlen
von 1 bis 9 erhalten haben.

00:23:46,309 --> 00:23:51,220
Sie können die obere Grenze auch weglassen
und einfach sagen, dass Sie [1,3...] haben wollen.

00:23:51,220 --> 00:23:58,730
Dann erhalten Sie mathematisch (zumindest
konzeptionell) die Liste aller ungeraden Zahlen.

00:23:58,730 --> 00:23:59,730
Eine unendliche Liste!

00:23:59,730 --> 00:24:04,170
Auch wenn Sie sie nicht in einer expliziten
Listenform aufschreiben können, so können Sie sie doch

00:24:04,170 --> 00:24:05,170
als Ausdruck aufschreiben.

00:24:05,170 --> 00:24:11,280
Und das bedeutet semantisch die
unendliche Liste aller ungeraden Zahlen.

00:24:11,280 --> 00:24:13,800
Was können Sie nun
mit einer solchen Liste machen?

00:24:13,800 --> 00:24:15,120
Natürlich können Sie
sie nicht ausgeben.

00:24:15,120 --> 00:24:16,260
Aber Sie können mit ihr arbeiten.

00:24:16,260 --> 00:24:19,690
Zum Beispiel können Sie andere
Listen in Bezug auf sie definieren.

00:24:19,690 --> 00:24:26,950
So könnten Sie zum Beispiel sagen: Ich
möchte die Quadrate von allem aus einer

00:24:26,950 --> 00:24:27,950
solchen Liste haben.

00:24:27,950 --> 00:24:36,450
Sie könnten [1,3...] haben, oder Sie können nur
[1...] haben (was die unendliche Liste aller natürlichen

00:24:36,450 --> 00:24:42,520
Zahlen ist), und diese List Comprehension
als Ganzes ist die unendliche Liste aller

00:24:42,520 --> 00:24:43,520
Quadratzahlen aller natürlichen Zahlen.

00:24:43,520 --> 00:24:45,280
Wir erhalten alle Quadratzahlen.



00:24:45,280 --> 00:24:50,810
Das kann man nicht ausgeben, aber es
ist definiert, und man kann damit arbeiten.

00:24:50,810 --> 00:24:51,810
Wie können Sie damit arbeiten?

00:24:51,810 --> 00:24:54,000
Zumindest kann man
mit Präfixen davon arbeiten.

00:24:54,000 --> 00:24:59,231
Wir können dies also als einen Ausdruck definieren,
der für eine unendliche Liste steht, und dann

00:24:59,231 --> 00:25:03,640
könnten Sie entscheiden, dass Sie nur einen Teil
davon betrachten wollen (nachdem Sie es als ganze unendliche

00:25:03,640 --> 00:25:05,620
Liste definiert haben).

00:25:05,620 --> 00:25:13,150
Zum Beispiel können Sie etwas sagen wie:
Gib mir die ersten drei Elemente der

00:25:13,150 --> 00:25:14,480
Liste aller Quadratzahlen.

00:25:14,480 --> 00:25:20,180
Und das bedeutet, dass Sie diese obere
Schranke nicht irgendwie in diese Liste einbauen müssen.

00:25:20,180 --> 00:25:25,120
Vielleicht wissen Sie bei der Definition der
Quadratzahlen nicht, wie viele von ihnen Sie brauchen

00:25:25,120 --> 00:25:26,120
werden.

00:25:26,120 --> 00:25:27,850
Also definieren Sie sie
als eine unendliche Liste.

00:25:27,850 --> 00:25:32,040
Aber dann, an einem bestimmten Nutzungspunkt,
sagen Sie: Gib mir die ersten drei.

00:25:32,040 --> 00:25:37,640
Und dann bekommen Sie wirklich die ersten
drei, und die anderen werden nicht einmal berechnet.

00:25:37,640 --> 00:25:43,740
Die Funktionalität besteht hier also nicht
darin, dass Haskell versucht, diese unendliche Liste

00:25:43,740 --> 00:25:50,880
aller Quadratzahlen zu berechnen und dann
feststellt, dass es das nicht kann.

00:25:50,880 --> 00:25:51,880
Nein.

00:25:51,880 --> 00:25:56,140
Was stattdessen passiert, ist, dass Haskell
herausfindet, dass es nur die ersten drei

00:25:56,140 --> 00:25:57,620
dieser Elemente benötigt.

00:25:57,620 --> 00:25:59,380
Also wird es
tatsächlich nur [1, 4, 9] berechnen.

00:25:59,380 --> 00:26:01,290
Und das funktioniert im Allgemeinen.

00:26:01,290 --> 00:26:07,260
Es ist nicht auf diese Idee beschränkt, eine
feste Anzahl von Elementen zu nehmen, wo man vielleicht

00:26:07,260 --> 00:26:11,960
sagen könnte, das ist ein Spezialfall, dass diese Zahl
irgendwie benutzt wird, um zu entscheiden, wie weit man gehen

00:26:11,960 --> 00:26:12,960
muss.

00:26:12,960 --> 00:26:15,600
Nein, das funktioniert
für fast alle Listenfunktionen.

00:26:15,600 --> 00:26:18,210
Sie können eine unendliche Liste
nicht umkehren, das ergibt keinen Sinn.

00:26:18,210 --> 00:26:22,960
Sie können auch nicht das
letzte Element einer unendlichen Liste erhalten.

00:26:22,960 --> 00:26:27,370
Und einige Anwendungen der
Rekursion sind auch problematisch.

00:26:27,370 --> 00:26:31,700
Aber viele der Listenfunktionen, die Sie bereits
gesehen haben, und auch weitere, operieren (ohne

00:26:31,700 --> 00:26:35,720
Probleme) auf unendlichen Listen, vorausgesetzt,
die Ausgabe ist etwas, das nur

00:26:35,720 --> 00:26:37,450
endliche Berechnungen erfordert.

00:26:37,450 --> 00:26:42,020
Zum Beispiel könnten Sie etwas sagen wie:
Ich möchte die unendliche Liste aller natürlichen Zahlen

00:26:42,020 --> 00:26:47,260
einschließlich null ([0..]) und
die endliche Zeichenkette "ab" zippen.

00:26:47,260 --> 00:26:48,260
Was würden Sie erhalten?

00:26:48,260 --> 00:26:49,580
Wie ich schon
über die zip-Funktion sagte:

00:26:49,580 --> 00:26:52,830
Sie hört auf, wenn eine der
beiden Listen keine weiteren Elemente hat.

00:26:52,830 --> 00:26:57,080
In diesem Fall ist also diese
endliche Liste diejenige, die zuerst stoppt.

00:26:57,080 --> 00:26:58,760
Sie enthält nur 'a' und 'b'.

00:26:58,760 --> 00:27:05,250
Von dieser unendlichen Liste aller nichtnegativen Zahlen
werden also nur die 0 und die 1

00:27:05,250 --> 00:27:06,620
verbraucht, der Rest wird nie berechnet.

00:27:06,620 --> 00:27:08,760
Und dies ist kein
Sonderfall für das erste Argument.

00:27:08,760 --> 00:27:12,760
Wenn Sie hier die beiden
Argumente vertauschen, wird es auch funktionieren.

00:27:12,760 --> 00:27:15,170
Das liegt an der
Eigenschaft der "Lazy Evaluation".

00:27:15,170 --> 00:27:19,130
Das war etwas, was ich im ersten Video
heute erwähnt habe, wo ich über die Vermeidung

00:27:19,130 --> 00:27:22,940
der Berechnung der Ackermann-Funktion gesprochen habe, wo
ich gesagt habe, dass Haskell nur die Dinge

00:27:22,940 --> 00:27:24,770
berechnen wird, die es unbedingt braucht.

00:27:24,770 --> 00:27:31,030
In diesem Fall wird die Restliste nach der
ersten 0 und 1 nicht benötigt, also wird sie

00:27:31,030 --> 00:27:35,190
nie berechnet.

00:27:35,190 --> 00:27:42,190
Okay.

78 # slide
00:27:42,190 --> 00:27:44,060
Das bedeutet nicht, dass
irgendeine Magie im Spiel ist.

00:27:44,060 --> 00:27:47,980
Haskell löst also
nicht beliebige mathematische Probleme.

00:27:47,980 --> 00:27:54,610
Betrachten wir dieses Beispiel hier, wo
wir die Liste aller Quadratzahlen haben.

00:27:54,610 --> 00:28:01,210
Was eine unendliche Liste ist, denn wir machen das
für alle Zahlen ab 1 und so weiter, ad infinitum.

00:28:01,210 --> 00:28:02,210
Und was wollen wir dann?

00:28:02,210 --> 00:28:06,070
Wir wollen die Ergebnisliste aller m aus
dieser unendlichen Liste so berechnen, dass m kleiner

00:28:06,070 --> 00:28:07,309
als 100 ist.

00:28:07,309 --> 00:28:14,210
Sie könnten erwarten, dass dies genau
die Liste der Quadratzahlen in [1..81] berechnet

00:28:14,210 --> 00:28:15,520
und dann aufhört.

00:28:15,520 --> 00:28:17,960
Das ist aber nicht
das, was passieren wird.

00:28:17,960 --> 00:28:23,520
Was passieren wird, ist, dass diese Auswertung
nach der Erzeugung eines endlichen Präfixes hängen bleibt.

00:28:23,520 --> 00:28:28,380
Sie wird also die Quadratzahlen von 1
bis 81 erzeugen, und dann wird sie ewig

00:28:28,380 --> 00:28:30,400
weiter rechnen.

00:28:30,400 --> 00:28:32,980
Warum ist das so?

00:28:32,980 --> 00:28:41,760
Weil Haskell kein Wissen oder algebraische Beweise
verwendet, um abzuleiten, dass, da diese Liste



00:28:41,760 --> 00:28:47,650
ansteigend ist und wir die Zahlen quadrieren, dies
auch eine ansteigende Liste sein wird, sodass wir.

00:28:47,650 --> 00:28:51,390
sobald wir die 100 gesehen haben,
nie wieder eine *kleinere* Zahl sehen können.

00:28:51,390 --> 00:28:56,500
Das wäre für diesen sehr speziellen Ausdruck
möglich, aber im Allgemeinen könnte man hier

00:28:56,500 --> 00:29:04,010
eine Liste haben, die nach einer Million
Zahlen wieder etwas ergibt, das kleiner als 100

00:29:04,010 --> 00:29:05,010
ist.

00:29:05,010 --> 00:29:06,910
Und das sollte dann
in die Ausgabeliste gehen.

00:29:06,910 --> 00:29:12,420
Es ist also sehr spezifisch,
dass die Quadratzahlen immer größer werden.

00:29:12,420 --> 00:29:18,130
Aber Haskell sollte dieses Wissen nicht nutzen,
weil das im Grunde der "referenziellen Transparenz" widerspricht.

00:29:18,130 --> 00:29:19,130
Was war das nochmal?

00:29:19,130 --> 00:29:25,140
Die Idee war, dass, wenn man einen
Ausdruck hat, dieser mit jedem anderen Ausdruck austauschbar

00:29:25,140 --> 00:29:29,320
sein sollte, der die gleichen Werte berechnet
(den gleichen Wert - oder die gleichen Werte,

00:29:29,320 --> 00:29:31,800
im Fall einer Liste).

00:29:31,800 --> 00:29:38,470
Während wir also anhand dieses speziellen Ausdrucks sehen
könnten, dass wir, wenn wir einmal "100" gesehen haben,

00:29:38,470 --> 00:29:42,950
nie wieder eine kleinere Zahl sehen werden, nehmen
wir an, dass es sich um einen anderen Ausdruck

00:29:42,950 --> 00:29:48,080
handelt, der ebenfalls die Quadratzahlen
berechnet, aber auf eine andere Weise.

00:29:48,080 --> 00:29:50,620
Auf irgendeine, vielleicht
weniger offensichtliche Weise.

00:29:50,620 --> 00:29:55,670
So dass Haskell, oder irgendein anderes Computerprogramm, im
Allgemeinen nicht beweisen kann, dass das, was hier

00:29:55,670 --> 00:29:57,390
berechnet wird, die Quadratzahlen sind.

00:29:57,390 --> 00:30:00,050
Es sollte also
keine Annahmen darüber machen.

00:30:00,050 --> 00:30:03,500
Andersherum formuliert:

00:30:03,500 --> 00:30:07,700
Dieser Ausdruck und jeder andere Ausdruck,
der ebenfalls die Quadratzahlen berechnet, sollten hier

00:30:07,700 --> 00:30:09,290
austauschbar sein.

00:30:09,290 --> 00:30:13,670
Und nur die Tatsache, dass wir aus diesem
speziellen Ausdruck erkennen können, dass es sich um

00:30:13,670 --> 00:30:18,450
die Quadratzahlen handelt, bedeutet nicht, dass dies
auch für jeden anderen Ausdruck möglich ist, der

00:30:18,450 --> 00:30:20,660
uns zufällig die gleiche Liste liefert.

00:30:20,660 --> 00:30:23,130
Aber die beiden Programme
sollten sich nicht unterschiedlich verhalten.

00:30:23,130 --> 00:30:28,630
Die einzige Möglichkeit, das sicherzustellen, ist also,
dass Haskell auch in diesem Fall tatsächlich

00:30:28,630 --> 00:30:32,610
alle Zahlen ausprobiert, die
aus dieser Liste kommen.

00:30:32,610 --> 00:30:38,860
Und da es sie nicht alle in einer
endlichen Zeit ausprobieren kann, wird es hier keine endliche

00:30:38,860 --> 00:30:39,860
Liste erzeugen.

00:30:39,860 --> 00:30:43,730
Das ist also etwas ganz anderes als
der Fall, in dem wir "take 3" hatten.

00:30:43,730 --> 00:30:50,390
Denn dort lässt die 3 Haskell,
das Laufzeitsystem, die Auswertung des Programms

00:30:50,390 --> 00:30:53,120
wirklich wissen, wann es fertig ist.

00:30:53,120 --> 00:30:56,960
Es hängt nicht von den
Elementen in der Liste ab.

00:30:56,960 --> 00:31:04,110
Dies ist also ein warnendes Beispiel,
dass man keine mathematische Magie erwarten sollte.

00:31:04,110 --> 00:31:05,980
Alles wird durch
Lazy Evaluation gesteuert.

00:31:05,980 --> 00:31:12,710
Nach diesem Prinzip (lazy evaluation) verwendet Haskell die
Fallunterscheidung, um zu wissen, was zu tun ist,

00:31:12,710 --> 00:31:17,170
und wertet nur die Argumente aus, die
benötigt werden, um diese Fallunterscheidungen zu treffen.

00:31:17,170 --> 00:31:25,370
Und das erlaubt uns oft endliche Berechnungen
mit unendlichen Daten, aber es ist kein mathematischer

00:31:25,370 --> 00:31:36,290
magischer Rätsellöser.

79 # slide
00:31:36,290 --> 00:31:40,600
Zum Abschluss für heute möchte
ich noch dieses Beispiel besprechen.

00:31:40,600 --> 00:31:44,880
Dies ist, wie der
Name schon sagt, eine Sortierfunktion.

00:31:44,880 --> 00:31:48,990
Und tatsächlich implementiert sie im
Wesentlichen die Idee von Quicksort.

00:31:48,990 --> 00:31:54,150
Sie sehen also einige der Funktionen
in Aktion, die wir bisher eingeführt haben.

00:31:54,150 --> 00:32:03,790
Wir haben eine Fallunterscheidung: Wir sagen also, dass
die leere Liste nach der leeren Liste sortiert wird.

00:32:03,790 --> 00:32:08,980
Und ansonsten führen wir
einige lokale Berechnungen durch.

00:32:08,980 --> 00:32:16,179
Wir wählen also ein Pivot-Element und verwenden
List Comprehensions, um im Grunde unsere Eingabeliste

00:32:16,179 --> 00:32:18,270
in kleinere und
größere Werte aufzuteilen.

00:32:18,270 --> 00:32:22,650
Und dann haben wir rekursive Aufrufe
auf diesen "kleineren" und "größeren" Elementen.

00:32:22,650 --> 00:32:28,190
Und dann kombinieren wir die Ergebnisse
mit dieser Verkettungsfunktion, die Sie auch schon

00:32:28,190 --> 00:32:29,559
gesehen haben.

00:32:29,559 --> 00:32:34,020
Und am Ende erhalten
wir hoffentlich eine sortierte Liste.

00:32:34,020 --> 00:32:39,210
Ich möchte das diskutieren, aber eigentlich möchte ich
einige Aspekte sehen, die besser in einem Editor

00:32:39,210 --> 00:32:41,890
erklärt werden, wo wir
auch das Programm laufen sehen.

00:32:41,890 --> 00:32:46,909
Tatsächlich werde ich also ein
separates Video für diesen Teil machen.

