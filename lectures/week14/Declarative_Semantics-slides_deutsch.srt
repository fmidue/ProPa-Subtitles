39 # slide
00:00:02,080 --> 00:00:08,720
Im letzten Video dieser Woche werden wir über
die deklarative Semantik von Prolog reden.

00:00:08,720 --> 00:00:10,560
Also, Semantik, was bedeutet das Programm?

00:00:11,520 --> 00:00:17,440
Und eigentlich werden wir insgesamt zwei verschiedene
Semantiken betrachten (dieses Jahr optional).

00:00:17,440 --> 00:00:21,200
Nämlich diese deklarative Semantik
und dann die operationelle Semantik.

00:00:21,200 --> 00:00:25,440
Bei der deklarativen Semantik geht es also
wirklich mehr um die Bedeutung eines Programms.

00:00:25,440 --> 00:00:29,040
Man könnte sie auch als die logische Semantik
oder die mathematische Semantik bezeichnen.

00:00:29,680 --> 00:00:34,160
Und bei der operationellen Semantik geht es
mehr darum, wie die Ausführung funktioniert.

00:00:34,160 --> 00:00:37,440
Dazu habe ich bereits eine
gewisse Intuition gegeben.

00:00:37,440 --> 00:00:42,640
Aber wenn wir über operationelle Semantik
sprechen, wird dies präziser und konkreter gemacht.

00:00:42,640 --> 00:00:48,240
Und konkreter, wie ein Prolog-System eine Lösung für
eine Anfrage zu einem bestimmten Programm finden kann.

00:00:49,680 --> 00:00:52,560
Okay, und das ist eine typische
Unterscheidung, verschiedene

00:00:52,560 --> 00:00:56,160
Arten von Semantik zu haben, mehr
mathematisch und mehr ausführungsorientiert.

00:00:56,160 --> 00:00:58,800
Und natürlich ist die ausführungsorientierte
Semantik das, was verwendet wird.

00:01:00,160 --> 00:01:02,320
Für die Implementierung einer Programmiersprache.

00:01:02,320 --> 00:01:04,800
Und so etwas wie deklarative
Semantik wird verwendet für

00:01:05,440 --> 00:01:08,560
Argumentation über Programme, zum
Beispiel, wenn man etwas beweisen will.

00:01:09,360 --> 00:01:16,320
Also, für den Haskell-Teil früher im Kurs, haben wir
etwas über operationelles Verhalten gesprochen, richtig?

00:01:16,320 --> 00:01:19,280
Als wir also über das Pattern-Matching gesprochen
haben, und wie es die Auswertung steuert.

00:01:19,280 --> 00:01:21,760
Die Lazy-Auswertung, die vorher
nur als Idee auftauchte,

00:01:21,760 --> 00:01:26,080
nur als eine Idee, und wurde dann für
konkrete Programme in Betracht gezogen.

00:01:28,000 --> 00:01:30,800
Also, das ist so etwas wie
operationelle Semantik für Haskell.

00:01:31,440 --> 00:01:35,040
Wir haben uns nicht einmal die Mühe gemacht,
eine deklarative Semantik für Haskell zu geben.

00:01:35,040 --> 00:01:38,160
Das würde man als eine
denotationelle Semantik bezeichnen.

00:01:38,160 --> 00:01:40,000
Und warum haben wir das nicht getan?

00:01:40,000 --> 00:01:46,000
Weil es für Haskell eine so große Nähe eine so enge Verbindung
zur Mathematik und Algebra gibt, dass das Aufschreiben

00:01:46,000 --> 00:01:50,480
einer solchen Semantik einfach bedeutet hätte, zu sagen,
dass Funktionen bedeuten, was Funktionen bedeuten.

00:01:51,040 --> 00:01:57,840
Also verwenden wir die Haskell-Funktionen im
gleichen Sinne wie die Funktionen der Mengenlehre.

00:01:57,840 --> 00:01:59,440
Wenn wir also Definitionen
niederschreiben, und dann

00:02:00,000 --> 00:02:04,000
haben wir eine Abbildung aufgeschrieben,
und das ist die Semantik dieser Funktion.

00:02:04,560 --> 00:02:07,760
Es gibt eine Möglichkeit, dies zu präzisieren.

00:02:07,760 --> 00:02:12,000
Aber für die Zwecke dieses Kurses haben wir
einfach die semantische Lücke verwischt, den

00:02:12,000 --> 00:02:14,480
Unterschied zwischen Syntax und
Semantik im Fall von Haskell.

00:02:14,480 --> 00:02:17,760
Wenn wir also die Funktion aufschreiben,
Definition, sie bedeutet genau

00:02:17,760 --> 00:02:20,240
was diese Funktionsdefinition
mathematisch bedeuten würde.

00:02:21,280 --> 00:02:27,600
Okay, also die Auswertung von Werten durch
Anwendung einer niedergeschriebenen Definition.

00:02:27,600 --> 00:02:30,640
Das ist der Grund, warum wir bei Haskell
diese Unterscheidung nicht gemacht haben.

00:02:30,640 --> 00:02:38,800
Aber für Prolog hier werden wir eine Erklärung
geben, was die logische Bedeutung ist.

00:02:40,320 --> 00:02:45,760
Okay, also wird diese Semantik hier benutzt
werden, um Fragen über Grundterme zu beantworten.

00:02:45,760 --> 00:02:47,040
Für Terme ohne Variablen.

00:02:47,040 --> 00:02:51,600
Wir werden Regeln mit Variablen haben, wie
wir sie bisher in Programmen gesehen haben.

00:02:51,600 --> 00:02:56,160
Aber die deklarative Semantik beantwortet
Fragen darüber, ob ein Prädikat

00:02:56,160 --> 00:02:59,840
wahr für gewisse Terme ist, die
selbst keine Variablen enthalten.

00:02:59,840 --> 00:03:04,400
Das unterscheidet sich auch von der operationellen Semantik,
wo wir uns auch mit Abfragen beschäftigen werden, die

00:03:04,400 --> 00:03:05,760
Variablen in diesem Sinne enthalten.

00:03:05,760 --> 00:03:10,080
Außerdem ist die deklarative Semantik etwas
einfacher als die operationelle Semantik.

00:03:10,080 --> 00:03:17,840
Denn sie muss sich nicht mit Variablen
in den Abfragen auseinandersetzen.

40 # slide
00:03:18,480 --> 00:03:24,000
Okay, was ist also die mathematische, logische
Bedeutung oder Semantik eines Prolog-Programms?

00:03:24,000 --> 00:03:31,840
Schauen wir auf ein einfaches Beispiel eines
Prolog-Programms, das wir bereits betrachtet haben.

00:03:31,840 --> 00:03:36,400
Nun, der erste und etwas offensichtliche
Schritt wäre es, wirklich

00:03:36,960 --> 00:03:42,160
die Prologsyntax durch die normale
Syntax der Prädikatenlogik zu ersetzen.

00:03:42,160 --> 00:03:46,000
Und tatsächlich, schreiben Sie auf, was die
Regeln oder das Faktum und die Regel, die

00:03:46,000 --> 00:03:50,560
wir hier sehen, bedeuten würden oder wie sie
wie in der Prädikatenlogik geschrieben werden.

00:03:50,560 --> 00:03:54,960
Und das ist eigentlich etwas, das ich schon
gezeigt habe, als wir über die Regeln von

00:03:54,960 --> 00:04:03,040
Variablen und über freie Variablen gesprochen haben. Dann habe
ich diese Transkription in die normale logische Syntax verwendet.

00:04:03,040 --> 00:04:09,440
Oder insbesondere diese
explizite Regel der Quantoren.

00:04:09,440 --> 00:04:18,080
Und dann war die Idee, na ja, im Grunde genommen wird
diese Tatsache in eine Aussage über alle x umgewandelt.

00:04:19,120 --> 00:04:23,280
Wobei x jetzt als Variable verwendet wird, und
es ist alles quantifiziert, weil dies für alle

00:04:23,280 --> 00:04:28,400
Wahlmöglichkeiten für x und, na ja,
Regel wie diese alternative Implikation.

00:04:28,400 --> 00:04:29,840
Also, die rechte Seite

00:04:30,560 --> 00:04:35,040
impliziert die linke Seite und dann natürlich
kann man es auch in dieser Reihenfolge schreiben.

00:04:35,600 --> 00:04:38,880
Und noch einmal, alle Variablen, die
hier erscheinen, sind alle quantifiziert.

00:04:38,880 --> 00:04:44,080
Und dann natürlich, da Sie mehrere Aussagen
eine Regel haben, werden sie geleitet.

00:04:44,080 --> 00:04:48,800
Also, sie werden mit einem und,
mit logisch und das ist dann

00:04:48,800 --> 00:04:51,920
was die logische Formel sein würde,
die diesem Prolog-Programm entspricht.

00:04:52,880 --> 00:04:56,000
Okay, natürlich ist das nur eine
Änderung der Syntax, das tut es nicht

00:04:56,000 --> 00:04:58,800
selbst, was die Bedeutung
des Programms ist.

00:04:59,440 --> 00:05:04,720
Okay, aber jetzt, wo wir in der Welt der formalen
Logik sind, können wir, und das ist etwas

00:05:04,720 --> 00:05:12,320
das habe ich bereits angedeutet, und wir können die
Methoden und Techniken aus der Theorie der Logik verwenden.

00:05:12,320 --> 00:05:19,920
Und ich habe bereits erklärt, dass ich
auf Hintergrundmaterial stützen werde, das

00:05:19,920 --> 00:05:24,720
in der vorherigen Vorlesung von Professor König zur Verfügung
gestellt wurde, und ich habe Sie auf Folien hingewiesen

00:05:24,720 --> 00:05:28,080
die diese Konzepte erklären
oder diese Konzepte wiederholen.

00:05:30,080 --> 00:05:35,680
Jetzt können Sie Ihr Verständnis
überprüfen oder auffrischen.

00:05:36,480 --> 00:05:37,040
Nun gut.

00:05:37,040 --> 00:05:44,560
Und dann, wie wird den logischen Formeln eine Bedeutung
gegeben oder auch solchen Kombinationen von Formeln?

00:05:44,560 --> 00:05:47,840
Nun, damit beginnt die Logik
das in Form von Modellen.

00:05:48,800 --> 00:05:53,760
Und wenn Sie die ersten paar Folien durchgehen, aus dem
Auszug, den ich vor einer Weile auf Moodle hochgeladen

00:05:53,760 --> 00:06:00,320
habe, aus der Vorlesung von Professor König,
gibt es diesen Begriff der "Struktur".

00:06:02,000 --> 00:06:10,640
Das ist also unsere Definition von gegebener Signatur,
gegebenen Konstanten- und Prädikatnamen, usw.

00:06:10,640 --> 00:06:15,440
Was diese Struktur ist, und das ist im Grunde
der Aufbau zur Beschreibung des Modells.

00:06:15,440 --> 00:06:17,840
Also, was ist darin enthalten?

00:06:17,840 --> 00:06:20,960
Nun, es muss eine Menge von
mathematischen Objekten geben.

00:06:20,960 --> 00:06:25,760
Das sind die Dinge, auf denen die Variablen dann
später als quantifiziert angenommen werden, richtig?

00:06:25,760 --> 00:06:30,160
Wenn Sie sagen "für alle x", dann müssen Sie wissen,
nun, was sind die Möglichkeiten, die wir für x haben.

00:06:31,120 --> 00:06:34,960
Und in einer sehr allgemeinen
Struktur in dieser Logiktheorie

00:06:34,960 --> 00:06:39,760
von Modellen, und das könnte eine beliebige Menge
von mathematischen Objekten sein, die später

00:06:39,760 --> 00:06:46,800
Zwang in Herbrand-Strukturen und Modellen,
was auch in der Folie von Struktur vorkommt.

00:06:46,800 --> 00:06:50,640
Aber von außen betrachtet wäre es einfach
eine Menge mathematischer Objekte.

00:06:50,640 --> 00:06:51,120
Aha.

00:06:51,120 --> 00:06:52,720
Und dann wird alles darauf aufgebaut.

00:06:53,760 --> 00:06:57,680
Also, insbesondere die Konstanten wie in diesem Fall
die Null, und es könnten natürlich weitere Konstanten

00:06:57,680 --> 00:07:02,000
im Programm vorkommen, müssen sie als Elemente
dieser Menge interpretiert werden, richtig?

00:07:02,000 --> 00:07:03,680
Das ist also nur eine beliebige Menge.

00:07:04,240 --> 00:07:07,600
Und dann, zum Beispiel, muss
die Null in dieser Menge sein.

00:07:07,600 --> 00:07:09,520
Sie muss in dieser Menge interpretiert werden.

00:07:10,960 --> 00:07:20,480
Okay, und ebenso, Funktoren oder Datenkonstruktoren,
und wie dieses s in diesem Fall hier im Programm

00:07:20,480 --> 00:07:25,440
vorkommt, muss als Funktion eine Funktion auf
diese mathematischen Objekte interpretiert werden.

00:07:25,440 --> 00:07:26,880
Also, da dies ein Argument benötigt,

00:07:27,520 --> 00:07:32,080
kann man das schon an der Domäne sehen erkennen,
über die die Variablen quantifizieren können.

00:07:32,080 --> 00:07:36,400
Dies sollte dann also interpretiert
werden als eine Funktion aus

00:07:36,400 --> 00:07:39,200
dieser Menge von mathematischen
Objekten in diese Menge zurück.

00:07:39,200 --> 00:07:44,240
Dann wäre es also ein binäres Prädikat, ein
binäres Symbol, dann wäre es eine Funktion aus dem

00:07:44,240 --> 00:07:49,120
kartesischen Produkt dieser Menge von mathematischen
Objekten von sich selbst zu dieser Menge zurück.

00:07:49,760 --> 00:07:53,440
Okay, so wird also der
Datenpfad interpretiert.

00:07:53,440 --> 00:07:56,240
Die Konstanten als Elemente
der Menge und des Funktors.

00:07:56,240 --> 00:08:00,400
Also, Datenkonstruktoren als Funktionen mit
angemessener Arithmetik über der Menge.

00:08:02,320 --> 00:08:04,640
Okay, und dann muss man auch
mit den Prädikaten umgehen.

00:08:04,640 --> 00:08:08,880
Also, die Dinge, über die die Fakten
und Regeln logische Aussagen machen,

00:08:10,080 --> 00:08:12,880
und letztendlich Beziehungen, richtig?

00:08:12,880 --> 00:08:15,600
So ist etwa die Addition
ein dreistelliges Prädikat,

00:08:16,240 --> 00:08:19,840
die Dinge, die in den Argumenten vorkommen,
Positionen interpretiert werden können.

00:08:19,840 --> 00:08:26,240
Dank der ersten beiden Punkte als Elemente dieser
Auswahlmenge, aus der die Struktur aufgebaut ist.

00:08:26,800 --> 00:08:33,120
Und dann kann für jedes Tripel von Elementen aus
dieser Menge dieses Prädikat wahr oder falsch sein.

00:08:33,120 --> 00:08:36,480
Und das ist genau das, wofür eine
Relation in der Mathematik verwendet wird.

00:08:37,200 --> 00:08:41,440
Sie muss Elemente von Mengen in Beziehung setzen
und, nun, in diesem Fall immer dieselbe Menge.

00:08:43,040 --> 00:08:46,640
Okay, dann können wir interpretieren
sowohl die Argumentpositionen hier

00:08:46,640 --> 00:08:49,840
als auch eine Aussage wie diese Literale.

00:08:50,720 --> 00:08:59,520
Je nachdem, welche Beziehung wir für eine
bestimmte Wahl von Prädikaten und Argumenten,

00:09:00,160 --> 00:09:05,440
können wir sagen, dass dies so interpretiert wird, dass es als
wahr oder falsch interpretiert wird, je nachdem, welche Relation

00:09:05,440 --> 00:09:08,560
wir für dieses bestimmte Prädikat gewählt haben.

00:09:09,120 --> 00:09:09,440
Okay.

00:09:09,440 --> 00:09:15,760
Das würde uns also wahre Werte für die Literale,
für die Dinge, die hier vorkommen, geben.

00:09:15,760 --> 00:09:18,080
Implikationen von Prädikaten auf Argumente.

00:09:19,360 --> 00:09:22,160
Dann gibt es natürlich noch all
diese logischen Konnektoren.

00:09:22,880 --> 00:09:27,680
Und dann werden bestimmte Regeln verwendet.

00:09:27,680 --> 00:09:33,200
Also, die Regeln der Prädikatenlogik, um
den Formeln wahre Werte zuzuweisen, richtig?

00:09:33,200 --> 00:09:39,280
Also, wenn wir zwei Literale haben,
dann wird die Konjunktion von ihnen als

00:09:39,280 --> 00:09:44,560
die logische Konjunktion interpretiert,
ob beide nicht beide einzeln wahr sind.

00:09:44,560 --> 00:09:44,880
Okay.

00:09:44,880 --> 00:09:47,040
Und die Implikation wird auf
die übliche Weise interpretiert.

00:09:47,600 --> 00:09:51,200
Die Quantoren werden auf die übliche Weise
interpretiert, z.B. wenn es heißt "für alle x",

00:09:52,000 --> 00:09:58,400
dann bedeutet diese Aussage eigentlich, wie in
der Logik für jedes Element der Menge, die Sie

00:09:58,400 --> 00:10:02,800
als Basisstruktur gewählt haben, auf
der wir unsere Struktur aufgebaut haben,

00:10:02,800 --> 00:10:07,200
der Fall sein, dass diese Beziehung für
Null und das Doppelte dieses Elements gilt.

00:10:08,240 --> 00:10:10,640
Okay, so können wir also

00:10:11,680 --> 00:10:16,960
nicht nur für zwei einzelne Literale wahre Werte
zuweisen, sondern auch für eine ganze Formel, die auch,

00:10:16,960 --> 00:10:22,800
natürlich die zusammengesetzte Formel, die man
durch die Übersetzung aller Fakten und Regeln

00:10:22,800 --> 00:10:27,600
aus dem Programm in diese
logischen Einstellungen erhält.

00:10:29,200 --> 00:10:31,680
Okay, und jetzt haben wir diese
möglichen Interpretationen.

00:10:31,680 --> 00:10:32,720
Ja, wir haben viele Wahlmöglichkeiten.

00:10:32,720 --> 00:10:34,720
Wir können verschiedene Mengen von
mathematischen Objekten wählen.

00:10:34,720 --> 00:10:37,120
Wir können verschiedene Interpretationen
dieser Konstanten wählen.

00:10:37,760 --> 00:10:39,360
Wir haben also eine Wahl.

00:10:39,360 --> 00:10:44,640
Wie wir dieses Symbol Null in unserer Gesamtmenge interpretieren,
Menge, die sogar unendlich viele Möglichkeiten umfassen könnte.

00:10:44,640 --> 00:10:46,720
Dasselbe gilt für die Funktionen,
die wir zu wählen haben.

00:10:47,680 --> 00:10:48,640
All das ist eine Wahl.

00:10:48,640 --> 00:10:52,320
Und jede Kombination von Wahlmöglichkeiten
ergibt hier eine Interpretation.

00:10:52,320 --> 00:10:56,080
Dann können wir prüfen, ob diese
Interpretation angesichts dieser

00:10:56,080 --> 00:11:02,000
Zuweisungsregeln, welche wahren Werte wir erhalten,
für die Formel, die dem Programm entspricht.

00:11:02,000 --> 00:11:05,920
Und wir betrachten nur die Interpretationen,
die alle gegebenen Formeln wahr machen.

00:11:05,920 --> 00:11:11,440
Nun, gegebene Formeln bedeuten Übersetzungen dieser
Fakten und Regeln, oder wenn man sie tatsächlich zu

00:11:11,440 --> 00:11:17,600
einer großen Konjunktion zusammenfasst, dann gibt
es nur eine Gesamtformel, die wahr sein muss.

00:11:17,600 --> 00:11:23,200
Okay, all die Interpretationen, all diese Entscheidungen,
die wir hier treffen können, oder jede Wahl

00:11:23,200 --> 00:11:28,000
die wir hier getroffen haben, für die tatsächlich
die Formel, die dem Programm entspricht, wahr ist.

00:11:28,000 --> 00:11:29,200
Sie sind immer noch wahre Werte oder wahr.

00:11:29,920 --> 00:11:31,360
Eine solche Interpretation nennt man ein Modell.

00:11:32,160 --> 00:11:35,680
Dann haben wir ein Modell
für diese logische Formel.

00:11:36,640 --> 00:11:38,880
Und die Semantik eines Programms ist

00:11:41,040 --> 00:11:47,600
all jene Beziehungen zwischen den Aussagen,
die in allen Modellen des Programms wahr sind.

00:11:47,600 --> 00:11:51,120
Wir haben ein Programm, das einer
logischen Formel entspricht,

00:11:51,680 --> 00:11:58,800
könnten wir im Prinzip sehr viele verschiedene Auswahlmöglichkeiten
für die Interpretation der syntaktischen Bestandteile

00:11:58,800 --> 00:12:04,880
des Programms treffen; wir betrachten nur diejenigen,
für die das Programm als Formel wahr ist.

00:12:05,840 --> 00:12:07,520
Dann wissen wir, was die Modelle sind.

00:12:07,520 --> 00:12:11,840
Die Strukturen, die dafür sorgen, dass
unser Prädikat unser Programm erfüllt.

00:12:11,840 --> 00:12:16,800
Und dann könnte es sein, dass in diesen
bestimmten Modellen weitere Dinge wahr sind.

00:12:17,440 --> 00:12:20,640
Denn wir können etwas ableiten
aus dem gegebenen Material.

00:12:20,640 --> 00:12:26,320
Und dann sind genau diese Aussagen, diese
Beziehungen, die in allen Modellen wahr sind,

00:12:26,320 --> 00:12:30,400
d.h. in allen Interpretationen, die
das Programm selbst wahr machen.

00:12:30,400 --> 00:12:34,480
Das sind die Dinge, die die
Semantik des Programms ausmachen.

00:12:34,480 --> 00:12:38,400
Und das bedeutet dann natürlich zum
Beispiel, dass, wenn man logisch

00:12:38,400 --> 00:12:42,800
etwas aus der Formel ableiten kann, dann
wird das auch in allen Modellen wahr sein.

00:12:43,600 --> 00:12:46,560
Genau diese Dinge werden wahr sein
in allen Modellen, die auch logische

00:12:47,280 --> 00:12:52,240
Konsequenzen aus dem gegebenen
materiellen Hintergrundwissen sind.

00:12:52,240 --> 00:12:52,720
Okay?

00:12:52,720 --> 00:12:58,560
Und genau das war das Thema eines Kapitels in
der Vorlesung von Professor König, richtig?

00:12:58,560 --> 00:13:05,840
Also, wie es ist und Sinn macht,
diese Art von Modelltheorie.

41 # slide
00:13:09,920 --> 00:13:13,280
Also, diese Freiheit, die man auf der
vorigen Folie bei der Wahl dieser.

00:13:14,000 --> 00:13:17,200
zugrundeliegenden Menge von mathematischen
Objekten, oft Universum genannt,

00:13:17,200 --> 00:13:23,600
ist ein Problem, wenn man systematisch Konsequenzen
einer logischen Formel untersuchen will.

00:13:23,600 --> 00:13:27,360
Ja, denn es gibt zu viele Modelle in
dem Sinne, dass man sie betrachten

00:13:27,360 --> 00:13:34,320
müsste, wenn man wirklich die Gültigkeit von Konsequenzen
feststellen will, indem man sie für alle Modelle überprüft.

00:13:34,320 --> 00:13:35,040
Okay?

00:13:35,040 --> 00:13:38,000
Zum Glück gibt es immer das
eine universelles Modell.

00:13:38,720 --> 00:13:42,960
Also, ein Modell, das manchmal
genügt, um es zu berücksichtigen.

00:13:42,960 --> 00:13:49,760
Wir müssen nicht alle möglichen Auswahl der
Grundmenge mathematischer Objekte berücksichtigen.

00:13:49,760 --> 00:13:50,720
Okay, und was ist die Idee dahinter?

00:13:50,720 --> 00:13:52,240
Nun, die Idee dazu ist sehr einfach.

00:13:53,440 --> 00:13:58,960
In gewissem Sinne interpretieren wir nämlich dieses
einfache als möglich, nämlich rein syntaktisch.

00:13:58,960 --> 00:14:03,600
Wir betrachten also nicht wirklich eine beliebige Menge
von mathematischen Objekten, wir betrachten einfach Terme.

00:14:04,400 --> 00:14:05,840
Weder die Funktionen noch die
Prädikate tun also wirklich

00:14:05,840 --> 00:14:09,120
etwas in dem Sinne, dass sie zu
irgendeiner tatsächlichen Berechnung.

00:14:09,120 --> 00:14:13,200
Sie werden einfach als das aufgefasst, was sie sind, wie
sie geschrieben sind, nämlich als syntaktische Objekte.

00:14:13,840 --> 00:14:17,120
Okay, was hat das nun für Konsequenzen?

00:14:17,120 --> 00:14:19,760
Nun, die Menge der Objekte wird
einfach die Menge der Grundterme sein.

00:14:20,720 --> 00:14:26,560
Ja, wir haben eine implizit gegebene
Signatur, wie Null und ein Nachfolgesymbol und

00:14:28,480 --> 00:14:32,000
auch Prädikate, die einfach
auf die Konstanten und die

00:14:32,560 --> 00:14:37,040
Datenkonstruktoren betrachten, hätten
wir Null und s im vorherigen Beispiel.

00:14:37,040 --> 00:14:40,560
Und wir betrachten alle Terme, die man
gebildet werden können, aber nur Grundterme.

00:14:40,560 --> 00:14:45,120
Erinnern wir uns also daran, dass wir das in
einer früheren Vorlesung, in einer früheren Woche.

00:14:45,120 --> 00:14:49,200
Wahrscheinlich letzte Woche, dass wir Grundterme
konstruieren Terme konstruieren, d.h. Terme ohne Variablen.

00:14:49,200 --> 00:14:53,360
Okay, wir betrachten also alle diese
Grundterme über impliziter Signatur.

00:14:53,360 --> 00:14:57,840
In diesem Fall wären es Null, s von Null, s von
Null, s von s, s von, s von Null, und so weiter.

00:14:57,840 --> 00:15:00,720
Dies wären die Objekte, die wir
betrachten, syntaktische Anwendung.

00:15:01,680 --> 00:15:03,360
Okay, und was ist dann der Funktor?

00:15:03,360 --> 00:15:04,080
Der Datenkonstruktor?

00:15:04,080 --> 00:15:05,200
Nun, er macht genau das.

00:15:05,200 --> 00:15:07,600
Er wendet einfach die Syntax an.

00:15:08,160 --> 00:15:08,560
Ja.

00:15:08,560 --> 00:15:16,320
Wendet man also den Konstruktor s auf den Term s von Null
an, dann erhalten wir einen neuen Term s von s von Null.

00:15:16,320 --> 00:15:21,440
Betrachten Sie also die Interpretation einfach als das, was
wir aufschreiben würden, wenn man es als Terme aufschreibt.

00:15:21,440 --> 00:15:25,840
Okay, also keine weitere Interpretation
in einem mathematischen Sinn.

00:15:26,960 --> 00:15:31,920
Okay, und das Prädikat, nun,
da es Beziehungen über diese

00:15:31,920 --> 00:15:38,720
Basismenge geben sollte, können wir das jetzt so
interpretieren, einfach diese Implikationen aufschreiben

00:15:38,720 --> 00:15:42,080
von Prädikatssymbolen auf Grundterme,
die als wahr angesehen werden sollten.

00:15:42,080 --> 00:15:45,360
Ja, das ist eine Möglichkeit der
Interpretation oder der Darstellung einer.

00:15:46,960 --> 00:15:52,880
Relation auf einer solchen syntaktischen Menge, indem man
einfach sagt: Nun, wir machen eine andere Menge, in der wir

00:15:52,880 --> 00:15:58,000
alle Anwendungen unserer Prädikatssymbole sammeln,
zum Beispiel das Additionssymbol auf drei Grundterme.

00:15:58,560 --> 00:16:04,000
Aber natürlich nicht alle diese Kombinationen,
sondern nur diejenigen, die in unserer

00:16:04,000 --> 00:16:08,240
Interpretation, in unserem Verständnis des
Prädikatssymbols oder der Beziehung wahr sein sollten.

00:16:09,920 --> 00:16:13,920
Okay, und dieses erste Ding hier
wird das Herbrand-Universum genannt.

00:16:13,920 --> 00:16:18,720
Und das ist wiederum ein Begriff, der
auch in Professor Königs Kurs vorkommt.

00:16:18,720 --> 00:16:24,640
Also, Herbrand war der Magier, der diese
spezifischen Strukturen, diese spezifischen Modelle.

00:16:24,640 --> 00:16:35,200
Dann auch, um die Modelltheorie für die Art der
Logik, die hier verwendet wird, besser zu verstehen.

00:16:35,200 --> 00:16:42,560
Okay, also das Herbrand-Universum wäre jetzt
dieser Raum, der von nun an verwendet wird.

00:16:43,840 --> 00:16:49,440
Und nun, was in der letzten Zeile steht, ist
also eine ausgewählte Menge von syntaktischen

00:16:49,440 --> 00:16:53,280
Anwendung der Prädikatssymbole auf Grundterme,
das wäre eine Herbrand-Interpretation.

00:16:53,280 --> 00:16:58,400
Denn sie sagt uns, was in einem
bestimmten Modell als wahr gilt.

00:16:58,400 --> 00:16:59,440
Okay, im Herbrand-Modell.

00:17:00,240 --> 00:17:01,760
Okay, lassen Sie uns das
anhand eines Beispiels tun.

00:17:01,760 --> 00:17:02,880
So, das war unser Beispiel.

00:17:03,440 --> 00:17:05,680
Daran können wir sehen, was
eine Signatur ist, richtig?

00:17:06,560 --> 00:17:09,200
Es gibt diese Konstante einfach
in 0 der Stelligkeit 0.

00:17:09,200 --> 00:17:12,400
Und das Funktionssymbol s hat
die Stelligkeit eins, richtig?

00:17:12,400 --> 00:17:17,840
Denn es nimmt ein Argument, wie
wir zum Beispiel hier sehen.

00:17:18,960 --> 00:17:21,280
Daraus können wir dann ein
Herbrand-Universum aufbauen.

00:17:21,840 --> 00:17:27,680
Also, alle Grundterme über der Signatur, und wir haben
bereits angedeutet, worauf das hinausläuft, nämlich,

00:17:27,680 --> 00:17:30,400
all diese verschachtelten Anwendungen.

00:17:30,400 --> 00:17:33,520
Und da es nur einen Datenkonstruktor
gibt, gibt es keine Auswahl mehr.

00:17:33,520 --> 00:17:37,200
Es ist also immer s von, s von, s
von, und irgendwann wird es Null sein.

00:17:37,200 --> 00:17:41,280
Also, all diese Kombinationen, natürlich,
in gewissem Sinne natürliche Zahlen dar.

00:17:41,280 --> 00:17:43,040
Aber hier findet eine
Interpretation statt, richtig?

00:17:43,040 --> 00:17:45,280
Das ist nur eine syntaktische Betrachtung.

00:17:45,280 --> 00:17:50,400
Und wichtig ist, dass wir im Herbrand-Universum
das Prädikatsymbol nicht verwenden.

00:17:50,400 --> 00:17:53,680
Schauen Sie sich also wirklich nur die Dinge
an, die in Argumentpositionen vorkommen können.

00:17:53,680 --> 00:17:55,520
Die Null und das s von etwas.

00:17:55,520 --> 00:17:59,840
Okay, und wir betrachten hier keine Variablen,
hier nicht, denn das sollten Grundterme sein.

00:17:59,840 --> 00:18:01,360
Okay, das ist also das Herbrand-Universum.

00:18:02,640 --> 00:18:08,720
Und dann gibt es noch die einfachste, oder
die einfachste Herbrand-Interpretation wäre

00:18:08,720 --> 00:18:13,280
die Herbrand-Basis, das wären einfach
alle Anwendungen der Prädikatssymbole.

00:18:13,280 --> 00:18:15,680
Nun, wir haben nur ein Prädikat
Symbol hier im Programm

00:18:15,680 --> 00:18:20,320
zu allen möglichen Termen aus
dem Herbrand-Universum, richtig?

00:18:20,320 --> 00:18:21,840
Dies ist also die Herbrand-Basis.

00:18:21,840 --> 00:18:26,240
Es ist eine bestimmte Herbrand-Interpretation,
aber nicht unbedingt die, nach der wir suchen.

00:18:26,240 --> 00:18:26,640
Richtig?

00:18:26,640 --> 00:18:30,640
Die Herbrand-Interpretation wäre jede
Teilmenge dieser sehr großen Menge,

00:18:30,640 --> 00:18:37,200
die alle Punkte enthält. Punkt, Punkt,
Punkt, hier würden wir tatsächlich

00:18:37,200 --> 00:18:44,480
alle Anwendungen von "add" auf jede
Dreiergruppe von Elementen aus dieser Menge.

00:18:44,480 --> 00:18:47,840
Einschließlich Dinge, von denen wir intuitiv
wissen, dass sie nicht wahr sind, richtig?

00:18:47,840 --> 00:18:51,280
Wir wissen, dass Null plus Null nicht eins ist,
aber die Herbrand-Basis kümmert sich nicht darum.

00:18:51,280 --> 00:18:55,840
Sie enthält alle Anwendungen von Prädikatssymbolen
auf Terme, die dies gefunden haben,

00:18:55,840 --> 00:18:59,840
in diesem Fall die unendliche Menge, und später
haben wir eigentlich die Herbrand-Interpretation, die

00:19:01,120 --> 00:19:02,800
in gewissem Sinne wahrer ist, oder?

00:19:02,800 --> 00:19:04,880
Also, logisch konsistenter des Prologs.

00:19:04,880 --> 00:19:07,120
Aber die Herbrand-Basis ist
einfach alle Anwendungen hier.

00:19:08,720 --> 00:19:09,840
Okay.

00:19:10,560 --> 00:19:15,280
Also, was man eigentlich sucht, also die Herbrand-Interpretation,
ist eine Teilmenge der Herbrand-Basis und

00:19:15,280 --> 00:19:21,440
sollte die Herbrand-Interpretation sein, die
das Programm wahr macht und sonst nichts.

00:19:22,320 --> 00:19:28,800
Nun, wir sollten genau die Dinge wahr machen,
die durch das gegebene Programm erzwungen werden.

00:19:28,800 --> 00:19:37,840
Denn dann ist es das perfekte Modell, aus dem wir
alle Dinge ableiten können, die ableitbar wären.

42 # slide
00:19:38,960 --> 00:19:41,840
Die nächste Frage ist dann, ob wir
dieses perfekte Modell tatsächlich auf

00:19:42,720 --> 00:19:46,240
irgendwie konstruktiv dieses
perfekte Modell berechnen können.

00:19:46,240 --> 00:19:48,400
Es müsste also die kleinste

00:19:48,400 --> 00:19:51,840
Herbrand-Interpretation sein, die ein Modell
ist, kleinste im Sinne von "Teilmenge".

00:19:53,200 --> 00:19:55,200
Ja, denn dann haben wir genau

00:19:57,120 --> 00:20:01,440
alle Dinge, den ganzen Grund, na ja, gesammelt,
alle Anwendungen von Prädikaten auf Grundterme,

00:20:01,440 --> 00:20:06,880
die dann wahr sein müssen, weil sie die
Konsequenz des Programms sind, aber mehr nicht.

00:20:06,880 --> 00:20:10,320
Also, die kleinste Herbrand
Interpretation, die ein Modell ist.

00:20:11,040 --> 00:20:11,540
Okay.

00:20:11,920 --> 00:20:15,440
Nun, eine vernünftige Frage wäre eigentlich die:
Gibt es eine solche kleinste Interpretation?

00:20:15,440 --> 00:20:17,680
Oder gibt es vielleicht verschiedene,
die nicht vergleichbar sind?

00:20:17,680 --> 00:20:18,880
Also, gibt es eine kleinste?

00:20:18,880 --> 00:20:20,400
Und wenn ja, können wir sie berechnen?

00:20:20,400 --> 00:20:20,720
Nun gut.

00:20:20,720 --> 00:20:22,720
Und die Antwort auf beide Fragen ist ja.

00:20:23,440 --> 00:20:27,040
Und die Methode dazu ist der sogenannte

00:20:27,040 --> 00:20:31,040
"unmittelbare Konsequenz-Operator", was
vielleicht etwas kompliziert klingt.

00:20:31,040 --> 00:20:35,840
Und hat auch eine Definition, die auf den ersten Blick
vielleicht auf den ersten Blick kompliziert aussieht,

00:20:35,840 --> 00:20:38,480
aber wir werden gleich sehen,
dies auf ein Beispiel anwenden.

00:20:38,480 --> 00:20:42,080
Und wir werden sehen, dass das ein
sehr intuitiver Prozess abläuft.

00:20:43,280 --> 00:20:44,080
Okay, was ist das also?

00:20:44,080 --> 00:20:45,200
Das ist ein Operator,

00:20:46,000 --> 00:20:48,080
der Mengen in neue Mengen verwandelt.

00:20:48,080 --> 00:20:49,920
Also, im Grunde gibt man ihm
eine Herbrand-Interpretation,

00:20:50,560 --> 00:20:52,560
und er gibt eine neue
Herbrand-Interpretation zurück.

00:20:52,560 --> 00:20:58,800
Er operiert also auf den Teilmengen der Sache der
Herbrand-Basis, die auf der vorherigen Folie zu sehen ist.

00:20:59,600 --> 00:21:02,800
Okay, man nennt ihn den "unmittelbaren
Konsequenzoperator", weil er immer

00:21:02,800 --> 00:21:06,640
neue Konsequenzen berechnet und diese sind
unmittelbare Konsequenzen in dem Sinne,

00:21:06,640 --> 00:21:10,400
dass sie aus dem, was wir bereits
in der vorherigen Menge hatten.

00:21:10,400 --> 00:21:14,000
Bevor wir also den Operator
anwenden, müssen sie sich aus diesem

00:21:14,000 --> 00:21:18,880
mit nur einem Argumentationsschritt durch Anwendung einer
Tatsache oder einer Regel aus unserem anderen Programm, richtig?

00:21:18,880 --> 00:21:22,800
Also, das Programm p als
tiefgestelltes Zeichen auf.

00:21:22,800 --> 00:21:26,480
Also, mit der unmittelbaren Konsequenz ist
der Operator immer relativ zu einem Programm.

00:21:27,680 --> 00:21:31,920
Okay, und dann operiert er
auf diese Interpretationen.

00:21:31,920 --> 00:21:32,800
Okay, und was macht er?

00:21:32,800 --> 00:21:34,400
Nun, er nimmt eine solche Menge,

00:21:34,400 --> 00:21:38,960
eine solche Teilmenge der Herbrand-Basis,
was dann eine Herbrand-Interpretation ist.

00:21:38,960 --> 00:21:40,800
Und es erzeugt alle Grundliterale.

00:21:40,800 --> 00:21:43,040
Das sind also Dinge, die in
einer Herbrand-Interpretation

00:21:43,040 --> 00:21:46,160
vorkommen können, denn sie sind genau
die Elemente der Herbrand-Basis, richtig?

00:21:46,160 --> 00:21:48,560
Prädikatssymbole, die auf
Grundterme angewendet werden.

00:21:48,560 --> 00:21:55,920
Es erzeugt also alle Grundliterale plus
Null für die es gibt L eins, zwei, Ln

00:21:56,480 --> 00:22:01,920
für irgendeine natürliche Zahl n, die bereits
in der aktuellen Interpretation, richtig?

00:22:01,920 --> 00:22:03,520
Daraus wollen wir eine Konsequenz ziehen.

00:22:03,520 --> 00:22:11,840
Wir müssen also L1, L2 bis Ln, bereits in der
gegebenen I so, dass die Null erhalten würde,

00:22:12,400 --> 00:22:18,640
wenn wir irgendeine Tatsache oder Regel aus dem Programm nehmen,
die auf irgendeine konsistente Weise instanziiert wurde, richtig?

00:22:18,640 --> 00:22:21,520
Also, konsistent in dem Sinne, dass wenn
man einen Fakt oder eine Regel hat, die

00:22:21,520 --> 00:22:26,400
Variable x enthält, dann können wir x durch einen
beliebigen Grundterm ersetzen, aber natürlich,

00:22:26,400 --> 00:22:32,400
müssen wir es in der gleichen Weise ersetzen,
zum Beispiel alle Literale entsprechend ersetzen.

00:22:34,240 --> 00:22:40,480
Okay, also, wir haben ein I, wir haben Regeln,
wir können sie vollständig instanziieren.

00:22:40,480 --> 00:22:42,560
So dass es keine Variablen mehr gibt.

00:22:42,560 --> 00:22:49,520
Und dann machen wir das auf alle möglichen Arten,
so dass wir L1, Ln schon im aktuellen I finden.

00:22:49,520 --> 00:22:53,520
Und wenn ja, dann setzen wir die L0, die
natürlich auch seine Variablen ersetzt hat,

00:22:53,520 --> 00:22:59,680
durch die Dinge, die wir für die Variablen gewählt
haben, und setzen diese Null in die nächste Menge.

00:22:59,680 --> 00:23:02,400
Also, in das, was Tp aus diesem I macht.

00:23:04,320 --> 00:23:07,520
Okay, es ist wichtig zu beachten, dass
das n auch Null sein kann, richtig?

00:23:07,520 --> 00:23:11,280
Dann hätten Sie eine Regel mit einer leeren
rechten Seite, mit einem leeren Rumpf,

00:23:11,280 --> 00:23:12,640
das wäre dann ein Fakt, richtig?

00:23:12,640 --> 00:23:18,000
Der Fall der Fakten wird hier also auch behandelt,
das ist der Fall, wenn n gleich Null ist.

00:23:18,640 --> 00:23:27,600
Dann setzen wir einfach in die nächste Menge alle
Instanziierungen aller Grundinstantiierungen unseres

00:23:28,480 --> 00:23:30,960
Fakts in die nächste Menge, wenn
unser Kopf den leeren Rumpf hat.

00:23:32,400 --> 00:23:35,920
Okay, das ist also eine Operation auf Mengen,
die Sie gleich in Aktion sehen werden.

00:23:35,920 --> 00:23:37,200
Und wofür ist sie nützlich?

00:23:37,200 --> 00:23:39,680
Nun, wir können sie auf was anwenden?

00:23:39,680 --> 00:23:43,120
Nun, zum Beispiel auf die leere Menge, wir müssen
irgendwo als Ergebnis der leeren Menge beginnen.

00:23:43,120 --> 00:23:47,200
Und dann können wir diesen Operator auf die leere Menge
anwenden, dann bekommen wir vielleicht neue Elemente.

00:23:47,200 --> 00:23:50,080
Also, die leere Menge wächst
zu etwas Nicht-Leerem.

00:23:50,080 --> 00:23:53,120
Dann können wir diesen Folgeoperator
erneut auf diese Menge anwenden.

00:23:53,120 --> 00:23:54,560
Und wieder, und wieder.

00:23:54,560 --> 00:23:59,200
Und es ist schwer zu erkennen, dass dadurch
die Mengen nur größer werden können.

00:23:59,200 --> 00:24:05,840
Sie können also nicht kleiner werden und
entweder wird das Ganze irgendwann stabil,

00:24:05,840 --> 00:24:11,520
und es gibt eine feste Endmenge, oder wir haben auch
unendliche Mengen, die irgendwie irgendwann stabil werden.

00:24:11,520 --> 00:24:14,720
Das geht immer weiter und
weiter und weiter und weiter.

00:24:14,720 --> 00:24:16,560
Aber selbst dann gibt es,
mathematisch gesehen, eine Grenze.

00:24:16,560 --> 00:24:19,920
Es gibt also zumindest eine obere
Grenze für diese unendliche Folge.

00:24:19,920 --> 00:24:24,880
Und was auch immer das ist, ob es in der endlichen
Zeit, oder es ist einfach eine unendliche Grenze,

00:24:24,880 --> 00:24:28,160
das wird das kleinste Herbrand-Modell
sein, nach dem wir suchen.

00:24:28,160 --> 00:24:31,600
Okay, wir haben also einen Fixpunkt oder ein Limit
einer Folge, die mit der leeren Menge beginnt.

00:24:31,600 --> 00:24:35,120
Indem wir diese Operation, die hier
definiert ist, auf die leere Menge

00:24:35,120 --> 00:24:40,000
anwenden, erhalten wir eine neue Menge, wenden Tp
auf diese Menge, und dann auf diese Menge, usw.

00:24:40,000 --> 00:24:42,960
Und entweder hört es an einem bestimmten
Punkt auf oder es geht ewig so weiter.

00:24:42,960 --> 00:24:44,480
Aber sie wird nie kleiner.

00:24:44,480 --> 00:24:50,800
Wenn wir also in einer der Mengen eine wörtliche Zahl
finden, der Mengen finden, dann wissen wir, dass es auch

00:24:50,800 --> 00:24:54,960
im kleinsten Herbrand-Modell vorkommen
wird, weil die Mengen nur wachsen.

00:24:54,960 --> 00:24:57,760
Wenn also etwas in einer der Mengen auftaucht,

00:24:57,760 --> 00:25:02,880
wissen wir, dass es etwas ist, das wirklich
logisch aus dem Programm ableitbar ist.

00:25:02,880 --> 00:25:04,800
Denn es erscheint im kleinsten Herbrand-Modell.

00:25:05,840 --> 00:25:13,840
Und das ist es, was wir als die
Bedeutung des Programms betrachten.

43 # slide
00:25:15,840 --> 00:25:18,480
Schauen wir uns das am Beispiel an.

00:25:18,480 --> 00:25:20,080
Also, das ist wieder dasselbe Programm.

00:25:20,800 --> 00:25:23,760
Und wo wir von der leeren Menge ausgehen,
müssen wir nicht die leere Menge aufschreiben,

00:25:23,760 --> 00:25:28,880
aber wir sollten die erste Anwendung des
Tp-Operators auf die leere Menge aufschreiben.

00:25:28,880 --> 00:25:29,920
Was wird das also sein?

00:25:29,920 --> 00:25:36,640
Nun, was müssen wir tun? Wir müssen prüfen,
welche rechten Seiten des gegebenen Programms

00:25:36,640 --> 00:25:42,400
Programmklauseln wir bereits in grundinstanziierter
Form in unserer gegebenen Menge finden.

00:25:42,400 --> 00:25:45,920
Wenn diese gegebene Menge am Anfang die
leere Menge ist, ist es bereits klar, dass

00:25:45,920 --> 00:25:50,560
es keinen Sinn macht, diese zweite Regel im
Operator der unmittelbaren Folge zu verwenden.

00:25:50,560 --> 00:25:56,480
Denn es gibt kein l1 auf der rechten Seite,
das wir auch in dem gegebenen I finden könnten.

00:25:56,480 --> 00:26:00,080
Okay, im ersten Schritt macht es also nur
Sinn, sich die Fakten des Programms anzusehen.

00:26:00,080 --> 00:26:01,200
Und was müssen wir dann tun?

00:26:01,200 --> 00:26:04,480
Nun, im Falle eines Fakts haben wir
keine rechte Seite zu berücksichtigen.

00:26:04,480 --> 00:26:09,200
Alles, was wir tun müssen, ist also zu
prüfen oder alle Grundinstantiierungen

00:26:09,200 --> 00:26:13,760
dieses Kopfes zu prüfen und zu versuchen, die
Menge auf unsere nächste Menge zu übertragen.

00:26:14,880 --> 00:26:17,520
Okay, und wo würden unsere
Grundinstantiierungen hier sein?

00:26:18,160 --> 00:26:20,960
Nun, es gibt eine Variable, die zweimal vorkommt.

00:26:20,960 --> 00:26:24,800
Wir müssen also alle Grundterme betrachten
und sie für x ersetzen, aber natürlich für

00:26:26,160 --> 00:26:27,120
beide Vorkommen von x.

00:26:27,680 --> 00:26:34,160
Okay, das bedeutet also, dass die erste
Anwendung des Tp-Operators auf die leere Menge

00:26:34,160 --> 00:26:38,320
uns diese bereits unendliche Menge mit
einem klaren Wiederholungsmuster, richtig?

00:26:38,320 --> 00:26:38,640
Wir erhalten also 0, 0, 0.

00:26:38,640 --> 00:26:41,440
Natürlich können wir beide
Xs durch die Null ersetzen,

00:26:41,440 --> 00:26:45,360
wir können auch beide Xs durch ein anderes
Element des Herbrand-Universums ersetzen.

00:26:45,360 --> 00:26:46,240
Vielleicht s von Null.

00:26:46,240 --> 00:26:51,120
Dann bekommen wir dieses Literal in unsere Menge,
können das gleiche für s von, s von Null, usw. tun.

00:26:51,120 --> 00:26:56,720
Hier fügen wir also Elemente aus dem Herbrand-
Universum ein, das wir zuvor festgelegt haben,

00:26:56,720 --> 00:26:57,440
zwei Folien zurück.

00:26:58,160 --> 00:27:00,800
Okay, das ist also, was in
der ersten Iteration passiert.

00:27:01,760 --> 00:27:02,640
Dann machen wir das noch einmal.

00:27:02,640 --> 00:27:06,000
Wir wenden Tp jetzt wieder auf diese Menge an.

00:27:06,000 --> 00:27:07,040
Und was bedeutet das?

00:27:07,040 --> 00:27:11,840
Nun, natürlich würde es immer noch oder
wieder alle diese Elemente erhalten, richtig?

00:27:11,840 --> 00:27:14,800
Denn im nächsten Schritt und wir können
uns immer noch den ersten Fakt ansehen.

00:27:14,800 --> 00:27:17,920
Es hat eine rechte Seite, also müssen wir
nichts in der vorherigen Menge finden.

00:27:17,920 --> 00:27:21,360
Wir können einfach alle
Grundinstantiierungen des Dings hinzufügen.

00:27:21,360 --> 00:27:24,160
Aber das würde nur Dinge hinzufügen, die
wir bereits gesehen haben, das macht keinen

00:27:24,160 --> 00:27:26,400
Sinn oder nichts
interessantes Neues.

00:27:26,960 --> 00:27:33,040
Es ist also wichtiger, im nächsten Schritt,
sich die eigentlichen Regeln anzusehen.

00:27:33,040 --> 00:27:37,680
Denn jetzt haben wir Sachen
bereits in unserem aktuellen Satz.

00:27:37,680 --> 00:27:43,600
Wir können also in dieser Menge tatsächlich
nach Grundinstanzen dieser rechten Seite suchen.

00:27:44,160 --> 00:27:50,400
Und für jede Wahl von x, y und z, für die
wir hier ein Element finden, können wir

00:27:50,400 --> 00:27:56,160
bei der nächsten Iteration die entsprechende
Instanziierung des Kopfes dieser Regel hinzufügen.

00:27:58,000 --> 00:28:00,080
Okay, wir haben also schon alles, was wir haben.

00:28:00,080 --> 00:28:03,280
Und das wird immer der Fall sein, ich habe bereits
erwähnt, dass die Mengen nur wachsen können.

00:28:03,280 --> 00:28:06,880
Also, jede aufeinanderfolgende Menge
hat die vorherige Menge als Teilmenge,

00:28:06,880 --> 00:28:12,080
und dann können neue Dinge hinzugefügt werden
oder es wird stationär und die Folge hört auf.

00:28:12,640 --> 00:28:15,280
Okay, hier bekommen wir also
das, was wir schon hatten, plus.

00:28:15,280 --> 00:28:16,400
Nun, plus was?

00:28:16,400 --> 00:28:22,080
Zum Beispiel, da dies als eine Instanziierung
für diese rechte Seite hier genommen werden kann.

00:28:22,080 --> 00:28:27,680
Wenn man x, y und z so wählt, dass alle
drei null sind, müssen wir s der x addieren.

00:28:27,680 --> 00:28:31,120
s von null, y null, s von z null.

00:28:31,120 --> 00:28:36,080
So erhalten wir aus diesem
Literal dieses neue Literal.

00:28:36,080 --> 00:28:38,240
Und auf ähnliche Weise erhalten wir neue Literale

00:28:38,240 --> 00:28:41,760
eigentlich für jedes derjenigen, die wir bereits
in unserer aktuellen Menge haben, richtig?

00:28:41,760 --> 00:28:48,320
Aus diesem Grund, weil wir auch wählen können,
x zu null, y und z zu den beiden s von null,

00:28:49,120 --> 00:28:52,640
daraus folgt dieses neue Prädikat.

00:28:54,320 --> 00:28:57,760
Mathematisch neues wörtliches Prädikat
Anwendung in der nächsten Iteration.

00:28:57,760 --> 00:28:58,720
Und dasselbe hier.

00:28:58,720 --> 00:29:02,480
Und natürlich, aus jeder dieser
Instanziierungen für jedes der

00:29:02,480 --> 00:29:05,760
Literale, die an diesem Punkt, Punkt, Punkt
vorkommen, erhält man auch hier ein neues.

00:29:06,880 --> 00:29:08,400
Okay, lassen Sie mich das noch einmal machen.

00:29:09,280 --> 00:29:10,240
Und noch einmal, und noch einmal.

00:29:10,240 --> 00:29:13,920
Richtig, und hier haben wir bereits
ich habe die Pfeile hier nicht.

00:29:13,920 --> 00:29:19,440
Aber wieder, von jeder neuen Sache, die in
der vorherigen Iteration aufgetreten ist,

00:29:19,440 --> 00:29:22,080
erhalten wir eine weitere neue Sache
für die nächste Iteration, richtig?

00:29:22,080 --> 00:29:23,600
Wir erhalten alles, was wir bereits haben.

00:29:24,960 --> 00:29:28,880
Plus neue Dinge in diesem Beispiel, das muss nicht
immer der Fall sein, aber hier ist es der Fall.

00:29:29,440 --> 00:29:31,920
Okay, das würde also eigentlich
immer so weitergehen.

00:29:31,920 --> 00:29:35,120
Und wenn wir dann sehr genau
hinschauen und überlegen, na ja,

00:29:35,120 --> 00:29:39,440
was wäre eigentlich die Grenze, von wenn
wir das unendlich oft machen würden?

00:29:39,440 --> 00:29:42,800
Nun, eigentlich wäre die Grenze diese
Menge, die man nicht aufschreiben kann

00:29:44,000 --> 00:29:45,360
durch endliche Aufzählung, natürlich.

00:29:45,360 --> 00:29:48,640
Denn sie enthält unendlich viele
Elemente, schon die erste Menge hier

00:29:48,640 --> 00:29:51,040
und dann sicherlich alle anderen auch.

00:29:51,040 --> 00:29:54,720
Obwohl, was hier eigentlich erscheinen würde,
kann man dieses Muster eigentlich schon sehen.

00:29:54,720 --> 00:30:01,600
Wenn man sich die Beispiele hier anschaut, bekommen wir immer
erhalten wir für alle Wahlmöglichkeiten schließlich von I und J

00:30:03,120 --> 00:30:09,440
s, I mal angewandt auf null, s J mal angewandt
auf null, s I plus J mal auf null angewandt.

00:30:09,440 --> 00:30:09,680
Richtig?

00:30:09,680 --> 00:30:13,920
Also, hier werden Sie nie etwas finden, was
nicht eine logische Konsequenz dieser Regeln ist.

00:30:13,920 --> 00:30:16,480
Sie erhalten zwei plus zwei ist
vier, zwei plus eins ist drei.

00:30:17,120 --> 00:30:19,120
Also, hier gibt es kein dummes Zeug.

00:30:19,120 --> 00:30:22,240
Man bekommt nur Dinge, die tatsächlich eine
Konsequenz des gegebenen Programms sind.

00:30:22,240 --> 00:30:24,160
Und eigentlich auch alles, was intuitiv

00:30:24,160 --> 00:30:27,440
eine Konsequenz aus dieser Definition der
Addition ist, wird irgendwann auftauchen.

00:30:27,440 --> 00:30:29,760
Das ist es, was diese letzte
Zeile hier eigentlich behauptet,

00:30:29,760 --> 00:30:32,960
oder bewiesen, aber es ist die
Tatsache, dass dies geschehen wird.

00:30:33,520 --> 00:30:37,520
Okay, in diesem Sinne fängt dieser Prozess genau

00:30:37,520 --> 00:30:40,480
die Bedeutung dieses Zusatzes
Prädikat dieser Definition.

44 # slide
00:30:44,880 --> 00:30:47,440
Das war also nur ein Beispiel.

00:30:47,440 --> 00:30:51,480
Die Frage ist jetzt natürlich: Funktioniert
das immer, für alle Prolog-Programme?

00:30:51,480 --> 00:30:56,000
Ist es immer möglich, dies zu tun,
mit dieser Tp-Semantik zu arbeiten?

00:30:56,000 --> 00:31:00,640
Und nun, die Antwort ist nicht
für alle Teile der Prolog-Sprache.

00:31:00,640 --> 00:31:02,160
So zum Beispiel für die Arithmetik.

00:31:02,160 --> 00:31:06,720
Die Verwendung dieses "is"-Konstrukts ist
also, um Dinge tatsächlich auszuwerten.

00:31:06,720 --> 00:31:09,840
Und das ist nicht abgedeckt
durch diese deklarative Semantik,

00:31:09,840 --> 00:31:14,560
hauptsächlich, weil die Semantik so
symbolisch orientiert ist, richtig?

00:31:14,560 --> 00:31:18,720
Also, diese Arithmetik, die wirklich die Berechnung
von zwei plus fünf als sieben ist, ist genau etwas,

00:31:18,720 --> 00:31:22,640
das nicht rein syntaktisch ist, also
passt es nicht wirklich zu diesem Ansatz.

00:31:22,640 --> 00:31:25,760
Das ist also etwas, das nicht
durch die Semantik abgedeckt wird.

00:31:25,760 --> 00:31:27,760
Und natürlich können wir

00:31:27,760 --> 00:31:30,800
die deklarative Semantik auch nicht auf
Programme anwenden, die Arithmetik enthalten.

00:31:30,800 --> 00:31:35,200
Aber es gibt auch andere Dinge, andere
Beschränkungen, denen wir unterliegen.

00:31:35,200 --> 00:31:40,720
So ist zum Beispiel die Negation generell
bei deklarativer Semantik problematisch.

00:31:41,280 --> 00:31:42,720
Wir werden dies also nicht berücksichtigen.

00:31:42,720 --> 00:31:52,560
Weder die Negation in der Form dieses ungleich-Prädikats,
noch Beziehungen, noch die allgemeine Negation

00:31:52,560 --> 00:31:58,320
eines Literals werden also im Kontext
der deklarativen Semantik betrachtet.

00:31:58,320 --> 00:32:00,240
Denn das funktioniert nicht wirklich.

00:32:00,880 --> 00:32:01,120
Oder?

00:32:01,120 --> 00:32:05,040
Die Interpretation von "not" ist etwas,
das operationell verstanden werden muss.

00:32:06,800 --> 00:32:11,200
Zumindest, wenn man das Negationssymbol
verwendet, gibt es ausgefeiltere Versionen

00:32:11,200 --> 00:32:14,800
in der Literatur, die sich auch mit der Negation
umgehen können, aber das ist nichts für diesen Kurs.

00:32:14,800 --> 00:32:16,480
Also, im Kurs sagen wir einfach,

00:32:16,480 --> 00:32:21,840
Sie werden die Negation nicht in Programmen verwenden,
für die Sie die deklarative Semantik verwenden wollen.

00:32:22,480 --> 00:32:25,040
Auch in Übungen usw. wird dies nicht vorkommen.

00:32:25,680 --> 00:32:29,040
Und darüber hinaus gibt es
auch in der Sprache Prolog,

00:32:29,040 --> 00:32:32,960
obwohl es eine logische Programmiersprache ist, gibt
es auch Funktionen, die nicht wirklich logisch sind.

00:32:33,600 --> 00:32:34,800
Sie werden in dieser Vorlesung nicht vorgestellt.

00:32:34,800 --> 00:32:41,360
Hier beschränken wir uns also auf den logischen Teil von
Prolog und auch auf die extra-logischen Eigenschaften,

00:32:41,360 --> 00:32:45,600
müssten wir uns auch mit der Tatsache befassen,
dass sie nicht dieser Semantik folgen.

00:32:45,600 --> 00:32:49,120
Sie sind also nicht wirklich kompatibel mit
der Semantik, weil sie wirklich von einer

00:32:49,120 --> 00:32:50,320
Modelltheorie aus der Logik.

00:32:50,320 --> 00:32:53,120
Wenn wir also etwas haben, das nicht
logisch ist, dann stimmt es nicht

00:32:53,120 --> 00:33:00,080
mit der Semantik überein. Okay, das sind die
Beschränkungen, unter denen die Semantik arbeitet.

00:33:01,280 --> 00:33:07,680
Okay, also für Sie werden wir natürlich
sicherstellen, dass dies immer erfüllt ist,

00:33:08,800 --> 00:33:13,280
wenn Sie ein Programm bekommen, für das Sie
auf deklarative Semantik prüfen sollten.

00:33:13,840 --> 00:33:14,480
Das ist gut.

00:33:14,480 --> 00:33:17,600
Aber das bedeutet natürlich nicht, dass es keine
interessanten Programme gibt, für die man das tun kann.

00:33:17,600 --> 00:33:20,800
Natürlich gibt es die, und Sie werden
einige in den Übungen sehen, usw.

00:33:20,800 --> 00:33:24,640
Und auch hier habe ich ein weiteres
Beispiel, das nur etwas komplizierter ist.

00:33:24,640 --> 00:33:28,160
Aber immerhin hat es schon zwei
Prädikate und Definitionen für sie.

00:33:28,960 --> 00:33:31,840
Und das eine ruft das andere auf, das könnte
sogar eine gegenseitige Rekursion sein,

00:33:31,840 --> 00:33:33,840
auch wenn das in diesem Beispiel nicht vorkommt.

00:33:33,840 --> 00:33:39,280
Aber man könnte viele Prädikate haben, die sich
gegenseitig rekursiv aufrufen können, wenn wir

00:33:39,280 --> 00:33:44,560
hier auch ein Programmprädikat mit mehr als
zwei Regeln, mit zwei Fakten und einer Regel.

00:33:44,560 --> 00:33:48,080
Wir haben hier einen Fall auf der rechten
Seite, wir haben mehrere Literale, usw.

00:33:48,080 --> 00:33:54,320
Anhand dieses Beispiels können Sie also wirklich
sehen, die aufwändigere Version dieser Iteration.

00:33:54,880 --> 00:33:58,240
Ich werde das hier nicht hier auf den
Folien nicht im Detail durchgehen.

00:33:58,240 --> 00:33:59,280
Ich habe also die Folien.

00:33:59,280 --> 00:34:02,000
Und Sie können auch sehen, was passiert,
was in jeder der Iterationen passiert.

00:34:02,000 --> 00:34:07,280
Aber ich werde nicht jeden Schritt
erklären, denn in dem collection.pdf

00:34:07,280 --> 00:34:11,600
im Moodle-Kurs, wo ich die
Übungsaufgaben und deren Lösungen.

00:34:11,600 --> 00:34:14,880
Es gibt tatsächlich ein sehr ähnliches Beispiel,
wo das wirklich sehr detailliert beschrieben wurde,

00:34:14,880 --> 00:34:21,520
wo wirklich jeder Schritt erklärt
wird und wie und warum bestimmte neue

00:34:21,520 --> 00:34:27,280
Literale in der nächsten Iteration des
Tp-Operators erscheinen, wird ausführlich erklärt.

00:34:27,280 --> 00:34:33,120
Das entspricht also den Pfeilen, die
ich auf der vorherigen Folie hatte.

00:34:33,120 --> 00:34:40,000
Und hier wiederum, wo ich im Grunde sage, na ja,
weil diese beiden Literale in dieser Iteration waren,

00:34:40,000 --> 00:34:42,560
kommt jetzt dieses neue Element
in dieser Iteration auf, richtig?

00:34:42,560 --> 00:34:47,040
Ich erkläre dies Jahr also nicht im Detail, aber nun,
wenn Sie sich die Texterklärung zu diesem anderen

00:34:47,040 --> 00:34:52,560
Beispiel in der collection.pdf durchlesen, dann
finden Sie genau solche Erklärungen von Schritten.

00:34:52,560 --> 00:34:57,200
Warum taucht etwas genau in
dieser Iteration auf?

00:34:57,200 --> 00:34:57,360
Eben.

00:34:57,360 --> 00:35:02,640
Also, was Sie aus diesem Beispiel entnehmen
können, hier erkläre ich nicht jeden Schritt,

00:35:02,640 --> 00:35:04,560
ist, wie es wächst und wächst und wächst.

00:35:04,560 --> 00:35:10,480
Und Sie werden immer neues Wissen darüber bekommen,
in diesem Fall die Addition und die Multiplikation

00:35:11,600 --> 00:35:12,240
von Prädikaten.

00:35:12,240 --> 00:35:14,960
Wie neues Wissen Schritt
für Schritt aufgebaut wird,

00:35:15,520 --> 00:35:18,400
wenn wir diesen unmittelbaren
Folgeoperator wiederholt anwenden.

00:35:18,960 --> 00:35:22,000
Okay, hier ist also etwas. In
der ersten Iteration wurde nur

00:35:22,000 --> 00:35:24,480
Wissen aus den Fakten akkumuliert, richtig?

00:35:24,480 --> 00:35:27,120
Denn wie im vorherigen Beispiel verwenden wir
in den ersten Iterationen nicht die Regeln mit

00:35:27,680 --> 00:35:30,000
tatsächlichen rechten Seiten
in den ersten Iterationen.

00:35:30,000 --> 00:35:31,440
In der ersten Iteration hatten wir nur

00:35:32,000 --> 00:35:36,480
Instanziierungen dieser drei Fakten und in
späteren Iterationen kommen dann neue Dinge hinzu.

45 # slide
00:35:36,480 --> 00:35:43,840
So zum Beispiel hier, aber auch hier
bekommen wir wieder neues Material.

00:35:45,680 --> 00:35:52,560
Okay, also, hier sind zwei Fälle, in denen wir aufgeschrieben
haben, warum ein bestimmtes neues Literal auftaucht.

00:35:52,560 --> 00:35:56,400
Dies erscheint also, weil wir
dies in der Menge hatten, richtig?

00:35:56,400 --> 00:36:02,480
Es war natürlich nicht in der Menge, weil
diese Menge ist das, was wir hier sehen.

00:36:03,200 --> 00:36:09,600
Es gibt also tatsächlich eine Aufforderung
dieser letzten Regel, bei der die Tatsache

00:36:09,600 --> 00:36:15,280
dass dies vorher vorhanden war und
dieses vorher vorhanden war, führt jetzt

00:36:15,280 --> 00:36:19,680
zu diesem neuen Wörtchen und
ebenso für etwas, das hier vorkam.

00:36:19,680 --> 00:36:25,040
Und das konkrete Wörtchen hier, das
führt zu diesem, und so weiter.

00:36:25,040 --> 00:36:31,920
Okay, am Ende erhält man zum Beispiel dies
Beispiel nach vier Schritten der Anwendung dieser

00:36:33,040 --> 00:36:36,080
unmittelbaren Konsequenz-Operator-Methode.
Wenn wir so weitermachen, erhalten

00:36:36,640 --> 00:36:46,880
wir alle gültigen Aussagen über Addition und
Multiplikation auf solchen symbolischen natürlichen Zahlen.

00:36:48,560 --> 00:36:50,160
Okay, das war's für jetzt.

00:36:50,960 --> 00:36:58,240
Und Sie haben das Material in der collection.pdf. Sie
werden natürlich auch eine Übungsaufgabe dazu haben.

00:36:58,240 --> 00:37:01,840
Und nächste Woche werden wir uns der
operationellen Semantik zuwenden,

00:37:02,960 --> 00:37:07,840
einer anderen Perspektive auf die
Bedeutung von Prolog-Programmen.
