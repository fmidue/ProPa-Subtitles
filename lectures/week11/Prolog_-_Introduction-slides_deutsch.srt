1 # slide
00:00:01,689 --> 00:00:06,180
Okay, willkommen zurück zur
Programmierparadigmen-Vorlesung.

00:00:06,180 --> 00:00:12,509
Schon aus dem Layout und dem Stil dieser
Folie können Sie erahnen und sehen, dass wir

00:00:12,509 --> 00:00:15,440
ein völlig neues Kapitel beginnen.

00:00:15,440 --> 00:00:21,930
In der Tat lassen wir Haskell für diesen Teil
der Vorlesung hinter uns und betrachten nun

00:00:21,930 --> 00:00:24,880
Prolog für den Rest des Kurses in der Vorlesung.

00:00:24,880 --> 00:00:31,050
Okay, und so ist der Prolog-Teil, der wie
früh angekündigt wurde, dass die Vorlesung in

00:00:31,050 --> 00:00:32,660
diese zwei Teile aufgeteilt wird.

00:00:32,660 --> 00:00:40,589
Also, offensichtlich ist das der kleinere
Teil der Vorlesung, nämlich da wir jetzt

00:00:40,589 --> 00:00:43,820
nach neun Vorlesungen sind und
weniger Vorlesungen übrig haben.

00:00:43,820 --> 00:00:51,000
Es sind also etwa 30 % des Kurses, was
zum Teil mit folgendem Fakt zu tun hat:

00:00:51,000 --> 00:00:55,109
Vieles von dem, was wir im Haskell-Teil gemacht
haben, kann auch als Inspiration für das Material im

00:00:55,109 --> 00:00:56,460
Prolog-Teil gesehen werden.

00:00:56,460 --> 00:01:03,579
Ja, ich habe am Anfang erwähnt, dass ein großer
Einfluss und eine große Vorbereitung für den

00:01:03,579 --> 00:01:09,800
Prolog-Teil, in dem es um die logische Programmierung geht,
tatsächlich ein Kurs über Logik ist, wie die meisten von

00:01:09,800 --> 00:01:13,720
Professor König gehört haben werden,
oder vielleicht auch anderswo.

00:01:13,720 --> 00:01:19,060
Aber hauptsächlich, denke ich, wird die Vorlesung
von Professor König Ihr logisches Fundament sein.

00:01:19,060 --> 00:01:24,050
Das ist also natürlich eine Voraussetzung
oder ein starker Einfluss für diesen Teil.

00:01:24,050 --> 00:01:28,270
Aber auch viele der Dinge, die wir
im Haskell-Teil gemacht haben, werden

00:01:28,270 --> 00:01:29,580
auch hier zum Tragen kommen.

00:01:29,580 --> 00:01:35,630
Das beginnt also mit der allgemeinen Idee,
ein völlig neues Programmierparadigma.

00:01:35,630 --> 00:01:43,340
Also, dass die Dinge wirklich anders sind als in
den imperativen Sprachen, die Sie bisher kennen.

00:01:43,340 --> 00:01:49,110
Die Idee der Deklarativität ist also etwas,
das sowohl Haskell als auch Prolog gemein ist,

00:01:49,110 --> 00:01:50,980
beziehungsweise sowohl der funktionalen
als auch der Logikprogrammierung.

00:01:50,980 --> 00:01:56,330
Aber auch spezifischere individuelle
Techniken werden von mir wieder gezeigt.

00:01:56,330 --> 00:02:02,730
Dazu gehört etwa die Tatsache, dass wir etwas
Ähnliches wie Pattern-Matching machen werden.

00:02:02,730 --> 00:02:06,490
Also, Pattern-Matching von der Haskell-Seite
wird hier sein Gegenstück haben.

00:02:06,490 --> 00:02:11,180
Auch die Art und Weise, in der
Nicht-Basistypen strukturiert sind.

00:02:11,180 --> 00:02:15,620
Die rekursive Datenstruktur, die wir in
Haskell gesehen haben, wird ein Analogon

00:02:15,620 --> 00:02:17,790
auch im Prolog-Teil haben.

00:02:17,790 --> 00:02:22,070
Natürlich wird die Syntax anders sein, aber
die Ideen dieser rekursiven Datenstrukturen

00:02:22,070 --> 00:02:23,290
werden wieder auftauchen.

00:02:23,290 --> 00:02:30,819
Und auch einige Aspekte der Trennungssemantik der
schrittweisen Auswertung oder schrittweisen Entwicklung

00:02:30,819 --> 00:02:40,640
der Ausführung von Abfragen im Falle von Prolog
werden zumindest an die Dinge erinnern, die

00:02:40,640 --> 00:02:41,810
wir in Haskell gesehen haben.

00:02:41,810 --> 00:02:42,810
Nun gut.

00:02:42,810 --> 00:02:44,790
Dennoch wird es auch wichtige
Unterschiede geben.

00:02:44,790 --> 00:02:50,080
Zum einen ist Prolog weder
befehls- noch ausdrucksbasiert.

00:02:50,080 --> 00:02:54,540
Also, im Haskell-Teil habe ich dann immer diese
Unterscheidung zwischen befehlsbasierten Sprachen

00:02:54,540 --> 00:02:58,550
unter die ich Dinge wie Python oder Java fasse.

00:02:58,550 --> 00:03:02,500
Und ausdrucksbasierter Programmierung, worauf
ich mich im Haskell-Teil konzentriert habe.

00:03:02,500 --> 00:03:06,270
Aber Prolog ist sicherlich nicht kommandobasiert,
aber es ist auch nicht ausdrucksbasiert in dem

00:03:06,270 --> 00:03:13,680
Sinne, dass die Ausführung von Prolog nicht darauf
basiert, dass ein Ausdruck zu einem Wert ausgewertet wird.

00:03:13,680 --> 00:03:16,350
Stattdessen basiert Prolog auf Propositionen.

00:03:16,350 --> 00:03:21,520
Wir haben also atomare Propositionen
und logische Konnektive zwischen diesen.

00:03:21,520 --> 00:03:27,849
Und ich erwähnte bereits, dass Abfragen oder Auswertungen
oder die operationale Ausführung von Prolog-Programmen

00:03:27,849 --> 00:03:29,410
durch Abfragen gesteuert wird.

00:03:29,410 --> 00:03:33,740
Und der Sinn einer Abfrage ist es zu
sehen, ob eine logische Aussage wahr ist.

00:03:33,740 --> 00:03:36,720
Und nicht, um etwas zu einem Wert
auszuwerten, zu einer Zahl, zum Beispiel.

00:03:36,720 --> 00:03:42,160
Der Hauptantrieb wird also sein, eine Abfrage zu
haben, die ein logischer Ausdruck ist und die Aufgabe

00:03:42,160 --> 00:03:47,270
des Prolog-Ausführungssystems wird sein,
herauszufinden, ob diese Abfrage wahr ist oder nicht.

00:03:47,270 --> 00:03:54,319
Es ist also hauptsächlich eine Frage der Erfüllbarkeit, und
die Ergebnisse werden Nebenprodukte in dem Sinne sein, dass

00:03:54,319 --> 00:04:00,629
wenn Sie eine Abfrage haben, die Variablen beinhaltet,
vielleicht mehrere, dann wird ein Teil der Erfüllbarkeitsprüfung

00:04:00,629 --> 00:04:04,690
die Zuweisung konkreter Instanziierungen
sein, diesen Variablen zuzuordnen.

00:04:04,690 --> 00:04:08,440
Und das könnte dann als die Ausgabe
des Programms angesehen werden.

00:04:08,440 --> 00:04:11,870
Völlig anders als im Haskell-Teil, dass
das Ergebnis der Wert ist, auf den ein

00:04:11,870 --> 00:04:13,100
Ausdruck am Ende reduziert wurde.

00:04:13,100 --> 00:04:17,430
Es gibt also Unterschiede, auch das
Pattern-Matching wird ähnlich, aber anders sein.

00:04:17,430 --> 00:04:22,840
Es gibt also einen weiteren Aspekt der
Prolog-Variante von Pattern-Matching.

00:04:22,840 --> 00:04:29,810
Aber einige Ideen werden übertragbar sein, und ich
erwähnte gerade, dass die operationale Semantik

00:04:29,810 --> 00:04:36,510
einige ähnliche Aspekte hat, aber
es ist nicht genau das Gleiche.

2 # slide
00:04:36,510 --> 00:04:39,380
Okay, wir beginnen heute mit einem
Blick auf einige Prolog-Grundlagen.

00:04:39,380 --> 00:04:41,280
Ja, wir brauchen natürlich eine Einführung.

00:04:41,280 --> 00:04:44,320
Und dies wird sehr beispielorientiert sein.

00:04:44,320 --> 00:04:50,680
Und tatsächlich werden viele der Beispiele bereits heute,
bis zu einem gewissen Grad auch in späteren Vorlesungen,

00:04:50,680 --> 00:04:56,350
aber sicherlich heute, zu einem großen Teil aus
dem Buch "Learn Prolog Now", das ist eines der

00:04:56,350 --> 00:05:01,650
Bücher, die ich als Literatur für Prolog in
der allerersten Vorlesung vorgeschlagen habe.

00:05:01,650 --> 00:05:04,190
Das war also ein Buch, das online verfügbar ist.

00:05:04,190 --> 00:05:08,130
Sie müssen es also nicht kaufen, Sie
können es einfach im Web durchblättern.

00:05:08,130 --> 00:05:14,020
Und Sie werden sehen, dass viele der Beispiele,
die ich heute verwende, auch in diesem Buch

00:05:14,020 --> 00:05:15,020
zu finden sind.

00:05:15,020 --> 00:05:17,840
Ich habe einige von ihnen verändert, um einige
Punkte zu verdeutlichen, die ich machen möchte.

00:05:17,840 --> 00:05:22,190
Es sind also nicht genau die gleichen
kleinen Programme, aber sehr ähnlich.

00:05:22,190 --> 00:05:30,750
Das erklärt auch, dass Sie gleich sehen werden,
wenn Sie sich an die Popkultur erinnern,

00:05:30,750 --> 00:05:36,490
und Sie werden sehen, dass viele der
Beispiele im Buch und dann hier auf einen

00:05:36,490 --> 00:05:42,100
populären Film beziehen, den Sie vielleicht
wiedererkennen werden oder vielleicht auch nicht.

00:05:42,100 --> 00:05:43,100
Nun gut.

3 # slide
00:05:43,100 --> 00:05:47,840
Also, Prolog im einfachsten Fall.

00:05:47,840 --> 00:05:58,669
Da habe ich gerade schon Abfragen erwähnt, und auf
den ersten Blick können Prolog-Programme als eine

00:05:58,669 --> 00:06:02,900
Art von Datenbanken gesehen werden,
die einige Fakten enthalten.

00:06:02,900 --> 00:06:04,479
Und dann kann man darüber Fragen stellen.

00:06:04,479 --> 00:06:09,400
Eigentlich wird das oft auch Datenprotokoll genannt,
was eine Untermenge von Prolog ist, wo man einfach

00:06:09,400 --> 00:06:12,419
diese Art von atomaren Fakten
hat, die Sie hier sehen.

00:06:12,419 --> 00:06:17,430
Ich werde dies also auch benutzen,
um die Syntax zu erklären.

00:06:17,430 --> 00:06:21,870
Was wir hier also sehen, ist eine
Aussage wie: Mia ist eine Frau.

00:06:21,870 --> 00:06:22,870
Jody ist eine Frau.

00:06:22,870 --> 00:06:25,140
Das ist also die Art und Weise,
wie es hier ausgedrückt wird.

00:06:25,140 --> 00:06:29,040
Dies ist also ein Prädikat, eine
Eigenschaft, die eine Entität haben kann.

00:06:29,040 --> 00:06:33,660
Und die Dinge, die hier in Klammern stehen,
sind die Dinge, über die wir etwas sagen.

00:06:33,660 --> 00:06:38,790
In diesem Fall ist das also eine einzelne Person,
aber natürlich ist es letztendlich nur einfacher.

00:06:38,790 --> 00:06:43,400
Was wir also sagen, ist, dass Mia eine Frau ist,
Jody eine Frau ist, und Yolanda eine Frau ist.

00:06:43,400 --> 00:06:48,680
Und es scheint, dass Jody Luftgitarre spielt.

00:06:48,680 --> 00:06:54,750
Okay, das wäre also ein Programm, das man
in eine Datei schreiben und dann in eine

00:06:54,750 --> 00:06:56,810
Prolog-Engine laden könnte.

00:06:56,810 --> 00:07:00,240
Und dann würde die Interaktion mit
dem Programm über Abfragen erfolgen.

00:07:00,240 --> 00:07:05,640
Also, genau wie im Haskell-Interpreter, lädt
man ein Programm und gibt dann einige Ausdrücke

00:07:05,640 --> 00:07:09,610
ein und erwartet, dass diese etwas
auswerten, das dann ausgegeben wird.

00:07:09,610 --> 00:07:14,590
Hier würden Sie Ihre Faktenbasis in die Engine laden, in die
Maschine, und dann ist dies eine Eingabeaufforderung, und dann

00:07:14,590 --> 00:07:16,490
stellen Sie einige Fragen.

00:07:16,490 --> 00:07:20,539
Und Fragen sind Aussagen, die
wahr oder falsch sein können.

00:07:20,539 --> 00:07:23,320
Sie erhalten keine 15 Antworten, aber
Sie erhalten wahr oder falsch heraus.

00:07:23,320 --> 00:07:28,750
Wenn Sie also dieses Programm laden, diese Fakten,
dann können wir Dinge fragen wie: Ist Mia eine Frau?

00:07:28,750 --> 00:07:32,610
Und dann wird Prolog wahrheitsgemäß
mit Ja antworten oder True, richtig?

00:07:32,610 --> 00:07:37,320
Denn das ist etwas, das in der
Datenbank steht.

00:07:37,320 --> 00:07:42,290
Okay, wichtiger syntaktischer Aspekt hier,
wenn Sie dies im Interpreter ausprobieren.

00:07:42,290 --> 00:07:44,440
Also, dieser Punkt hier ist wirklich wichtig.

00:07:44,440 --> 00:07:46,150
Beides hier ist wirklich Teil der Syntax.

00:07:46,150 --> 00:07:50,460
Nun, hier ist es im Grunde der Punkt, an dem wir
sagen, dass diese Anweisung vollständig ist, richtig?

00:07:50,460 --> 00:07:55,000
Und diese Fakten, und auch wenn Sie eine Abfrage stellen,
dann muss man wirklich diesen Punkt hier eingeben.

00:07:55,000 --> 00:07:58,300
Das kann am Anfang manchmal verwirrend sein.

00:07:58,300 --> 00:08:05,780
Denn wenn Sie nach der Anweisung einfach Enter
drücken ohne den Punkt, dann passiert nicht das,

00:08:05,780 --> 00:08:07,130
was Sie erwarten würden.

00:08:07,130 --> 00:08:10,039
Ich meine, dass die Maschine
anfängt, diese Frage zu beantworten.

00:08:10,039 --> 00:08:12,940
Okay, das ist wirklich
etwas, das Sie tun sollten.

00:08:12,940 --> 00:08:15,190
Okay, dann lassen Sie uns ein
paar andere Fragen stellen.

00:08:15,190 --> 00:08:19,220
So können wir natürlich auch
fragen, ob Jody Luftgitarre spielt.

00:08:19,220 --> 00:08:20,820
Und die Antwort wird auch wahr sein.

00:08:20,820 --> 00:08:24,520
Einfach, weil es in den Fakten steht.

00:08:24,520 --> 00:08:28,330
Okay, dann können wir auch Fragen stellen,
die sich als falsch herausstellen.

00:08:28,330 --> 00:08:32,870
Hier fragen wir zum Beispiel, ob Mia
Gitarre spielt, und die Antwort ist falsch.

00:08:32,870 --> 00:08:39,300
Und das ist schon die erste, also wichtige
Erkenntnis vielleicht, oder etwas, dessen man

00:08:39,300 --> 00:08:40,300
sich bewusst sein sollte.

00:08:40,300 --> 00:08:44,180
Nämlich, wir haben natürlich nie gesagt,
dass Mia nicht Gitarre spielt, richtig?

00:08:44,180 --> 00:08:46,320
Wir haben gesagt, dass Jody
die Luftgitarre spielt.

00:08:46,320 --> 00:08:52,680
Die Fakten hier sagen weder, dass Mia
Luftgitarre spielt, noch sagen sie das Gegenteil.

00:08:52,680 --> 00:08:57,220
Und trotzdem wird Prolog, wenn man es fragt, ob
Mia Luftgitarre spielt, mit "falsch" antworten.

00:08:57,220 --> 00:09:01,130
Es behauptet also, dass Mia nicht Gitarre spielt,
auch wenn das hier nicht ausgedrückt wird.

00:09:01,130 --> 00:09:02,130
Was bedeutet das?

00:09:02,130 --> 00:09:06,339
Nun, es bedeutet, dass Prolog alles für
falsch hält, das nicht explizit bewiesen ist.

00:09:06,339 --> 00:09:09,080
Hier geben wir also einige Fakten an.

00:09:09,080 --> 00:09:13,930
Und die Vorstellung oder Interpretation ist, dass
diese Fakten wahr sind, und alles andere falsch ist.

00:09:13,930 --> 00:09:18,180
Wenn Sie also nach etwas fragen, das nicht
ausgedrückt oder nicht enthalten und nicht ableitbar

00:09:18,180 --> 00:09:23,490
ist, dann wird Prolog nicht nur sagen, ich weiß
es nicht, weil ich nicht beweisen kann, dass

00:09:23,490 --> 00:09:24,490
Mia Luftgitarre spielt.

00:09:24,490 --> 00:09:26,520
Prolog wird tatsächlich "falsch" sagen.

00:09:26,520 --> 00:09:31,700
Das nennt man auch Negation des Scheiterns
in dem Sinne, dass Prolog dies als

00:09:31,700 --> 00:09:35,510
nicht wahr ansieht, weil
es es nicht beweisen kann.

00:09:35,510 --> 00:09:39,830
Okay, das ist nicht unbedingt die Art und
Weise, wie mathematische Logik zu verstehen ist.

00:09:39,830 --> 00:09:44,660
Wo man sagt, wenn ich das nicht bewiesen hätte,
oder ich weiß nicht, dass Mia Luftgitarre spielt,

00:09:44,660 --> 00:09:45,950
weil es hier nicht gesagt wird.

00:09:45,950 --> 00:09:50,160
Das heißt nicht unbedingt, dass ich
weiß, dass Mia nicht Luftgitarre spielt.

00:09:50,160 --> 00:09:51,750
Aber tatsächlich hat Prolog diese Interpretation.

00:09:51,750 --> 00:09:56,770
Okay, wenn wir eine Frage haben, die durch die
Wissensbasis, die wir haben, nicht positiv beantwortet wird,

00:09:56,770 --> 00:10:04,930
dann wird die Aussage tatsächlich
als nicht wahr angesehen.

00:10:04,930 --> 00:10:07,500
Das stimmt.

00:10:07,500 --> 00:10:13,180
Das gilt auch für Situationen wie diese, wo
wir etwas über eine Person oder ein Individuum

00:10:13,180 --> 00:10:15,690
oder eine Entität fragen, die
nicht Teil des Programms ist.

00:10:15,690 --> 00:10:16,690
Richtig?

00:10:16,690 --> 00:10:19,420
Nun, bei Mia wussten wir, dass es eine Frau ist.

00:10:19,420 --> 00:10:22,100
Wir wussten nicht, dass sie Luftgitarre
spielt.

00:10:22,100 --> 00:10:24,390
Also, Prolog sagte, nun, sie
spielt keine Luftgitarre.

00:10:24,390 --> 00:10:28,260
Nun, wenn wir fragen, ob Vincent Luftgitarre
spielt, wird Prolog auch "falsch" sagen.

00:10:28,260 --> 00:10:29,270
Es wird auch "nein" sagen.

00:10:29,270 --> 00:10:32,440
Vincent spielt keine Luftgitarre, auch
wenn wir nichts über Vincent gesagt haben.

00:10:32,440 --> 00:10:33,440
Ja.

00:10:33,440 --> 00:10:39,700
Also, aus dem Prolog-Programm, das wir hier oben gesehen
haben, ist Vincent nicht einmal ein Ding, eine Person,

00:10:39,700 --> 00:10:42,120
er ist nicht einmal als Entität vorhanden.

00:10:42,120 --> 00:10:45,910
Aber trotzdem können wir fragen, ob Vincent
Luftgitarre spielt und Prolog wird "nein" sagen.

00:10:45,910 --> 00:10:47,150
Ich habe noch nie von Vincent gehört.

00:10:47,150 --> 00:10:49,190
Ich habe noch nie etwas darüber
gehört, dass er Luftgitarre spielt.

00:10:49,190 --> 00:10:51,200
Es ist also nicht wahr.

00:10:51,200 --> 00:10:56,250
Es ist sogar falsch, dass er Luftgitarre
spielt.

00:10:56,250 --> 00:10:57,450
Okay, okay.

00:10:57,450 --> 00:11:04,130
Und dann noch ein paar letzte Beispiele, ein einfaches
Beispiel. Wir könnten auch fragen, ob Jody Klavier spielt.

00:11:04,130 --> 00:11:05,980
Darüber wissen wir aber nichts, richtig?

00:11:05,980 --> 00:11:08,060
Wir wissen nur, dass Jody Luftgitarre spielt.

00:11:08,060 --> 00:11:09,930
Wir wissen nicht, dass Jody Klavier spielt.

00:11:09,930 --> 00:11:12,410
Die Antwort könnte also "false" sein.

00:11:12,410 --> 00:11:16,740
Aber eigentlich ist es in diesem Fall etwas
subtiler, weil manchmal Prolog, oder einige

00:11:16,740 --> 00:11:24,230
Prolog-Systeme bzw. Prolog-Systeme mit bestimmten
Einstellungen, in diesem Fall sogar eine Fehlermeldung ausgeben

00:11:24,230 --> 00:11:25,830
Meldung, richtig?

00:11:25,830 --> 00:11:30,600
Während Entitäten, die nicht bekannt sind oder
einfach als existent angenommen werden, aber keine der

00:11:30,600 --> 00:11:31,600
Eigenschaften erfüllen.

00:11:31,600 --> 00:11:32,600
Das ist der Punkt, an dem wir hier falsch liegen.

00:11:32,600 --> 00:11:35,170
Wenn Sie tatsächlich eine Frage
stellen, die nicht definiert ist.

00:11:35,170 --> 00:11:39,010
Es ist also nichts über jemanden
bekannt, der Klavier spielt.

00:11:39,010 --> 00:11:43,790
Wenn man also etwas fragt wie "Spielt
Jody ...", werden einige Prologsysteme

00:11:43,790 --> 00:11:49,519
annehmen, dass wir einen Tippfehler gemacht und
vielleicht hier ein falsches Prädikat geschrieben haben.

00:11:49,519 --> 00:11:53,720
Es gibt also eine nützliche Interpretation,
die besagt, nun, es ist falsch.

00:11:53,720 --> 00:11:59,420
Aber eigentlich werden sich einige Systeme eher beschweren
und sagen, wahrscheinlich meinten Sie eine andere Eigenschaft

00:11:59,420 --> 00:12:00,420
hier.

00:12:00,420 --> 00:12:09,110
Okay, das wird natürlich nicht passieren, wenn Sie nur
Prädikate, Eigenschaftsnamen verwenden, die tatsächlich

00:12:09,110 --> 00:12:15,490
in der Faktenbasis vorkommen, oder die von
Ihnen in den Aufgaben definiert wurden, wenn Sie

00:12:15,490 --> 00:12:16,740
Übungsaufgaben lösen.

00:12:16,740 --> 00:12:18,800
Okay, dann sollten Sie diese
Fehlermeldung nicht erhalten.

00:12:18,800 --> 00:12:23,060
Es sei denn, Sie haben wirklich einen Tippfehler gemacht
und ein Prädikat geschrieben, das keinen Sinn macht oder

00:12:23,060 --> 00:12:25,089
nicht verwendet werden sollte.

00:12:25,089 --> 00:12:28,580
Okay, das ist sehr einfach.

00:12:28,580 --> 00:12:32,029
Lassen Sie uns das Ganze
etwas interessanter gestalten.

4 # slide
00:12:32,029 --> 00:12:40,519
Okay, was wir hier haben, sind also nicht mehr
nur Fakten, sondern auch einige Implikationen oder

00:12:40,519 --> 00:12:41,519
Regeln, richtig?

00:12:41,519 --> 00:12:45,050
Also, die ersten beiden Zeilen sind Dinge von
einem Stil, die Sie bereits gesehen haben.

00:12:45,050 --> 00:12:48,240
Dann sagen wir so etwas wie:
Nun, Yolanda ist glücklich.

00:12:48,240 --> 00:12:51,330
Und Mia hört Musik, okay.

00:12:51,330 --> 00:12:55,480
Und dann gibt es etwas Neues hier in dieser
Zeile, und die beiden anderen Zeilen sind ähnlich.

00:12:55,480 --> 00:12:58,680
Wir haben hier nämlich dieses seltsame Symbol.

00:12:58,680 --> 00:13:02,060
Und dann haben wir links und rechts,
haben wir eine Aussage, richtig?

00:13:02,060 --> 00:13:07,320
Links steht, dass Yolanda Musik hört,
und rechts steht: Yolanda ist glücklich.

00:13:07,320 --> 00:13:10,640
Wenn Sie dies wieder als eine
Eigenschaft dieser Entität betrachten.

00:13:10,640 --> 00:13:13,860
Okay, was ist die Bedeutung des Symbols
hier?

00:13:13,860 --> 00:13:17,110
Und natürlich auch in den anderen
beiden Zeilen, dass es ein "wenn" ist.

00:13:17,110 --> 00:13:20,209
Das ist also die Regel, die wir hier haben.

00:13:20,209 --> 00:13:24,339
Die linke Seite ist der Kopf und
die rechte Seite ist der Rumpf.

00:13:24,339 --> 00:13:26,250
Ja, viele regelbasierte Einstellungen.

00:13:26,250 --> 00:13:30,710
Die Idee ist also, dass der Kopf,
der durch den Rumpf impliziert wird.

00:13:30,710 --> 00:13:32,579
Wie ist das also zu verstehen?

00:13:32,579 --> 00:13:37,560
Wenn Yolanda glücklich ist, dann hört sie
Musik.

00:13:37,560 --> 00:13:39,240
Das ist eine Adaption dieser Regel.

00:13:39,240 --> 00:13:44,240
Und ebenso, wenn Mia Musik hört,
dann spielt Mia Luftgitarre.

00:13:44,240 --> 00:13:48,620
Wenn Yolanda Musik hört, dann
spielt Yolanda Luftgitarre.

00:13:48,620 --> 00:13:55,209
Okay, das sind also zwei Fakten und diese drei
Regeln, und sie können verwendet werden, um logische

00:13:55,209 --> 00:13:56,209
Schlüsse zu ziehen.

00:13:56,209 --> 00:14:01,180
Jetzt können wir also Fragen stellen, die nicht explizit
beantwortet werden können, indem man sich Fakten ansieht,

00:14:01,180 --> 00:14:06,050
sondern wo Prolog tatsächlich
die bekannten Fakten nutzt.

00:14:06,050 --> 00:14:09,910
Plus einige Aussagen,
Implikationen, einige Regeln.

00:14:09,910 --> 00:14:16,050
Okay, in diesem Beispiel, wo man zum Beispiel
fragen kann, ob Mia Luftgitarre spielt.

00:14:16,050 --> 00:14:20,060
Und obwohl es keinen Fakt gibt, der das tatsächlich
besagt, wird Prolog trotzdem "true" sagen.

00:14:20,060 --> 00:14:21,230
Und wie kommt das?

00:14:21,230 --> 00:14:27,350
Nun, weil Prolog weiß, dass Mia
Musik hört, das war ein Faktum.

00:14:27,350 --> 00:14:31,380
Und dann gibt es noch die Regel, dass, wenn
Mia Musik hört, dann spielt Mia Luftgitarre.

00:14:31,380 --> 00:14:35,680
Also wird Prolog dies aus dem ableiten, was
wir wissen aus den Fakten und den Regeln.

00:14:35,680 --> 00:14:38,760
In der Tat, ja, Mia spielt Luftgitarre.

00:14:38,760 --> 00:14:40,700
Okay, was ist mit Yolanda?

00:14:40,700 --> 00:14:44,920
Wir können auch fragen, ob
Yolanda Luftgitarre spielt.

00:14:44,920 --> 00:14:50,470
Und wenn man das hier ausarbeitet, dann wird man
finden, dass Prolog mit der Antwort true richtig liegt.

00:14:50,470 --> 00:14:55,459
Es ist also eigentlich eine
zweistufige Argumentation.

00:14:55,459 --> 00:15:00,530
Es ist nämlich nicht so einfach wie bei
Mia, wo wir haben, wenn sie Musik hört, dann

00:15:00,530 --> 00:15:01,750
spielt sie Luftgitarre.

00:15:01,750 --> 00:15:07,079
Bei Yolanda müssten wir eigentlich wissen,
dass sie Musik hört, um festzustellen, dass

00:15:07,079 --> 00:15:09,250
sie Luftgitarre spielt.

00:15:09,250 --> 00:15:12,640
Aber die Tatsache, dass Yolanda Musik
hört, ist an sich keine Tatsache.

00:15:12,640 --> 00:15:15,130
Es ist auch etwas, das sich
nur aus der Regel ergibt.

00:15:15,130 --> 00:15:20,149
Wir wissen nämlich, dass Yolanda Musik hört, wenn
sie glücklich ist, und wir wissen auch, dass sie

00:15:20,149 --> 00:15:21,149
glücklich ist.

00:15:21,149 --> 00:15:25,380
Also wird Prolog das Wissen maximal
ausnutzen und wirklich ausrechnen,

00:15:25,380 --> 00:15:29,459
dass Yolanda in diesem Fall
tatsächlich Luftgitarre spielt.

00:15:29,459 --> 00:15:35,300
Da Yolanda aufgrund dieser Erkenntnis glücklich
ist, hört sie aufgrund dieser Tatsache Musik,

00:15:35,300 --> 00:15:37,110
auf der Grundlage dieser Regel, richtig?

00:15:37,110 --> 00:15:38,790
Natürlich ist das jetzt eine
vorwärts gerichtete Argumentation.

00:15:38,790 --> 00:15:40,740
Hier hingegen sind die
Regeln rückwärts geschrieben.

00:15:40,740 --> 00:15:43,720
Das ist der Fall, wenn das der Fall ist.

00:15:43,720 --> 00:15:50,209
Also, dass Yolanda Musik hört, impliziert, dass Yolanda,
und nach der letzten Regel bedeutet dies wiederum,

00:15:50,209 --> 00:15:52,199
dass Yolanda Luftgitarre spielt.

00:15:52,199 --> 00:15:53,639
Also ist die Antwort hier wahr.

00:15:53,639 --> 00:15:55,540
Und natürlich sehen wir diese
Argumentation nicht hier.

00:15:55,540 --> 00:16:00,980
Zumindest nicht in diesem Modus hier. Es gibt einige
Debug-Funktionen, mit denen man herausfinden kann,

00:16:00,980 --> 00:16:03,899
wie Prolog zu dieser
Schlussfolgerung gekommen ist.

00:16:03,899 --> 00:16:08,519
Aber eigentlich ist das nicht sichtbar
und der Interpreter genau wie in Haskell.

00:16:08,519 --> 00:16:09,990
Wenn man einen Ausdruck eingibt,
bekommt man das Ergebnis.

00:16:09,990 --> 00:16:14,050
Sie erhalten nicht die schrittweise Auswertung
dieses Ergebnisses, zumindest nicht standardmäßig.

00:16:14,050 --> 00:16:20,070
Okay, hier stellen wir also eine Frage, und Prolog gibt
eine Antwort basierend auf einigen Überlegungen und einem

00:16:20,070 --> 00:16:23,600
Testlauf im Hintergrund.

00:16:23,600 --> 00:16:24,600
Okay.

00:16:24,600 --> 00:16:27,440
Also, es gibt eine neue Syntax.

5 # slide
00:16:27,440 --> 00:16:30,270
Schauen wir uns noch
komplexere Regeln an, richtig?

00:16:30,270 --> 00:16:32,029
Dies sind sehr einfache Regeln.

00:16:32,029 --> 00:16:38,150
Einige Fakten und dann, wenn dies, dann das.
Also eine Aussage impliziert eine andere Aussage.

00:16:38,150 --> 00:16:42,850
Aus der Logik wissen Sie, dass man natürlich auch kompliziertere
Implikationen haben kann, bei denen man vielleicht

00:16:42,850 --> 00:16:47,140
mehrere Aussagen kombinieren
muss, um eine andere abzuleiten.

00:16:47,140 --> 00:16:50,380
In Prolog wäre das also so etwas wie
auch so.

00:16:50,380 --> 00:16:55,440
Ansonsten könnte es nur sehr einfache
Programme und Regeln schreiben.

00:16:55,440 --> 00:16:57,730
Schauen wir uns nun einige komplexere Regeln an.

00:16:57,730 --> 00:17:04,449
Und es gibt im Grunde zwei Dinge,
die auf dieser Folie relevant sind.

00:17:04,449 --> 00:17:08,439
Die erste Sache ist, dass wir auf der rechten
Seite mehrere Anweisungen haben können, richtig?

00:17:08,439 --> 00:17:11,089
Hier sind wieder zwei sehr einfache Fakten.

00:17:11,089 --> 00:17:13,199
Vincent ist glücklich und Butch hört Musik.

00:17:13,199 --> 00:17:18,120
Und dann haben wir diese Regel, die besagt,
Vincent spielt die Luftgitarre, wenn, na ja, was

00:17:18,120 --> 00:17:19,120
wenn?

00:17:19,120 --> 00:17:22,589
Nun, wenn zwei Dinge
offensichtlich wahr sind, richtig?

00:17:22,589 --> 00:17:25,890
Also ist dieses Komma hier in der Tat
einfach die Interpretation von "und".

00:17:25,890 --> 00:17:28,659
Sie können hier also eine
Liste von Dingen hinzufügen.

00:17:28,659 --> 00:17:32,559
Und dann ist die logische Interpretation,
dass alle diese Dinge wahr sein müssen,

00:17:32,559 --> 00:17:33,720
um diese Regeln anwenden zu können.

00:17:33,720 --> 00:17:34,720
Im Grunde ist es das Gleiche.

00:17:34,720 --> 00:17:37,929
Vincent spielt die Luftgitarre, wenn
dies der Fall ist und dies der Fall ist.

00:17:37,929 --> 00:17:41,080
Also, das Komma ist das "und".

00:17:41,080 --> 00:17:43,740
Dort schreiben wir nicht "und",
wir benutzen einfach das Komma.

00:17:43,740 --> 00:17:48,980
Okay, dann können wir fragen,
ob Vincent Luftgitarre spielt.

00:17:48,980 --> 00:17:51,580
Und ob das der Fall sein wird, schauen wir mal.

00:17:51,580 --> 00:17:56,600
Nun, die einzige Möglichkeit, das festzustellen,
wäre durch diese Regel, und dann müsste es

00:17:56,600 --> 00:17:59,999
der Fall sein, dass Vincent Musik hört.

00:17:59,999 --> 00:18:01,389
Und Vincent ist glücklich.

00:18:01,389 --> 00:18:02,929
Eines von beidem ist wahr.

00:18:02,929 --> 00:18:03,929
Vincent ist tatsächlich glücklich.

00:18:03,929 --> 00:18:06,919
Aber wir wissen nichts darüber,
dass Vincent Musik hört.

00:18:06,919 --> 00:18:10,460
Denn die einzige Tatsache bezieht
sich auf Butch, nicht auf Vincent.

00:18:10,460 --> 00:18:14,999
Es gibt auch keine Regeln, die festlegen
würden, die besagen, dass er Musik hören könnte.

00:18:14,999 --> 00:18:17,639
Wir wissen also nicht, dass dies wahr ist.

00:18:17,639 --> 00:18:22,330
Und Prolog nimmt an, dass es falsch ist, wobei
die Argumentation oder die erwähnte Interpretation

00:18:22,330 --> 00:18:23,360
vorher.

00:18:23,360 --> 00:18:25,870
Und dann ist es nicht der Fall,
dass diese beiden Dinge wahr sind.

00:18:25,870 --> 00:18:30,360
Also, wir können nicht folgern, dass Vincent Luftgitarre
spielt und wenn Prolog nicht ableiten kann, dass Vincent

00:18:30,360 --> 00:18:33,519
Luftgitarre spielt, dann nimmt
Prolog an, dass er es nicht tut.

00:18:33,519 --> 00:18:35,200
Okay, die Antwort ist hier falsch.

00:18:35,200 --> 00:18:37,230
Weil wir diese Regel nicht anwenden können.

00:18:37,230 --> 00:18:39,860
Weil wir nicht alle Vorbedingungen kennen.

00:18:39,860 --> 00:18:42,380
Okay, was ist mit Butch?

00:18:42,380 --> 00:18:46,999
Nun, es gibt zwei Regeln über Butch.

00:18:46,999 --> 00:18:49,929
Wie soll das interpretiert werden?

00:18:49,929 --> 00:18:55,710
Vielleicht können wir auch nicht feststellen, dass
Butch unsere Gitarre spielt, weil wir nicht wissen,

00:18:55,710 --> 00:18:56,909
ob er glücklich ist.

00:18:56,909 --> 00:18:57,909
Das stimmt.

00:18:57,909 --> 00:19:01,429
Wir wissen das über Vincent,
aber nicht über Butch.

00:19:01,429 --> 00:19:08,249
Aber es gibt eine andere Regel, die besagt: Wenn
Butch Musik hört, dann spielt er Luftgitarre.

00:19:08,249 --> 00:19:11,479
Und wir wissen tatsächlich,
dass Butch Musik hört.

00:19:11,479 --> 00:19:16,649
Okay, also wird dies tatsächlich als
wahr bewertet oder als wahr abgeleitet.

00:19:16,649 --> 00:19:18,320
Dies ist also eine Aussage, die wahr ist.

00:19:18,320 --> 00:19:19,320
Und warum?

00:19:19,320 --> 00:19:21,950
Weil wir diese zwei Regeln haben, und Prolog kann
sich entscheiden, eine von beiden zu verwenden.

00:19:21,950 --> 00:19:25,820
Und wenn Prolog sich dafür entscheidet, dies zu
verwenden, oder tatsächlich wird es beides ausprobieren.

00:19:25,820 --> 00:19:30,580
Und bei der ersten wird es keinen Erfolg
haben, weil es kein Wissen über Butch gibt, der

00:19:30,580 --> 00:19:31,580
glücklich ist.

00:19:31,580 --> 00:19:35,999
Aber da es die zweite Regel gab, und hier können
wir sehen, dass die Vorbedingung wahr ist, weil

00:19:35,999 --> 00:19:41,049
von dieser Tatsache wird Prolog tatsächlich ableiten und
es ist richtig zu sagen, nun, in der Tat, Butch spielt

00:19:41,049 --> 00:19:42,429
Luftgitarre.

00:19:42,429 --> 00:19:47,519
Wenn Sie also etwas wie diese beiden Regeln haben, die
den gleichen Kopf haben, dann ist das eine Alternative.

00:19:47,519 --> 00:19:48,690
Es ist wie ein Oder.

00:19:48,690 --> 00:19:49,690
Oder?

00:19:49,690 --> 00:19:51,250
Das Komma hier bedeutet "und".

00:19:51,250 --> 00:19:53,649
Diese beiden Dinge müssen wahr
sein, damit dies wahr ist.

00:19:53,649 --> 00:19:55,809
Hier haben wir, wenn dies
wahr ist, dann ist dies wahr.

00:19:55,809 --> 00:19:58,999
Wenn dies wahr ist, oder dies wahr ist, was dasselbe
ist wie zu sagen, dass, wenn eines von diesen

00:19:58,999 --> 00:20:01,340
wahr ist, dann haben wir dies, richtig?

00:20:01,340 --> 00:20:06,429
Wir müssen also nicht beides nachweisen,
wir können eines feststellen.

00:20:06,429 --> 00:20:07,880
Und dann können wir ableiten, was wir wollen.

00:20:07,880 --> 00:20:09,539
So ist das hier gelaufen.

00:20:09,539 --> 00:20:12,470
In der Tat gibt es eine alternative Schreibweise.

00:20:12,470 --> 00:20:14,809
In der dies deutlicher gemacht wird.

00:20:14,809 --> 00:20:20,309
Wir könnten also diese beiden Regeln zu einer
kombinieren, eine mit dem gemeinsamen Kopf.

00:20:20,309 --> 00:20:23,600
Und im Rumpf würden wir diese beiden
Regeln mit einem Semikolon verbinden.

00:20:23,600 --> 00:20:26,289
Das Komma wird also als "und" verwendet.

00:20:26,289 --> 00:20:29,220
Und wir könnten das Semikolon als ein
"oder" auf der rechten Seite verwenden.

00:20:29,220 --> 00:20:34,519
Aber das ist gleichbedeutend mit diesen beiden
Regeln oder mit dieser Regel. Aber in der Praxis,

00:20:34,519 --> 00:20:43,029
und auch in den Beispielen in diesem Kurs, zumindest
von meiner Seite aus, werde ich das Komma für

00:20:43,029 --> 00:20:46,869
das "und" verwenden, um mehrere Dinge auf
der rechten Seite einer Regel zu verknüpfen.

00:20:46,869 --> 00:20:48,299
Aber das Semikolon werde ich
normalerweise nicht verwenden.

00:20:48,299 --> 00:20:53,350
Wenn ich also etwas wie dieses habe, würde ich lieber
zwei Regeln schreiben, die unabhängig voneinander sind,

00:20:53,350 --> 00:20:58,289
und jede von ihnen legt etwas fest
unter einer der Vorbedingungen.

00:20:58,289 --> 00:21:01,490
Und ich würde sie nicht in eine
einzige Regel mit dem Semikolon.

00:21:01,490 --> 00:21:04,970
Zum Teil, weil es für Anfänger leicht ist, das
Komma und das Semikolon zu verwechseln, oder?

00:21:04,970 --> 00:21:08,960
Wenn Sie also diese beiden Regeln sehen, ist eine mit
Komma und eine mit Semikolon, erkennen Sie vielleicht

00:21:08,960 --> 00:21:14,429
nicht sofort den sehr wichtigen logischen
Unterschied, denn diese beiden Regeln machen deutlich,

00:21:14,429 --> 00:21:22,989
dass eine dieser beiden Aussagen verwendet werden
kann, um den Kopf hier zu bilden, den gemeinsamen

00:21:22,989 --> 00:21:23,989
Kopf.

00:21:23,989 --> 00:21:24,989
Okay, es ist wahrscheinlich
besser, es so zu schreiben.

00:21:24,989 --> 00:21:31,440
Aber ich werde es so schreiben,
in allen oder fast allen Fällen.

00:21:31,440 --> 00:21:43,649
Okay, das waren jetzt komplexere Regeln mit logischen
Konnektiven oder äquivalenten Beschreibungen

00:21:43,649 --> 00:21:46,979
zu einem logischen Oder in diesem Fall.

00:21:46,979 --> 00:21:51,990
Okay, was können wir noch
interessanter machen an den Beispielen?

00:21:51,990 --> 00:21:57,039
Nun, diese Aussagen sind alle in gewisser
Weise langweilig, da sie immer nur etwas

00:21:57,039 --> 00:21:58,879
über eine Person aussagen, richtig?

00:21:58,879 --> 00:21:59,879
Vincent ist glücklich.

00:21:59,879 --> 00:22:00,950
Butch hört Musik, und so weiter.

00:22:00,950 --> 00:22:05,999
Wenn wir komplexe Regeln haben, die mehrere Aussagen
kombinieren, aber sie beziehen sich immer auf eine Person

00:22:05,999 --> 00:22:07,019
oder ein Individuum.

00:22:07,019 --> 00:22:10,159
Wir haben keine Aussagen,
die sich darauf beziehen.

00:22:10,159 --> 00:22:13,950
Bis jetzt haben wir keine Aussagen, die
sich auf mehrere Entitäten beziehen.

00:22:13,950 --> 00:22:14,950
Das stimmt.

00:22:14,950 --> 00:22:17,440
Das ist etwas, das wir auf
jeden Fall ändern sollten.

00:22:17,440 --> 00:22:22,389
Und in der Tat, die Art und Weise, dies zu
tun, ist, dass man grundsätzlich Beziehungen.

00:22:22,389 --> 00:22:26,039
Logische Programmierung wird also manchmal auch als
relationale Programmierung genannt, denn im Grunde

00:22:26,039 --> 00:22:34,999
im allgemeinen Fall sprechen wir über Beziehungen zwischen
Entitäten, genau wie in der Prädikatenlogik, wo man

00:22:34,999 --> 00:22:38,769
zwei Prädikate wie dieses hat.

00:22:38,769 --> 00:22:41,649
Eine Beziehung als semantische Interpretation.

00:22:41,649 --> 00:22:42,809
Wie wird das syntaktisch behandelt?

00:22:42,809 --> 00:22:46,649
Nun, wir würden Aussagen haben, die
sich auf mehr als eine Person beziehen.

00:22:46,649 --> 00:22:51,899
Im Grunde können wir also in den Klammern
hier mehr als eine Person auflisten.

6 # slide
00:22:51,899 --> 00:22:54,639
Okay, das ist in diesem Programm passiert.

00:22:54,639 --> 00:22:56,720
Was haben wir hier zum Beispiel?

00:22:56,720 --> 00:23:01,019
Wir haben einige grundlegende Fakten über
die eine Person jede Person, richtig?

00:23:01,019 --> 00:23:02,830
Mia ist eine Frau, Jody, Yolanda ist eine Frau.

00:23:02,830 --> 00:23:05,359
Das sind Fakten, die wir schon gesehen haben.

00:23:05,359 --> 00:23:11,119
Aber dann können wir auch Prädikatsaussagen
haben, die sich auf zwei Individuen beziehen.

00:23:11,119 --> 00:23:15,580
Also, hier ist die
Interpretation: Vincent liebt Mia.

00:23:15,580 --> 00:23:17,059
Marsellus liebt Mia.

00:23:17,059 --> 00:23:18,059
Mia liebt Vincent.

00:23:18,059 --> 00:23:22,119
Und Vincent ist selbstverliebt.

00:23:22,119 --> 00:23:27,830
Okay, auf diese Weise weiß man
jetzt, um welchen Film es geht. (?)

00:23:27,830 --> 00:23:29,690
Ja, gut.

00:23:29,690 --> 00:23:39,200
Also, in der Position hier von etwas wie das
ist in diesem Fall eine Relation oder ein

00:23:39,200 --> 00:23:40,340
binäres Prädikat.

00:23:40,340 --> 00:23:46,109
Da es sich um unäre Prädikate handelt, sagt im
Grunde die Interpretation etwas aus, das sind

00:23:46,109 --> 00:23:48,840
die Frauen, diese drei.

00:23:48,840 --> 00:23:55,230
Hier haben wir eine Relation im binären Prädikat,
die immer zwei Entitäten in Beziehung setzt.

00:23:55,230 --> 00:23:59,080
Okay, welche Art von Abfragen
kann man dazu stellen?

00:23:59,080 --> 00:24:03,470
Nun, man könnte natürlich Fragen
stellen wie: Liebt Marsellus Mia?

00:24:03,470 --> 00:24:04,649
Und die Antwort wäre wahr.

00:24:04,649 --> 00:24:07,999
Wir könnten fragen: Liebt
Marsellus oder liebt Mia Marsellus?

00:24:07,999 --> 00:24:09,429
Und die Antwort wäre falsch.

00:24:09,429 --> 00:24:11,320
Denn es gibt hier keine Aussage.

00:24:11,320 --> 00:24:16,379
Die Interpretation würde also wieder lauten, wenn
eine Beziehung im Programm nicht ausgedrückt wird,

00:24:16,379 --> 00:24:19,580
dann ist es nicht der Fall.

00:24:19,580 --> 00:24:23,739
Okay, jetzt ist die Überschrift
hier komplexer: Abfrage.

00:24:23,739 --> 00:24:29,549
Wir wollen also mehr tun als nur wieder über das
Stellen grundlegender Fragen direkt aus diesen

00:24:29,549 --> 00:24:30,549
Fakten.

00:24:30,549 --> 00:24:33,049
Lassen Sie uns also eine
Abfrage wie diese verwenden.

00:24:33,049 --> 00:24:36,869
Wir können also Abfragen stellen,
bei denen wir Variablen haben.

00:24:36,869 --> 00:24:42,390
Und hier sehen Sie schon den vielleicht
unglücklichen Unterschied zu Haskell.

00:24:42,390 --> 00:24:47,009
Es ist nicht unglücklich im Allgemeinen, aber natürlich,
in diesem Kurs ist es manchmal etwas verwirrend,

00:24:47,009 --> 00:24:54,969
dass die Rollen von Klein- und Großschreibung,
Bezeichnern grundsätzlich zwischen Haskell und

00:24:54,969 --> 00:24:55,969
Prolog, richtig?

00:24:55,969 --> 00:24:58,419
In Haskell würden Variablen
also immer kleingeschrieben.

00:24:58,419 --> 00:25:04,749
Während in Prolog die Konvention ist,
dass Großbuchstaben Variablen sind.

00:25:04,749 --> 00:25:07,210
Okay, was soll das also heißen?

00:25:07,210 --> 00:25:11,769
Es ist eine Abfrage, bei der wir nicht fragen, ist Mia
eine Frau oder ist Jody oder ist Vincent eine Frau?

00:25:11,769 --> 00:25:19,289
Sondern wir fragen, ob X eine Frau ist, wobei die Frage
im Grunde bedeutet, gibt es ein X, das eine Frau ist?

00:25:19,289 --> 00:25:21,330
Was sollte Prolog in diesem Fall antworten?

00:25:21,330 --> 00:25:24,690
Nun, man könnte sagen, es
sollte mit "Ja" antworten.

00:25:24,690 --> 00:25:27,269
Denn wir haben Entitäten, die Frauen sind.

00:25:27,269 --> 00:25:30,940
Aber dann würden wir nicht so viel
lernen wie tatsächlich, was die X sind.

00:25:30,940 --> 00:25:31,940
Richtig?

00:25:31,940 --> 00:25:35,979
Also, was Prolog in einer Abfrage wie dieser macht,
mit Variablen, es sagt nicht nur "wahr" oder "falsch"

00:25:35,979 --> 00:25:38,369
wie in all den vorherigen Beispielen,
in denen wir keine Variablen hatten.

00:25:38,369 --> 00:25:42,669
Wenn man eine Abfrage mit Variablen hätte, dann
würde Prolog vielleicht auch "falsch" sagen.

00:25:42,669 --> 00:25:46,840
Wenn es einfach keine Möglichkeit
gibt, wie die Aussage hier.

00:25:46,840 --> 00:25:53,259
Aber wenn es eine gibt, dann wird Prolog nicht einfach "wahr"
sagen, es wird uns tatsächlich sagen, für welches X es wahr

00:25:53,259 --> 00:25:54,259
ist.

00:25:54,259 --> 00:26:00,059
Wenn wir also diese Anfrage an Prolog
stellen, wird es etwas wie "X ist Mia" sagen.

00:26:00,059 --> 00:26:02,179
Es sagt also nicht nur "wahr".

00:26:02,179 --> 00:26:06,489
Es sagt tatsächlich, dass X gerade Mia ist.
Und die Bedeutung ist: Ja, es ist wahr,

00:26:06,489 --> 00:26:08,580
für den Fall, dass X Mia ist.

00:26:08,580 --> 00:26:12,269
Auch hier sehen Sie bereits das Semikolon.
Es ist eigentlich nicht etwas, das Prolog

00:26:12,269 --> 00:26:13,269
ausgeben würde.

00:26:13,269 --> 00:26:15,799
Prolog würde dies so ausgeben: X ist
Mia,

00:26:15,799 --> 00:26:20,070
und dann wäre es die Aufgabe des
Benutzers, entweder dies zu akzeptieren

00:26:20,070 --> 00:26:22,080
(und einen Punkt einzugeben und damit
zu sagen: okay, das ist in Ordnung;

00:26:22,080 --> 00:26:28,440
also würde man den Punkt benutzen, um tatsächlich zu sagen,
gut), oder Sie könnten mit einem Semikolon antworten.

00:26:28,440 --> 00:26:33,860
Und denken Sie daran, das Semikolon entspricht in
der Prolog-Interpretation der Logik einem "oder".

00:26:33,860 --> 00:26:40,969
Im Grunde genommen bedeutet es also, dass, wenn der
Benutzer dies eingibt, dann würden Sie Prolog bitten

00:26:40,969 --> 00:26:45,100
(nachdem Prolog Ihnen gesagt hat,
dass X gleich Mia eine Frau ist),

00:26:45,100 --> 00:26:49,649
dann könnten Sie fragen: "Oder", im Sinne von:
"Oder gibt es vielleicht auch ein anderes X?"

00:26:49,649 --> 00:26:50,649
Ja.

00:26:50,649 --> 00:26:55,559
Also, wenn man das Semikolon eingibt, dann würde Prolog
sagen: "Na ja, vielleicht gefällt dir meine Lösung nicht,

00:26:55,559 --> 00:26:56,559
dass X Mia ist.

00:26:56,559 --> 00:26:57,559
Du fragst: 'oder'.

00:26:57,559 --> 00:26:58,999
Nun, dann sage ich dir eine andere Möglichkeit."

00:26:58,999 --> 00:27:03,659
Also, Prolog würde sagen, nun, Jody ist auch
eine Frau, denn das ist auch etwas, das

00:27:03,659 --> 00:27:06,210
aus der Faktenbasis folgt.

00:27:06,210 --> 00:27:13,219
Okay, und dann könnte man wieder ein Semikolon
eingeben, und dann würde Prolog mit der letzten Option

00:27:13,219 --> 00:27:16,120
antworten, nämlich dass X
auch Yolanda sein könnte.

00:27:16,120 --> 00:27:20,469
Wiederum wird Prolog tatsächlich herausgefunden
haben, dass dies genau drei Möglichkeiten sind, die

00:27:20,469 --> 00:27:21,669
diese Aussage wahr machen.

00:27:21,669 --> 00:27:23,929
Es gibt also keine weiteren Optionen.

00:27:23,929 --> 00:27:25,039
Okay, warum?

00:27:25,039 --> 00:27:30,440
Wiederum, weil, wenn etwas nicht gesetzt ist oder
aus dem Wissen ableitbar ist, dann ist es nicht

00:27:30,440 --> 00:27:31,440
wahr.

00:27:31,440 --> 00:27:36,129
Wenn Sie also fragen, was sind die Frauen, dann wird
Prolog genau diese drei anbieten und keine weiteren

00:27:36,129 --> 00:27:37,129
welche.

00:27:37,129 --> 00:27:42,489
Denn es gibt keine zusätzlichen Informationen, dass
irgendjemand anderes zu diesem Prädikat passen würde.

00:27:42,489 --> 00:27:44,999
Okay, das ist also schön.

00:27:44,999 --> 00:27:48,789
Man kann solche Fragen stellen, bei denen
es noch nicht diese binären Prädikate gibt.

00:27:48,789 --> 00:27:53,979
Aber wir können natürlich jetzt mit Variablen auch
Fragen stellen, die dieses Prädikat beinhalten.

00:27:53,979 --> 00:28:00,789
Zum Beispiel können wir gemischte Fragen stellen, bei denen
einige Stellen der Prädikate tatsächlich konkrete Entitäten

00:28:00,789 --> 00:28:04,259
sind und andere Variablen sind.

00:28:04,259 --> 00:28:10,840
So können wir zum Beispiel fragen, ob es
wahr ist, dass Vincent jemanden liebt?

00:28:10,840 --> 00:28:12,399
Das geht.

00:28:12,399 --> 00:28:14,099
Und was wären dann die Antworten?

00:28:14,099 --> 00:28:16,809
Nun, die Antwort könnte wahr sein.

00:28:16,809 --> 00:28:20,919
Denn in der Tat ist es der Fall, dass Vincent
jemanden liebt, aber eigentlich, nochmal, Prolog

00:28:20,919 --> 00:28:22,339
nicht einfach "true" sagt.

00:28:22,339 --> 00:28:24,679
Es würde uns sagen, wen Vincent liebt.

00:28:24,679 --> 00:28:28,989
Die Antwort würde also
lauten: Nun, Mia, sicherlich.

00:28:28,989 --> 00:28:32,169
Und wiederum, wenn Sie nach
"Nun, was noch?" fragen würden.

00:28:32,169 --> 00:28:39,729
Dann würde Prolog auch das beantworten, in der Tat,
auch, dass X gleich Vincent eine vernünftige Antwort ist.

00:28:39,729 --> 00:28:46,070
Okay, und dann könnte man sogar noch weitergehen und
fragen: Nun, vielleicht will man mehr wissen, oder

00:28:46,070 --> 00:28:47,719
diese beiden Abfragen kombinieren.

00:28:47,719 --> 00:28:53,299
Vielleicht wollen Sie fragen, ob es jemanden gibt,
der eine Frau ist und der von Vincent geliebt wird?

00:28:53,299 --> 00:28:54,299
Ja.

00:28:54,299 --> 00:29:00,440
Auch, natürlich, ohne diese
letzte, oder diese Antwort hier.

00:29:00,440 --> 00:29:05,489
Und das kann man auch in der Abfrage machen,
indem man unsere Konnektive verwendet.

00:29:05,489 --> 00:29:10,369
Auf der vorigen Folie habe ich also ein
Komma auf der rechten Seite der Regel

00:29:10,369 --> 00:29:12,070
um auszudrücken, dass etwas wahr sein muss.

00:29:12,070 --> 00:29:13,350
Und etwas anderes muss auch wahr sein.

00:29:13,350 --> 00:29:15,080
Und das kann ich auch in einer Abfrage tun.

00:29:15,080 --> 00:29:18,879
Die Abfrage muss also nicht nur ein
Prädikat mit einigen Argumenten enthalten.

00:29:18,879 --> 00:29:20,360
Eine Abfrage könnte auch so aussehen.

00:29:20,360 --> 00:29:22,929
So, und das Komma ist wieder ein Und.

00:29:22,929 --> 00:29:26,750
Ich stelle hier also diese zwei
Fragen auf einmal gleichzeitig.

00:29:26,750 --> 00:29:31,559
Und natürlich auch gleichzeitig in dem Sinne,
dass ich hier das gleiche X verwenden möchte.

00:29:31,559 --> 00:29:36,100
Also erhalte ich nicht alle
Kombinationen, die hier möglich sind.

00:29:36,100 --> 00:29:42,690
Ich erhalte also Kombinationen, in denen Vincent
ein X liebt und dieses bestimmte X eine Frau ist.

00:29:42,690 --> 00:29:46,239
Und das kann man natürlich auch schon sehen,
entweder aus dem Programm oder aus den

00:29:46,239 --> 00:29:47,239
Lösungen hier.

00:29:47,239 --> 00:29:51,580
Die Antwort sollte jetzt nur noch Mia sein.

00:29:51,580 --> 00:29:56,239
Was hier passieren könnte, ist nicht unbedingt
der Fall in allen Prolog-Implementierungen.

00:29:56,239 --> 00:30:00,690
Aber gut, wir wissen natürlich, dass
Mia die einzige Antwort hier ist.

00:30:00,690 --> 00:30:04,929
Also hätte Prolog hier auch einen Punkt
setzen können und damit fertig sein.

00:30:04,929 --> 00:30:11,379
Aber eigentlich, aufgrund der internen Art und Weise,
wie dieses logische Lösen organisiert ist, wird es oft

00:30:11,379 --> 00:30:15,109
der Fall sein, dass Prolog an dieser Stelle
tatsächlich noch mögliche Alternativen anbietet.

00:30:15,109 --> 00:30:19,039
Also, der Benutzer würde sagen, na ja, es ist ein
Doppelpunkt, oder so, gibt es vielleicht eine andere Lösung.

00:30:19,039 --> 00:30:20,980
Und erst dann wird Prolog sagen, falsch.

00:30:20,980 --> 00:30:25,029
Wobei es äquivalent ist zu
sagen, X ist Mia oder falsch.

00:30:25,029 --> 00:30:27,549
Und wo etwas oder falsch genau das ist,
etwas.

00:30:27,549 --> 00:30:32,219
Es ist also äquivalent zu sagen, dass
X gleich Mia die einzige Lösung ist.

00:30:32,219 --> 00:30:40,690
Okay, das macht absolut Sinn, denn das
folgt genau aus dem, was wir hier hatten.

00:30:40,690 --> 00:30:44,960
Okay, das ist schon ein
schönes, interessantes Beispiel.

00:30:44,960 --> 00:30:49,750
Okay, was können wir uns noch von
einer Programmiersprache erhoffen?

00:30:49,750 --> 00:30:56,259
Nun, vielleicht wollen wir Variablen nicht nur
in Abfragen, sondern auch im Programm nutzen.

00:30:56,259 --> 00:30:57,259
Oder?

00:30:57,259 --> 00:31:03,129
Es ist schließlich langweilig im Programm, in
Faktenbasen, immer nur Grundaussagen haben.

00:31:03,129 --> 00:31:05,129
Mit festen Individuen, richtig?

00:31:05,129 --> 00:31:06,889
So, das hatten wir bisher.

00:31:06,889 --> 00:31:10,849
Wir hatten unäre Prädikate, binäre Prädikate,
wir haben Regeln, wir haben etwas auf

00:31:10,849 --> 00:31:13,129
der rechten Seite, aber
es war immer sehr konkret.

00:31:13,129 --> 00:31:15,409
Sie haben immer etwas Bestimmtes erwähnt.

00:31:15,409 --> 00:31:23,340
Nun, in diesem Fall, Personen, sonst einfach
Entitäten, Atome in unseren Aussagen.

00:31:23,340 --> 00:31:25,499
Und jetzt haben wir Variablen
in Abfragen verwendet.

00:31:25,499 --> 00:31:32,129
Natürlich wollen Sie auch Variablen in Regeln
verwenden, und das ist durchaus möglich.

00:31:32,129 --> 00:31:37,750
Und ein Beispiel dafür wäre wie folgt.

7 # slide
00:31:37,750 --> 00:31:40,320
Okay, was haben wir hier?

00:31:40,320 --> 00:31:42,950
Nun, jetzt werden die
Anweisungen noch interessanter.

00:31:42,950 --> 00:31:49,860
Also, wir haben wieder einige grundlegende Fakten
über diese binäre Beziehung über Liebesbeziehungen.

00:31:49,860 --> 00:31:51,080
Also, Vincent liebt Mia.

00:31:51,080 --> 00:31:52,080
Marsellus liebt Mia.

00:31:52,080 --> 00:31:53,999
Und Mia liebt Vincent.

00:31:53,999 --> 00:31:56,979
Okay, gut für ihn.

00:31:56,979 --> 00:32:00,729
Vielleicht abhängig von den
Eigenschaften von Mia, natürlich.

00:32:00,729 --> 00:32:02,209
Sie ist etwas verrückt.

00:32:02,209 --> 00:32:05,780
Wenn man den Film kennt.

00:32:05,780 --> 00:32:10,149
Nun, und dann gibt es noch
eine Aussage über Variablen.

00:32:10,149 --> 00:32:14,249
Also, wir definieren im
Grunde eine neue Beziehung.

00:32:14,249 --> 00:32:21,379
Aber sie wird nicht definiert, indem man explizit
einige Paare auflistet, die diese Beziehung erfüllen.

00:32:21,379 --> 00:32:23,470
Aber eigentlich ist es eine
abgeleitete Eigenschaft.

00:32:23,470 --> 00:32:27,559
Es ist eine Regel, die
verallgemeinerte Fälle mit Variablen.

00:32:27,559 --> 00:32:32,599
Das heißt, X ist eifersüchtig auf Y.

00:32:32,599 --> 00:32:35,940
Wenn X Z liebt und Y Z liebt.

00:32:35,940 --> 00:32:45,529
Wenn also X und Y in gewissem Sinne dieselbe dritte
Person lieben, dann ist X eifersüchtig auf Y.

00:32:45,529 --> 00:32:49,889
Das ist ein vernünftiges Konzept
von Eifersucht, denke ich.

00:32:49,889 --> 00:32:53,349
Okay, und wie könnte nun
eine Abfrage funktionieren?

00:32:53,349 --> 00:33:00,879
Nun, zum Beispiel könnte man fragen, ob
Marsellus auf jemanden eifersüchtig ist.

00:33:00,879 --> 00:33:05,169
Und wenn man dieses Konzept im Kopf hat, dann
würde man erwarten, dass Marsellus wahrscheinlich

00:33:05,169 --> 00:33:06,330
auf jemanden eifersüchtig ist.

00:33:06,330 --> 00:33:09,959
Nämlich, wahrscheinlich ist
Marsellus eifersüchtig auf Vincent.

00:33:09,959 --> 00:33:11,470
Denn sie lieben beide Mia.

00:33:11,470 --> 00:33:14,799
Okay, diese Antwort ist also vernünftig.

00:33:14,799 --> 00:33:17,589
Und dann könnten wir wieder fragen, ob
es vielleicht eine andere Lösung gibt.

00:33:17,589 --> 00:33:18,789
Also, vielleicht sind wir hier falsch.

00:33:18,789 --> 00:33:21,450
Nun, schauen wir mal, was
tatsächlich passieren wird.

00:33:21,450 --> 00:33:27,490
Wenn wir fragen, ob Marsellus eifersüchtig
ist auf auch auf jemand anderen.

00:33:27,490 --> 00:33:28,960
Nun, das ist er tatsächlich.

00:33:28,960 --> 00:33:32,119
Dann ist er auch auf sich selbst eifersüchtig.

00:33:32,119 --> 00:33:35,190
Okay, das ist vielleicht überraschend.

00:33:35,190 --> 00:33:39,840
Aber nicht, wenn wir diese logische
Lesart hier in Betracht ziehen.

00:33:39,840 --> 00:33:45,139
Denn es heißt ja, dass X eifersüchtig ist
auf Y, wenn sie beide dieselbe Person lieben.

00:33:45,139 --> 00:33:50,919
Und auch wenn es hier zwei Variablen gibt, könnte
es sich bei beiden um dieselbe Person handeln.

00:33:50,919 --> 00:33:51,999
Richtig?

00:33:51,999 --> 00:33:55,059
Also, das ist dasselbe wie in den meisten
Programmiersprachen, auch in Haskell, natürlich.

00:33:55,059 --> 00:33:58,690
Wenn wir zwei Variablen haben, dann müssen
sie nicht die gleiche Instanziierung haben.

00:33:58,690 --> 00:34:04,470
Aber dort könnten wir haben: Nun, wenn wir
eine Gleichung "Funktion f x y ist etwas" und

00:34:04,470 --> 00:34:09,570
natürlich verhindert niemand,
dass f mit fünf und fünf.

00:34:09,570 --> 00:34:15,849
Und ähnlich, hier, kann dieses Konzept auch für
Situationen verwendet werden, in denen X und Y tatsächlich

00:34:15,849 --> 00:34:16,849
gleich sind.

00:34:16,849 --> 00:34:22,730
Wenn wir hier also Marsellus und Marsellus verwenden,
dann ist Marsellus, da er Mia liebt, eifersüchtig auf

00:34:22,730 --> 00:34:26,190
Marsellus, und daher ist dies
hier eine gültige Lösung.

00:34:26,190 --> 00:34:27,579
Weitere Lösungen gibt es hier nicht.

00:34:27,579 --> 00:34:30,389
Wenn wir nach weiteren Lösungen
fragen, wäre die Antwort "falsch".

00:34:30,389 --> 00:34:36,519
Okay, es gibt also einen Interpretationsansatz, da
dass verschiedene Variablen sich immer noch auf

00:34:36,519 --> 00:34:38,089
dieselbe Entität beziehen.

00:34:38,089 --> 00:34:41,440
Nun, natürlich wird auch hier darauf eingegangen.

00:34:41,440 --> 00:34:45,149
Aber gut zu wissen, dass natürlich dieses
X hier nichts mit diesem X zu tun hat.

00:34:45,149 --> 00:34:46,149
Oder?

00:34:46,149 --> 00:34:50,799
Wir müssen also nicht vorsichtig sein, wenn wir in
den Abfragen andere Variablennamen verwenden als

00:34:50,799 --> 00:34:51,940
im Programm.

00:34:51,940 --> 00:34:53,809
Das ist nur eine Umbenennung.

00:34:53,809 --> 00:34:54,809
Ja.

00:34:54,809 --> 00:34:55,929
Es gibt also unterschiedliche Geltungsbereiche.

00:34:55,929 --> 00:35:00,190
Also, hier haben wir nach
dem X in der Antwort gefragt.

00:35:00,190 --> 00:35:05,460
Und es gibt keine mögliche Verwechslung zwischen
diesem X und jenem X, weil es zum Beispiel

00:35:05,460 --> 00:35:12,510
in X1 und Y1 umbenannt werden könnte, und dann ist
es klar, dass dies das erste und dies das zweite

00:35:12,510 --> 00:35:13,510
Argument ist.

00:35:13,510 --> 00:35:17,170
Es gibt also keine Interaktion
mit diesem X und diesem X hier.

00:35:17,170 --> 00:35:21,930
Ja, das ist also gültig, genau
wie hier geschrieben hier.

00:35:21,930 --> 00:35:26,300
Okay, das ist also etwas, das wir fragen
können, auf wen Marsellus eifersüchtig ist.

00:35:26,300 --> 00:35:28,920
Und vielleicht ist es überraschend, dass
er auch auf sich selbst eifersüchtig ist.

00:35:28,920 --> 00:35:30,570
Aber das ist eigentlich nicht so überraschend.

00:35:30,570 --> 00:35:34,859
Wenn man das logisch liest, dann gibt es
einige andere Dinge, die wir fragen könnten.

00:35:34,859 --> 00:35:37,029
So können wir zum Beispiel
etwas fragen wie dieses.

00:35:37,029 --> 00:35:39,190
Was ist die Bedeutung davon?

00:35:39,190 --> 00:35:45,390
Nun, es ist auch die Frage, ob X eifersüchtig ist auf
... und dann ist da noch dieser seltsame Unterstrich,

00:35:45,390 --> 00:35:47,319
aber eigentlich ist er gar nicht so seltsam.

00:35:47,319 --> 00:35:49,770
Es ist einfach eine anonyme Variable.

00:35:49,770 --> 00:35:53,349
Ja, das ist eigentlich die gleiche
Syntax wie in Haskell, richtig?

00:35:53,349 --> 00:35:55,500
Der Unterstrich für "etwas,
das uns nicht interessiert".

00:35:55,500 --> 00:35:56,500
Wir wissen es nicht.

00:35:56,500 --> 00:35:57,500
Es ist uns egal.

00:35:57,500 --> 00:36:03,109
Es geht darum, ob eifersüchtig
X etwas, in diesem Fall jemand.

00:36:03,109 --> 00:36:06,180
Und wir sind nicht daran interessiert,
wer diese andere Person ist.

00:36:06,180 --> 00:36:09,460
Wir werden also Lösungen für X erhalten.

00:36:09,460 --> 00:36:13,720
Natürlich muss jede Lösung für X und dieses Prädikat
auch einen Partner haben, auf den X eifersüchtig

00:36:13,720 --> 00:36:14,720
ist.

00:36:14,720 --> 00:36:15,720
Aber das wird nicht gedruckt, richtig?

00:36:15,720 --> 00:36:19,779
Das ist also so etwas wie eine Variable, um deren
Ergebnis/Instanziierung wir uns nicht kümmern.

00:36:19,779 --> 00:36:23,200
Was würde also passieren, wenn
wir diese Anweisung ausgeben?

00:36:23,200 --> 00:36:26,130
Nun, wir wissen bereits, dass Marsellus
eifersüchtig ist auf jemanden.

00:36:26,130 --> 00:36:29,740
Wir wissen auch, aus demselben Grund, dass
Vincent eifersüchtig auf jemanden ist.

00:36:29,740 --> 00:36:33,660
Denn wir hätten diese Frage genauso
gut mit Vincent hier stellen können.

00:36:33,660 --> 00:36:37,490
Okay, also ist Vincent sicherlich
eifersüchtig auf jemanden.

00:36:37,490 --> 00:36:42,269
Also, wenn wir diese Frage stellen, dann
bekommen wir eine Antwort für X, nämlich Vincent.

00:36:42,269 --> 00:36:45,882
Und für diesen Unterstrich gibt es
keine Antwort, denn dieser ist anonym.

00:36:45,882 --> 00:36:47,900
Das interessiert uns nicht.

00:36:47,900 --> 00:36:50,380
Okay, was noch?

00:36:50,380 --> 00:36:52,030
Nun, wieder Vincent.

00:36:52,030 --> 00:36:55,980
Also, wir stellen diese Frage und
Prolog wird sagen: Nun, X ist Vincent.

00:36:55,980 --> 00:36:58,480
Und nebenbei, X ist Vincent
ist eine andere Lösung.

00:36:58,480 --> 00:36:59,829
Warum ist das so?

00:36:59,829 --> 00:37:06,849
Nun, grundsätzlich wird Prolog alle Möglichkeiten untersuchen,
wie X auf jemand anderen eifersüchtig sein könnte.

00:37:06,849 --> 00:37:13,130
Und nun, da, mit der gleichen Argumentation wie
oben ist Vincent sowohl eifersüchtig auf Marsellus

00:37:13,130 --> 00:37:14,789
als auch eifersüchtig auf sich selbst.

00:37:14,789 --> 00:37:18,340
Es gibt tatsächlich zwei Möglichkeiten,
wie Vincent eifersüchtig sein kann.

00:37:18,340 --> 00:37:20,560
Wir erhalten also eigentlich zwei Lösungen.

00:37:20,560 --> 00:37:25,109
Das bedeutet, dass die Ergebnisse, die Prolog
hier liefert, mehrere Mengen sind, nicht

00:37:25,109 --> 00:37:26,109
nur eine Menge.

00:37:26,109 --> 00:37:29,279
Prolog wird also nicht jede
Antwort nur einmal geben.

00:37:29,279 --> 00:37:33,920
Prolog wird jede Antwort so oft geben,
wie sie für wahr befunden wurde.

00:37:33,920 --> 00:37:39,680
Und ebenso gibt es zwei Arten, auf die
Marsellus auf jemanden eifersüchtig ist.

00:37:39,680 --> 00:37:42,010
Wir haben das oben schon gesehen.

00:37:42,010 --> 00:37:47,250
Also, wieder wird Prolog zweimal antworten,
dass Marsellus auf jemanden eifersüchtig ist.

00:37:47,250 --> 00:37:52,880
Und wir ignorieren, auf wen er eifersüchtig
ist, aber trotzdem, erhält man zwei Lösungen.

00:37:52,880 --> 00:37:58,130
Okay, und wenn wir dann nach weiteren Lösungen
fragen, tatsächlich, Mia ist auch eifersüchtig.

00:37:58,130 --> 00:38:00,150
Auf wen ist Mia eifersüchtig?

00:38:00,150 --> 00:38:03,289
Nun, nur auf sich selbst.

00:38:03,289 --> 00:38:06,589
Ja, also Mia liebt Vincent.

00:38:06,589 --> 00:38:09,579
Aber das bedeutet auch, dass
Mia eifersüchtig ist auf Mia.

00:38:09,579 --> 00:38:13,830
Denn sowohl Mia als auch Mia lieben Vincent.

00:38:13,830 --> 00:38:20,160
Okay, vielleicht sind das seltsame Ergebnisse oder überraschende
Ergebnisse, aber sie ergeben sich aus dem, was wir

00:38:20,160 --> 00:38:22,040
hier geschrieben haben.

00:38:22,040 --> 00:38:25,309
Okay, wie könnten wir das vielleicht reparieren?

00:38:25,309 --> 00:38:26,730
Nun, sagen wir, wir wollen das nicht.

00:38:26,730 --> 00:38:31,579
Wir wollen wirklich nur, dass eine Person
eifersüchtig ist, wenn es einen Konkurrenten gibt.

00:38:31,579 --> 00:38:37,220
Ja, wir wollen vielleicht nicht, dass Mia als
eifersüchtig angesehen wird, nur weil sie Vincent liebt.

00:38:37,220 --> 00:38:39,210
Also sollte sie nicht eifersüchtig auf sich sein.

00:38:39,210 --> 00:38:45,310
Nun, ich habe bereits erwähnt, dass verschiedene Variablen
hier die gleiche Person sein können, die gleiche Entität.

00:38:45,310 --> 00:38:49,780
Wenn man das also nicht will, muss
man das ausdrücklich verbieten.

00:38:49,780 --> 00:38:51,130
Können wir das tun?

00:38:51,130 --> 00:38:56,319
Ja, wir können etwas sagen wie, und die
Syntax wird in einem Moment gezeigt.

00:38:56,319 --> 00:39:00,619
Wir können sagen, dass X eifersüchtig auf Y
ist, wenn sie beide dieselbe Person lieben.

00:39:00,619 --> 00:39:03,539
Und eigentlich sind es
zwei verschiedene Personen.

00:39:03,539 --> 00:39:09,089
Wir könnten also sagen, wenn X anders
ist als Y, und X liebt Z, und Y liebt Z,

00:39:09,089 --> 00:39:11,400
dann ist X eifersüchtig auf Y.

8 # slide
00:39:11,400 --> 00:39:16,170
Okay, so muss das geschrieben werden.

00:39:16,170 --> 00:39:17,170
Ja.

00:39:17,170 --> 00:39:22,119
Das ist also etwas anders als die
Haskell-Syntax für nicht gleich.

00:39:22,119 --> 00:39:23,119
Ja.

00:39:23,119 --> 00:39:27,260
In Haskell wäre der
Schrägstrich anders orientiert.

00:39:27,260 --> 00:39:30,500
Hier ist dieser Backslash
die Negation von Gleichheit.

00:39:30,500 --> 00:39:34,029
Okay, die Basisfakten sind also dieselben.

00:39:34,029 --> 00:39:37,680
Die Regel ist fast die gleiche, aber jetzt
sagen wir explizit sagen: X ist anders als Y.

00:39:37,680 --> 00:39:40,960
Okay, hat das den gewünschten Effekt?

00:39:40,960 --> 00:39:41,960
Überprüfen wir das.

00:39:41,960 --> 00:39:46,599
Nun, darauf komme ich gleich zurück.

00:39:46,599 --> 00:39:50,930
Der Grund, warum ich das hier und nicht an den
Anfang gestellt habe, aber funktioniert es?

00:39:50,930 --> 00:39:56,970
Nun, es funktioniert in dem Sinne, dass wenn ich jetzt
frage, ob Marsellus auf jemanden eifersüchtig ist,

00:39:56,970 --> 00:39:58,940
dann ist die Antwort ja.

00:39:58,940 --> 00:40:00,990
Und es ist genau eine Instanziierung.

00:40:00,990 --> 00:40:03,680
Nämlich, Marsellus ist eifersüchtig auf Vincent.

00:40:03,680 --> 00:40:08,460
Es gibt keine Antwort mehr, dass Marsellus
eifersüchtig auf sich selbst ist, denn wir haben

00:40:08,460 --> 00:40:14,289
genau diese seltsame Eifersucht durch diese
Eigenschaft ausgeschlossen, durch diese Aussage.

00:40:14,289 --> 00:40:19,280
Okay, und zu der anderen Frage, ob oder wer sind
alle Personen, die auf jemanden eifersüchtig sind

00:40:19,280 --> 00:40:20,280
jemanden sind?

00:40:20,280 --> 00:40:24,130
Nun, wir bekommen immer noch
Vincent, aber nur einmal.

00:40:24,130 --> 00:40:30,009
Wir bekommen auch Marsellus, aber auch nur
einmal, weil all diese Eifersuchtssituationen

00:40:30,009 --> 00:40:32,269
nun durch diese Einschränkung
ausgeschlossen sind.

00:40:32,269 --> 00:40:37,020
Und wichtig ist, dass wir nicht
erfahren, dass Mia eifersüchtig ist.

00:40:37,020 --> 00:40:41,940
Denn sie ist es nicht nach der Interpretation, dass
man nur auf jemand anderen eifersüchtig sein kann.

00:40:41,940 --> 00:40:42,940
Okay.

00:40:42,940 --> 00:40:50,880
Und natürlich, wenn man wirklich daran interessiert
ist, wer auf wen eifersüchtig ist, und nicht nur, ob

00:40:50,880 --> 00:41:00,520
überhaupt jemand eifersüchtig ist, könnte man
auf diese anonyme Variable auch verzichten,

00:41:00,520 --> 00:41:02,190
und hier eine echte Variable verwenden.

00:41:02,190 --> 00:41:04,390
So etwas wie Y und dann könnten
Sie Fragen stellen wie diese.

00:41:04,390 --> 00:41:06,690
Und dann bekämen wir, gut, Vincent
ist eifersüchtig auf Marsellus.

00:41:06,690 --> 00:41:09,069
Das erklärt die erste Antwort hier.

00:41:09,069 --> 00:41:12,220
Aber auch Marsellus ist eifersüchtig auf
Vincent, das erklärt die zweite Antwort.

00:41:12,220 --> 00:41:14,250
Und es gibt keine weiteren Fälle.

00:41:14,250 --> 00:41:20,650
So, das ist jetzt auch ein vernünftiger
Zusammenhang zwischen diesen beiden Beobachtungen.

00:41:20,650 --> 00:41:28,540
Okay, eine wichtige Sache hier ist dieser Teil,
nämlich, dass so eine Negation am Ende der Regel

00:41:28,540 --> 00:41:30,029
stehen muss.

00:41:30,029 --> 00:41:31,980
Ich will jetzt nicht ins Detail gehen.

00:41:31,980 --> 00:41:35,240
Warum das jetzt so ist, und
auch für die Übungsaufgaben.

00:41:35,240 --> 00:41:39,940
Denken Sie daran, dass, wenn Sie etwas negativ
ausdrücken wollen, dann ist es immer die beste Idee,

00:41:39,940 --> 00:41:45,059
dies am Ende der Regel oder der Abfrage zu tun.

00:41:45,059 --> 00:41:51,039
Wenn wir dies also an den Anfang stellen
würden, dann wäre die Interpretation von Prologs

00:41:51,039 --> 00:41:52,420
Seite etwas anders ausfallen.

00:41:52,420 --> 00:41:57,470
Einige Abfragen würden immer noch wie erwartet funktionieren,
und andere könnten überraschende Ergebnisse liefern.

00:41:57,470 --> 00:41:58,900
Nun gut.

00:41:58,900 --> 00:42:05,750
Also, im Allgemeinen muss die
Negation vorsichtig verwendet werden.

00:42:05,750 --> 00:42:12,859
Das bezieht sich auch auf Dinge wie die spätere
Überprüfung, dass etwas die leere Liste ist oder nicht.

00:42:12,859 --> 00:42:18,160
Ja, erinnern Sie sich, in Haskell konnten wir
Pattern-Matching verwenden, um zwischen leeren und nichtleeren

00:42:18,160 --> 00:42:19,160
Listen unterscheiden.

00:42:19,160 --> 00:42:23,180
Oder wir könnten eine Anweisung haben
wie: if xs is nicht die leere Liste.

00:42:23,180 --> 00:42:25,650
In Haskell war dies äquivalent.

00:42:25,650 --> 00:42:31,130
In Prolog gibt es subtile Unterschiede zwischen
etwas mit einem Pattern-Matching auszudrücken,

00:42:31,130 --> 00:42:35,750
wie Sie sehen werden, ist
genauso möglich wie in Haskell.

00:42:35,750 --> 00:42:38,460
Es ist auch möglich, die Negation zu verwenden.

00:42:38,460 --> 00:42:42,790
Aber die Negation ist in
Prolog immer etwas speziell.

00:42:42,790 --> 00:42:46,950
Also wenn Sie etwas ohne Negation
ausdrücken können, ist das besser.

00:42:46,950 --> 00:42:53,509
Wenn man etwas mit Verneinung ausdrücken muss, wie
in diesem Fall, versuche man zumindest, die Negation

00:42:53,509 --> 00:42:59,609
in diesem Fall so spät wie möglich zu verwenden,
indem man sie an das Ende dieser Aussage hier stellt.

00:42:59,609 --> 00:43:03,259
Für einen Moment ist das das Einzige, was
Sie sich für diese Übung merken müssen.

00:43:03,259 --> 00:43:07,720
Wenn Sie etwas Negatives haben, wie dieses "not
equal", setzen Sie es an das Ende Ihrer Abfrage oder

00:43:07,720 --> 00:43:09,279
ans Ende Ihrer Regel.
