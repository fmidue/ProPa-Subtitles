0:00:02.270,0:00:06.580
Okay, wir gehen über zu CodeWorld.

0:00:06.580,0:00:13.430
Was wir hier sehen, ist genau der Ausdruck, den ich auf dem
Whiteboard erstellt habe (im vorigen, optionalen Video).

0:00:13.430,0:00:23.580
Wenn der Syntaxbaum fast genau das wäre, was ich dort
tatsächlich hatte... Es war, dass dieses ganze Polygon

0:00:23.580,0:00:32.920
Aufruf in diesen Ausdruck eingefügt wurde.

0:00:32.920,0:00:35.440
So,

0:00:35.440,0:00:48.160
ich hatte dieses Ding, das ich als Baum auf dem
Whiteboard hatte, einen wohldefinierten Ausdruck.

0:00:48.160,0:00:52.330
Und es zeichnet etwas Ähnliches wie das,
wovon wir letzte Woche begonnen haben.

0:00:52.330,0:00:57.800
Okay, aber ich möchte mich nicht so sehr
auf das Ausgangsbild hier konzentrieren.

0:00:57.800,0:01:05.070
Denn was ich hier wirklich tun möchte, ist etwas
Syntax besprechen, damit Sie vorbereitet sind

0:01:05.070,0:01:11.920
auch für Ihre eigenen ersten CodeWorld-Programme,
für die ersten Übungsaufgaben.

0:01:11.920,0:01:14.010
Okay, also was haben wir hier?

0:01:14.010,0:01:17.790
Wir haben diese Art von
Standardcode, der immer da ist.

0:01:17.790,0:01:20.789
Also, das ist gegeben; das
Importieren der Bibliothek.

0:01:20.789,0:01:26.560
Und das bedeutet im Grunde, dass wir jetzt
etwas zeichnen werden, aber noch nicht

0:01:26.560,0:01:27.560
eine Animation erstellen.

0:01:27.560,0:01:33.020
Also, dann müsste ich das in eine andere Primitive
ändern, aber das wollen wir im Moment nicht machen,

0:01:33.020,0:01:37.859
und wo ich diese Szene zeichnen möchte,
und ich habe diesen Ausdruck dafür.

0:01:37.859,0:01:38.859
Okay.

0:01:38.859,0:01:42.979
Und in diesem Fall habe ich bereits den
Namen für den Unterausdruck eingeführt.

0:01:42.979,0:01:44.520
Und das mache ich jetzt.

0:01:44.520,0:01:47.349
Okay, dieses Gleichheitszeichen
hier ist sehr wichtig.

0:01:47.349,0:01:48.759
Es ist kein Zuweisungsbefehl.

0:01:48.759,0:01:49.759
Ja.

0:01:49.759,0:01:56.819
Also, ich habe die Vorlesung dieser Woche damit begonnen
mit der Feststellung, dass funktionale Programmierung

0:01:56.819,0:02:01.750
im Wesentlichen Programmierung ohne Zuweisungsbefehle ist,
aber eigentlich sogar ohne irgendwelche Befehle überhaupt.

0:02:01.750,0:02:04.789
Jedenfalls wichtig, keine Zuweisungsbefehle.

0:02:04.789,0:02:08.929
Das sollte also nicht so gesehen
werden: Ich habe eine Variable "scene".

0:02:08.929,0:02:11.850
Und dann weisen wir dieser Variable etwas zu.

0:02:11.850,0:02:16.720
Und vielleicht weiter unten würden wir
das ändern und etwas anderes definieren,

0:02:16.720,0:02:18.810
etwas wie das hier.

0:02:18.810,0:02:21.600
Und Sie sehen bereits auf der linken
Seite, dass es einen Fehler gibt.

0:02:21.600,0:02:23.850
Und der wird wahrscheinlich
auch nicht verschwinden,

0:02:23.850,0:02:30.010
wenn ich das vervollständige. Das ergibt keinen
Sinn, weil wir keine Sachen an Variablen zuweisen.

0:02:30.010,0:02:36.500
Wir deklarieren Werte, und wir können nicht
zwei Deklarationen für denselben Wert haben.

0:02:36.500,0:02:41.100
Das wäre so, als würde man in einem Gleichungssystem
sagen, dass x gleich 5 ist, aber es ist auch

0:02:41.100,0:02:42.100
gleich 7.

0:02:42.100,0:02:45.850
Das wäre einfach ein mathematischer
Widerspruch. Wir können das nicht haben.

0:02:45.850,0:02:49.930
Das sind also keine Zuweisungsbefehle,
es sind einfach Deklarationen von Werten.

0:02:49.930,0:02:55.080
Okay, das bedeutet auch, dass die Reihenfolge der
Definitionen oder Deklarationen nicht wichtig sein sollte.

0:02:55.080,0:02:59.840
Sie sehen schon, dass ich hier "triangle"
verwende, das weiter unten im Code definiert wird.

0:02:59.840,0:03:06.350
Aber hier gibt es keinen Begriff von
"später", weil dies keine Dinge sind, die in

0:03:06.350,0:03:07.350
einer bestimmten Reihenfolge geschehen.

0:03:07.350,0:03:12.790
Es sind einfach Gleichungsdefinitionen.

0:03:12.790,0:03:18.480
Und wenn wir ein System von linearen Gleichungen
aufschreiben, 3 mal x plus 5 mal y ist 11,

0:03:18.480,0:03:22.760
und eine andere Gleichung, dann ist die Reihenfolge, in
welcher man die Gleichungen aufschreibt, nicht wichtig.

0:03:22.760,0:03:25.360
Wichtig ist, was die
Gleichung über die Werte sagt.

0:03:25.360,0:03:32.350
Wenn ich also die Reihenfolge hier ändere, ist das technisch
gesehen ein anderes Programm, aber es ist genauso gut

0:03:32.350,0:03:36.670
definiert, und es berechnet
natürlich das gleiche Bild.

0:03:36.670,0:03:42.420
Okay, weil wir den Variablen keine Dinge
zuweisen, sondern einfach Werte definieren.

0:03:42.420,0:03:47.130
Okay, das war eine Sache, die man
im Hinterkopf behalten sollte.

0:03:47.130,0:03:51.080
Dann gibt es noch ein paar Dinge,
die ich sagen sollte über die Syntax.

0:03:51.080,0:03:56.980
Sie fragen sich vielleicht, was das eigentlich
bedeutet, dass man "circle 0.1" schreibt.

0:03:56.980,0:04:01.790
Wenn ich auf dem Whiteboard sage, dass "circle"
eine Funktion ist, die eine Zahl nimmt,

0:04:01.790,0:04:05.220
sollte das nicht irgendwie so geschrieben werden?

0:04:05.220,0:04:11.209
Das sieht wahrscheinlich eher so
aus, wie Sie es gewohnt sind.

0:04:11.209,0:04:19.480
Oder lassen Sie mich das in einem Kommentar schreiben. So
sind Sie normalerweise an mathematische Syntax gewöhnt, wie

0:04:19.480,0:04:25.509
eine Funktion f von x zu definieren
ist, zum Beispiel Sinus von etwas.

0:04:25.509,0:04:27.889
Also, f von x ist sin von x.

0:04:27.889,0:04:34.030
So schreibt man eine Funktionsdefinition
und einen Ausdruck mit trigonometrischen

0:04:34.030,0:04:36.039
Funktionen wie Sinus.

0:04:36.039,0:04:44.360
In der Mathematik. Nun, der Unterschied in Haskell
ist, hauptsächlich: Wir benutzen nicht so viele

0:04:44.360,0:04:51.240
Klammern, weil die Anwendung einer Funktion auf
einen Wert einfach als f von x geschrieben wird.

0:04:51.240,0:04:55.479
Wir müssen das Argument nicht in
Klammern setzen.

0:04:55.479,0:05:03.289
Stattdessen schreiben wir einfach f x, und das Gleiche hier
auf der rechten Seite auch. Um Sinus auf etwas anzuwenden,

0:05:03.289,0:05:08.250
muss man nicht sagen, Sinus und in Klammern
das x, sondern einfach Sinus auf x angewendet.

0:05:08.250,0:05:09.680
Okay.

0:05:09.680,0:05:12.599
Und das gilt auch für Funktionen,
die mehr als ein Argument nehmen.

0:05:12.599,0:05:16.969
Wenn wir also eine Funktion haben, die zwei Argumente
benötigt, dann würden wir in der Mathematik wieder

0:05:16.969,0:05:23.199
vielleicht etwas schreiben wie f von
x und y, und dann eine Definition.

0:05:23.199,0:05:32.029
Und in Haskell schreiben wir stattdessen
einfach ohne die Klammern und ohne Komma, x y.

0:05:32.029,0:05:34.430
Und dann schreiben wir die Definition auf.

0:05:34.430,0:05:35.610
Okay.

0:05:35.610,0:05:42.270
Und das ist auch der Grund, warum etwa das, was ich im
Syntaxbaum als den "translated"-Aufruf gezeichnet habe

0:05:42.270,0:05:51.189
(mit drei Argumenten), hier nicht geschrieben
ist wie "translated" und dann das erste

0:05:51.189,0:05:54.639
Argument und das zweite
Argument und etwas anderes.

0:05:54.639,0:05:59.699
Stattdessen wird es einfach so geschrieben wie hier,
translated, Leerzeichen, das erste Argument, Leerzeichen,

0:05:59.699,0:06:05.499
das zweite Argument, Leerzeichen, das dritte Argument.
Und das dritte muss ich in Klammern setzen, aber nicht

0:06:05.499,0:06:09.580
weil "translated" dort Klammern erwartet.

0:06:09.580,0:06:13.500
Sondern einfach weil, wenn ich es so schreiben
würde, es dann nicht klar wäre, was das

0:06:13.500,0:06:20.189
Argument wovon ist. Man könnte denken, dass
die "colored"-Funktion das dritte Argument

0:06:20.189,0:06:22.900
zu "translated" ist, nicht
der ganze Ausdruck hier.

0:06:22.900,0:06:28.629
Da muss ich also Klammern verwenden.

0:06:28.629,0:06:35.840
Aber es sind viel weniger Klammern, als wenn ich
das im mathematischen Stil geschrieben hätte.

0:06:35.840,0:06:41.339
Lassen Sie mich das mal überlegen,
dann hätte ich es so geschrieben.

0:06:41.339,0:06:46.990
Und auch das "colored" würde so geschrieben
werden, weil es zwei Argumente braucht.

0:06:46.990,0:06:48.620
Okay.

0:06:48.620,0:06:51.310
Also, das ist nicht das, was wir machen.

0:06:51.310,0:06:52.310
Was wir machen, ist das.

0:06:52.310,0:07:00.259
Und sobald Sie anfangen, Lösungen in Autotool
einzureichen, warnt es Sie auch vor zu

0:07:00.259,0:07:02.150
vielen Klammern.

0:07:02.150,0:07:08.509
Sie können das nicht einmal schreiben, weil die Kommas
nichts in einer Funktionsanwendung zu suchen haben

0:07:08.509,0:07:09.509
in Haskell.

0:07:09.509,0:07:14.199
Aber auch wenn Sie etwas ohne die Kommas schreiben
und versuchen, hier mehr Klammern hinzuzufügen,

0:07:14.199,0:07:19.159
weil Sie sich sicherer fühlen, z.B. indem Sie Klammern
um alle Argumente packen, dann wird Autotool sagen,

0:07:19.159,0:07:21.810
dass diese Klammern überflüssig sind.

0:07:21.810,0:07:28.580
Und wir raten Ihnen, die vorgeschlagenen
Änderungen vorzunehmen, so dass Ihre Programme

0:07:28.580,0:07:33.490
so aussehen, wie Programme in
Haskell normalerweise sind.

0:07:33.490,0:07:39.689
Okay, das waren ein paar
einfache Syntax-Bemerkungen.

0:07:39.689,0:07:45.779
Ich habe bereits darüber gesprochen, dass die
Reihenfolge der Definitionen unwichtig ist.

0:07:45.779,0:07:50.619
Und das wird natürlich immer wichtiger und relevanter,
wenn wir weitere Namen/Definitionen einführen.

0:07:50.619,0:07:57.469
So könnte ich zum Beispiel, im Sinne meiner
früheren Kommentare in den Folien und

0:07:57.469,0:08:02.499
auf dem Whiteboard, auch Namen für weitere
Unterausdrücke einführen, wo ich sagen könnte: dieses

0:08:02.499,0:08:09.559
farbige rote Dreieck ist auch etwas, das ich
vielleicht wiederverwenden möchte. Sagen wir mal,

0:08:09.559,0:08:19.139
diese rote Form sollte auch einen Namen
bekommen.

0:08:19.139,0:08:25.759
Und dann könnte ich zum Beispiel sagen, na ja, ich
verschiebe das einfach aus dem obigen Ausdruck heraus

0:08:25.759,0:08:26.979
und gebe ihm einen Namen.

0:08:26.979,0:08:28.649
Und dann benutze ich diesen Namen hier.

0:08:28.649,0:08:35.460
Okay, also was ich hier in dieser Zeile gemacht habe, war,
dass ich auch gesagt habe, dass das ein Bild sein soll.

0:08:35.460,0:08:37.720
Eigentlich müsste ich das gar nicht machen.

0:08:37.720,0:08:47.160
Denn Haskell führt Typinferenz aus. Also selbst
wenn ich all diese Typ-Annotationen verwerfe,

0:08:47.160,0:08:50.910
weiß Haskell immer noch, dass dies ein Picture ist,
auch wenn ich es hier nicht aufgeschrieben habe.

0:08:50.910,0:08:51.910
Okay.

0:08:51.910,0:08:59.310
Und wenn ich etwas Dummes mache, wenn ich etwas
sage wie, redForm ist einfach "red", dann würde das

0:08:59.310,0:09:00.310
ein Typfehler sein.

0:09:00.310,0:09:01.310
Na gut.

0:09:01.310,0:09:05.390
Also, es funktioniert so, dass es eigentlich ein "Picture"
sein sollte, aber es ist nur "Color". Es ergibt keinen

0:09:05.390,0:09:06.390
Sinn,

0:09:06.390,0:09:11.960
auch ohne Annotationen. Und wenn ich eine
korrekte Definition angebe, dann funktioniert es.

0:09:11.960,0:09:16.730
Okay, und wenn ich das ausführe, dann bekomme ich das
gleiche Bild, aber einfach mit umbenannten Sachen.

0:09:16.730,0:09:18.680
Namen für Unterausdrücke.

0:09:18.680,0:09:21.910
Ich habe nichts an den Werten
geändert, die ich berechne.

0:09:21.910,0:09:27.310
Und noch einmal, die Reihenfolge, in der die
Dinge definiert sind, ist hier völlig irrelevant.

0:09:27.310,0:09:34.200
Wenn die Werte definiert sind,
dann ist das in Ordnung.

0:09:34.200,0:09:39.410
Okay, was kann ich tun, wenn ich den Namen eingeführt
habe? Das erlaubt mir natürlich die Wiederverwendung von

0:09:39.410,0:09:45.950
Definitionen. Ich könnte also zum Beispiel sagen,
zusätzlich zu diesen beiden Formen möchte ich noch

0:09:45.950,0:09:52.120
eine weitere Form. Also verwende ich diesen binären Operator.
Er kann auch auf mehrere Argumente angewendet werden,

0:09:52.120,0:09:56.760
wie ein Plus. Man kann a + b + c schreiben,
obwohl Plus ein binärer Operator ist.

0:09:56.760,0:09:57.760
Es ist assoziativ.

0:09:57.760,0:10:00.210
Man kann also eine Folge
von Additionen schreiben.

0:10:00.210,0:10:04.380
Und das Gleiche gilt für diesen
Operator zum Kombinieren von Bildern.

0:10:04.380,0:10:09.650
Ich könnte zum Beispiel sagen, ich möchte kombinieren
eine andere rote Form (oder die gleiche rote Form), aber

0:10:09.650,0:10:15.900
jetzt nicht in dieser verschobenen Form, sondern
so wie es ist. Und was bekomme ich dann?

0:10:15.900,0:10:25.790
Nun, ich erwarte, dass ich hier ein
weiteres Dreieck sehe, am Ursprung.

0:10:25.790,0:10:27.530
Okay.

0:10:27.530,0:10:32.210
Und natürlich kann ich es auch drehen, zum
Beispiel. Ich kann sagen, gut, lass mich das drehen.

0:10:32.210,0:10:36.600
Wir wissen, dass das in Bogenmaß ist.

0:10:36.600,0:10:41.220
Ich nehme also die Hälfte der Zahl Pi.

0:10:41.220,0:10:43.380
Und was passiert dann?

0:10:43.380,0:10:47.450
Ich bekomme dieses Bild.

0:10:47.450,0:10:51.370
Und natürlich habe ich die rote Form nicht
wirklich bewegt oder gedreht, richtig?

0:10:51.370,0:10:54.580
Es ist nicht so, dass es
eine gedrehte rote Form ist,

0:10:54.580,0:10:56.830
und jetzt ist diese rote
Form irgendwie auch gedreht.

0:10:56.830,0:10:58.110
Nein, natürlich nicht.

0:10:58.110,0:11:02.260
Das wäre nicht im Sinne der
mathematischen Ausdrücke.

0:11:02.260,0:11:07.450
Das wäre so, als würde man eine Aktion anwenden
und hätte einen Effekt, diese rote Form zu bewegen.

0:11:07.450,0:11:09.170
Aber das ist nicht das, was hier passiert.

0:11:09.170,0:11:11.530
Die rote Form ist nur dieses rote Dreieck.

0:11:11.530,0:11:16.890
Und dann benutze ich es hier für irgendeinen
Wert, und hier für etwas anderes.

0:11:16.890,0:11:20.790
Und das liegt nicht nur daran, dass ich diese Rotation
in gewisser Weise nach der Translation ausführe.

0:11:20.790,0:11:25.370
Also, es geht nicht um die zeitliche Abfolge.

0:11:25.370,0:11:36.180
Auch wenn ich es so mache, einfach zuerst sage, ich
habe das so kombiniert, dann bedeutet das nicht,

0:11:36.180,0:11:39.880
dass jetzt die rote Form gedreht ist,

0:11:39.880,0:11:42.990
und wenn ich sie dann wieder verwende,
dann ist sie irgendwie immer gedreht.

0:11:42.990,0:11:44.720
Nein, das ist nicht der Fall.

0:11:44.720,0:11:52.820
Das Ergebnis hier wird genau das gleiche Bild sein,
weil es ein rotes Dreieck gibt, und ich benutze

0:11:52.820,0:11:58.370
es hier, und drehe es und verwende das Ergebnis.

0:11:58.370,0:12:01.850
Und ich benutze wieder die
rote Form und verschiebe sie.

0:12:01.850,0:12:09.410
Und dann verwende ich diesen resultierenden
Wert als Teil meiner Gesamtszene.

0:12:09.410,0:12:17.060
Okay, das war also etwas, das ich zeigen
wollte.

0:12:17.060,0:12:23.490
Und dann wollte ich auch schon zeigen,
dass man diese Definitionen nicht auf

0:12:23.490,0:12:24.490
der obersten Ebene haben muss.

0:12:24.490,0:12:31.120
Sie müssen also keinen neuen Namen
einführen, oder Ihre Unterausdrücke im Scope

0:12:31.120,0:12:37.090
des gesamten Moduls haben. Das wäre ungünstig, denn
dann hätten Sie vielleicht sehr viele von diesen

0:12:37.090,0:12:41.950
Definitionen, die nicht alle
wirklich miteinander zu tun haben.

0:12:41.950,0:12:46.770
Man könnte also zum Beispiel sagen, na ja,
eigentlich brauche ich diese rote Form nur im

0:12:46.770,0:12:52.360
Kontext dieser Szenendefinition,
aber nicht anderswo.

0:12:52.360,0:12:58.220
Man könnte also sagen, nun, ich möchte das
hier verwenden, lokal in gewisser Weise, und

0:12:58.220,0:13:04.120
dann könnte man so etwas machen,
wie in der Mathematik: ich will

0:13:04.120,0:13:09.290
2 mal y berechnen, wobei y gleich
x plus 1 ist, zum Beispiel.

0:13:09.290,0:13:20.670
Ich kann also sagen, dass ich diesen Ausdruck berechnen möchte.
Darin möchte ich diesen Wert namens "redForm" verwenden,

0:13:20.670,0:13:30.810
und ich verschiebe diese
Definition lokal in diesen Bereich.

0:13:30.810,0:13:38.680
Dann ist es wieder wohldefiniert und berechnet
dasselbe Bild, natürlich. Ich habe es einfach

0:13:38.680,0:13:40.160
auf eine andere Weise ausgedrückt.

0:13:40.160,0:13:46.050
Und jetzt habe ich redForm nicht als globalen
Wert, der irgendwo anders verwendet werden kann.

0:13:46.050,0:13:49.880
Es ist jetzt wirklich lokal
für diese "scene"-Definition.

0:13:49.880,0:13:53.150
Damit können wir also Dinge gruppieren.

0:13:53.150,0:13:59.560
Vielleicht ist das nicht so wichtig bei den ersten
Übungsaufgaben, aber später ist es eine nützliche

0:13:59.560,0:14:06.140
Technik, um den Code so zu organisieren, dass
er lokale Definitionen auf diese Weise nutzt.

0:14:06.140,0:14:07.250
Okay.

0:14:07.250,0:14:13.510
Ich denke, das war alles an Syntax und
Funktionen, die ich im Moment zeigen wollte.
