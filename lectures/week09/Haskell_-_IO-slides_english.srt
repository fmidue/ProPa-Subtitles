149 # slide
00:00:01,920 --> 00:00:12,320
After the several short videos this week so far,
now will come a longer video again. And this will

00:00:12,320 --> 00:00:18,800
be the last video on the Haskell part of this
course. So, with this chapter, this last chapter

00:00:18,800 --> 00:00:25,040
we will close the Haskell part of the lecture,
and next week the lecture will be about Prolog.

00:00:26,400 --> 00:00:29,040
As you see here,

00:00:29,040 --> 00:00:33,520
we will be dealing with input and output. That
is something that we have largely ignored so

00:00:33,520 --> 00:00:38,880
far. In CodeWorld, we have produced some output:
the pictures and the animations. But we didn't

00:00:39,920 --> 00:00:45,440
program input facilities where the user is
asked for some input. So far, if we wanted to

00:00:47,360 --> 00:00:51,600
apply our functions to some input, then we
would have to call them in the interpreter.

00:00:51,600 --> 00:00:55,600
We haven't written stand-alone programs that
ask the user for input and return an output.

00:00:57,200 --> 00:01:02,160
To be taken seriously, a language should have
facilities for this. And Haskell certainly has.

00:01:02,160 --> 00:01:09,040
And indeed here on this slide, I have a somewhat
surprising quote which claims that Haskell is the

00:01:09,040 --> 00:01:13,680
world's finest imperative programming language,
which is a bit counterintuitive probably because

00:01:13,680 --> 00:01:19,360
so far in the course, I have always emphasized
differences between Haskell and imperative

00:01:19,360 --> 00:01:27,200
programming languages, like the absence of side
effects, no dealing with non-local information,

00:01:27,200 --> 00:01:32,000
global state, things like that. Now, here is a
quote by Simon Peyton Jones. What is that? He

00:01:32,000 --> 00:01:37,680
knows a bit or two about Haskell. He is one of
the main people… main persons… the project lead

00:01:37,680 --> 00:01:43,280
behind the GHC (the compiler we have been
using) and has since been involved in the

00:01:43,280 --> 00:01:47,600
development and design of the Haskell language.
So, if he says something like this, it is not

00:01:47,600 --> 00:01:54,080
just a joke. How does he mean this? The point is
that even though Haskell is a functional language,

00:01:54,080 --> 00:01:59,120
it is not imperative; by design, it does
have facilities for dealing with all these

00:01:59,120 --> 00:02:05,440
imperative effects as well. And we will just
see a glimpse of this in this one half lecture.

00:02:06,880 --> 00:02:12,800
And the way that these features are included
in Haskell is much more principled than a

00:02:12,800 --> 00:02:18,640
language that is just imperative from the start.
Haskell is a mathematically-oriented language.

00:02:18,640 --> 00:02:24,480
It does have support for all kinds of imperative
features. But they are integrated in a way that

00:02:24,480 --> 00:02:30,080
doesn't compromise the mathematical properties of
the language. In that sense, there is a certain

00:02:30,080 --> 00:02:37,120
beauty also in how these imperative features
can be used. So, they can make use of all the

00:02:37,120 --> 00:02:42,240
abstraction facilities we have seen so far
in the pure part of the language. Of course,

00:02:42,240 --> 00:02:47,440
I won't be able to do full justice to this beauty
because I have only this half lecture I will spend

00:02:47,440 --> 00:02:52,800
on this. And we will not talk about the general
picture of the general facilities for this. So,

00:02:52,800 --> 00:02:59,280
that would come under the heading of monads
which you may have heard about, which is an

00:02:59,280 --> 00:03:04,560
important language design part of Haskell. But
it is not something I will cover in abstract

00:03:05,120 --> 00:03:10,160
ways in this course. That would be something
for an advanced lecture or an advanced seminar.

00:03:10,720 --> 00:03:17,200
But we will see this specific application
of this concept for input and output. This

00:03:17,200 --> 00:03:22,480
is just one of the imperative features, but other
features known from imperative languages can be

00:03:22,480 --> 00:03:27,520
integrated in a syntactically similar fashion.
But that is not something that I will do here.

150 # slide
00:03:31,360 --> 00:03:36,800
So, even in a declarative language, be it
Haskell, be it Prolog starting next week,

00:03:36,800 --> 00:03:41,520
there should be some way to embed imperative
commands. Because we might want to do something

00:03:41,520 --> 00:03:45,840
like print something to the screen on
our computer, or we want to ask the user

00:03:46,720 --> 00:03:51,600
"What should I do?", so, ask for some
input number maybe on which then to compute

00:03:51,600 --> 00:03:59,600
some function. Let's remember this distinction
between expressions and commands. I put a lot of

00:03:59,600 --> 00:04:03,920
emphasis on that Haskell is expression-based,
and expressions don't have side effects.

00:04:03,920 --> 00:04:09,360
They simply compute a value. Printing something
to the screen is completely different. And we

00:04:09,360 --> 00:04:13,680
know that in pure functions, as we have programmed
so far, there shouldn't be such interaction with

00:04:13,680 --> 00:04:19,440
the operating system, with user input from the
keyboard or whatever. This shouldn't be possible.

00:04:19,440 --> 00:04:24,640
And that's very important because otherwise,
that would defy the referential transparency. So,

00:04:24,640 --> 00:04:30,000
the idea that an expression computes a value
and the same expression given the same context

00:04:30,000 --> 00:04:35,440
always produces the same value. We can share
subexpressions and things like that. That was

00:04:35,440 --> 00:04:41,600
not valid if we consider non-pure expressions; so,
if we consider commands. That was the discussion I

00:04:41,600 --> 00:04:47,440
had in one of the very first videos in the first
or second lecture week about this idea that if we

00:04:47,440 --> 00:04:52,080
had an expression which reads something… which has
a side effect of reading something from the user,

00:04:52,080 --> 00:04:56,480
then suddenly mathematical transformations
of expressions wouldn't be valid anymore.

00:04:56,480 --> 00:05:02,320
They would change the semantics because maybe
the order of evaluation influences which of two

00:05:03,200 --> 00:05:12,240
input commands is executed first, etc. Simply
adding such imperative commands as expressions

00:05:12,240 --> 00:05:19,600
is a no-go because that would destroy the
mathematics of the language. Nevertheless,

00:05:19,600 --> 00:05:24,720
we need such facilities in some sense. We have to
do this. We have to write programs that. We want

00:05:24,720 --> 00:05:29,440
to write programs that ask the user for
input and to print output. What do we do?

00:05:29,440 --> 00:05:33,680
There is a special notation. It is the so-called
do-notation, which has to do with monads. But

00:05:34,240 --> 00:05:41,040
that abstract concept will not be covered here. We
will simply take this do-notation as our point of

00:05:41,040 --> 00:05:45,680
interaction with this feature. And we will see
how it is used. Actually, we have already seen

00:05:45,680 --> 00:05:54,080
the do-notation because the main definitions
where the test suites were integrated in many of

00:05:55,200 --> 00:05:59,840
Autotool tasks already used the do-notation. There was
some printing to the screen and then the execution

00:05:59,840 --> 00:06:05,840
of test suites, etc. This was, of course, already
some effect facility, printing to the screen.

00:06:06,960 --> 00:06:10,880
So, there is the special do-notation. We will
see how it works. It does enable such interaction

00:06:10,880 --> 00:06:14,640
and from that do-notation, we can, of course, call
normal functions. So, we will use do-notation where

00:06:14,640 --> 00:06:20,960
we do interactive behavior with the user, maybe.
And of course, we call so-called normal functions,

00:06:20,960 --> 00:06:27,440
so the mathematical functions of Haskell to do
computation on the inputs that the user has given.

00:06:28,880 --> 00:06:32,800
That would be the very naïve way to just
have the do-notation, and then we call normal

00:06:32,800 --> 00:06:37,760
functions. But actually, the integration is much
deeper because all the features and abstraction

00:06:37,760 --> 00:06:42,000
concepts like higher-order-ness, polymorphism,
…, so all the things we have seen of Haskell,

00:06:42,000 --> 00:06:48,240
they remain available even in and with do-code.
So it is not like there is a strict separation.

00:06:48,880 --> 00:06:52,560
Of course, there is a separation, but this
separation is on the type level, as you will see.

00:06:52,560 --> 00:06:58,080
But we don't give up our abstraction
facilities like writing higher-order functions,

00:06:58,880 --> 00:07:04,560
writing polymorphic code just because we also
have to do do-code now because we want to have

00:07:04,560 --> 00:07:09,680
some effects. We will also be able to abstract
over code that uses the do-notation. That's very

00:07:09,680 --> 00:07:16,160
important because it gives us a means of thinking
about imperative code that is not available in

00:07:16,160 --> 00:07:21,440
full imperative languages. That's what Simon
was referring to on the previous slide as well.

151 # slide
00:07:24,560 --> 00:07:31,440
So here's the first example, very simple. We want
the “hello world” of the Haskell do-notation.

00:07:32,080 --> 00:07:36,160
And the task is to get two numbers from the
user, and then compute something from them,

00:07:36,160 --> 00:07:43,600
in this case, the product of all the integers
from the first number to the second number,

00:07:43,600 --> 00:07:47,840
and then print the result to the screen.
And that is exactly what this code is

00:07:49,200 --> 00:07:56,000
saying. This is the “main” definition. Usually
in the Autotool task, there would be the

00:07:56,720 --> 00:08:03,440
test suite written here. Now instead, we
have some input. So this notation is for:

00:08:03,440 --> 00:08:11,440
read a value from the user, and bind the result
to n, and then read another value from the user

00:08:11,440 --> 00:08:18,800
and bind whatever the result has entered to m,
and then compute something. And this “prod” is a

00:08:18,800 --> 00:08:22,800
pure function, so defined in this case with
pattern-matching on lists. But it could be any

00:08:23,760 --> 00:08:28,960
function on Integer lists that you can define
via list comprehensions or foldr or whatever,

00:08:29,920 --> 00:08:36,240
and then the result is printed. What does the
do-notation give us? It gives us a means of

00:08:36,240 --> 00:08:42,480
sequentializing. That the point was: we shouldn't be
printing something like the product of read times

00:08:42,480 --> 00:08:49,040
read. Because then, the order becomes unclear.
So, this is really similar to imperative code in

00:08:49,040 --> 00:08:54,000
the sense that we have, if we want to think
about it, a semicolon at the end of each

00:08:54,000 --> 00:09:00,240
line which somehow gives sequential order. So,
first, read something, bind the result to n,

00:09:01,040 --> 00:09:04,800
read something, bind the result to m, then we
also know what the first and the second inputs

00:09:04,800 --> 00:09:11,200
by the user are because it is sequentialized, then
some computation based on these values, and then

00:09:11,200 --> 00:09:17,280
printing this out. What you may notice
is that we don't need to say here that

00:09:17,280 --> 00:09:22,400
n should be an Integer. There's no
“scanf” like in C, with some special

00:09:23,840 --> 00:09:29,360
format string to express what is
read. This will be decided by

00:09:30,400 --> 00:09:36,240
type inference. Since the n and m variables, which
are not type annotated here, will be used as

00:09:36,240 --> 00:09:40,960
inputs to the prod function, which is Integer
type, automatically, the compiler will find out

00:09:40,960 --> 00:09:45,520
that we should read an Integer here. So if
the user inputs something here which doesn't

00:09:45,520 --> 00:09:51,280
pass as an Integer, because they use “abc”,
not just digits, then this will be rejected.

00:09:52,640 --> 00:09:58,320
But that's the main point (type inference). The
main point is the separation of do-code and

00:09:58,320 --> 00:10:04,640
the computation code, and the fact that here
the “do”, we have this sequential behavior

00:10:04,640 --> 00:10:10,480
which makes clear, and is corresponding
to C or Python code in the sense that we

00:10:10,480 --> 00:10:18,400
have commands. We can read these as commands,
and they are executed in a certain order not

00:10:18,960 --> 00:10:24,800
governed by lazy evaluation but really governed by
syntactic appearance in this sequential do-block.

152 # slide
00:10:28,480 --> 00:10:32,880
The principle behind this integration and also
where the guarantees about the mathematical

00:10:32,880 --> 00:10:39,040
well-behavedness and nice integration with the
rest of the language come from this on the type

00:10:39,040 --> 00:10:44,400
level. So as you have seen on the previous slide,
and also in the test suites, the type of the main

00:10:44,400 --> 00:10:49,040
was something like IO and then the empty tuple.
The empty tuple is not the important part. The IO

00:10:49,040 --> 00:10:54,240
is the important part. It's a type constructor,
just as we have seen type constructors

00:10:54,240 --> 00:10:59,440
like Tree or List, that take an argument and then
give us a Tree of Bools, a Tree of Ints, etc.

00:10:59,440 --> 00:11:03,520
There is the type constructor IO, but it's not
a type constructor that we can define ourselves,

00:11:03,520 --> 00:11:07,360
it's not something that a user has written
with the "data" syntax. It's an abstract type

00:11:07,360 --> 00:11:14,240
that is provided by the language, by some part
of the runtime system. It's a type constructor.

00:11:14,240 --> 00:11:18,560
It is used like the other type constructors we
have seen so far. Since we have basic types like

00:11:22,800 --> 00:11:27,840
Int or user-defined types like Tree of something,
or compound types like lists of pairs, etc.,

00:11:28,640 --> 00:11:34,320
then with each of these types we can have also the
type IO of Int, IO of Tree Bool, IO of whatever,

00:11:34,880 --> 00:11:39,120
because IO is a polymorphic type constructor.
It waits for a type argument, and then it is

00:11:39,120 --> 00:11:47,360
IO whatever type. What is the interpretation of
this? If we have something like IO of an abstract

00:11:47,360 --> 00:11:54,560
type (a) or a type Int, Bool, whatever, then
the idea is that the elements of that IO type

00:11:54,560 --> 00:12:01,520
are not themselves concrete values. It's not
like IO Int is five. They are commands. They are

00:12:02,160 --> 00:12:05,968
potentially arbitrary complex sequences
of input and output operations (that

00:12:05,968 --> 00:12:10,720
is what it is called IO), and computations
depending on those values that are read in,

00:12:10,720 --> 00:12:16,240
and ultimately a value of type (a) is created.
So IO Int could be a complete program that

00:12:17,040 --> 00:12:20,240
asks the user for inputs, does some
computation, prints something to the screen,

00:12:20,800 --> 00:12:25,600
asks for further input etc., and then at the very
end, of all of these effects, it produces a value,

00:12:25,600 --> 00:12:32,240
maybe like an exit code of the program. The whole
program of this kind may be written in a long

00:12:32,240 --> 00:12:36,800
do-block and maybe even in nested do-blocks and
calls to other functions would be something of

00:12:36,800 --> 00:12:44,640
type IO Int, for example, because it does complex
operations, and in the end, it returns an Int.

00:12:47,200 --> 00:12:53,280
In that sense, it makes sense that a Haskell
program that can be compiled and then run as

00:12:53,280 --> 00:12:56,800
a stand-alone program doesn't need the
compiler or the interpreter anymore,

00:12:57,360 --> 00:13:03,360
should have an IO type. And usually, it's a
type IO empty type because we are interested

00:13:03,360 --> 00:13:07,200
in what the program does and not what it
computes at the end. It could also be IO Int,

00:13:07,200 --> 00:13:12,640
and then the Int could maybe be the exit code,
like often done in C programs that return an

00:13:12,640 --> 00:13:20,840
exit code to the shell. But usually in Haskell,
we usually use IO and this empty tuple ().

153 # slide
00:13:22,480 --> 00:13:29,360
Where do we get such IO values or IO commands
from? There must be some predefined primitives

00:13:30,160 --> 00:13:37,040
and they are recognizable by their IO-based
types. These primitives are the things that

00:13:37,040 --> 00:13:43,120
would be commands in an imperative language…
that would make up commands in an imperative

00:13:43,120 --> 00:13:48,160
language. So, reading from the user, writing
to a file, things like that. For every kind

00:13:48,160 --> 00:13:53,280
of effect that we want to integrate in such an
input-output sequence, there is some primitive.

00:13:54,160 --> 00:13:58,960
Here we will only look at primitives for reading
from the keyboard and printing to the console.

00:14:01,040 --> 00:14:06,560
The most basic primitives for this would
be the tool here: get a character. That's

00:14:06,560 --> 00:14:10,400
an IO behavior. That's why its type is IO
something. And what is the something? That's

00:14:10,400 --> 00:14:16,000
a character because we do some input-output.
In this case, we are getting only an input.

00:14:16,000 --> 00:14:20,800
And then, what is the result? It's a character
that the user has inputted. It is not the same

00:14:20,800 --> 00:14:27,040
as a constant of type Char which can only be
constant for some fixed Char. Since it is IO Char,

00:14:27,040 --> 00:14:32,480
it's a computation that depends on what the
user is doing, what the user is providing,

00:14:32,480 --> 00:14:37,840
and then there is a Char. If the user answers
with the Char 'a', then the outcome here is 'a'.

00:14:37,840 --> 00:14:42,000
And if the user enters the Char 'b', then the
outcome is 'b' even though this is not a function.

00:14:42,640 --> 00:14:48,480
There's no dependence on some input. It implicitly
depends on what the user is doing. And the IO type

00:14:48,480 --> 00:14:58,880
constructor encapsulates this. 'putChar' prints
one Char to the screen. And based on this,

00:14:58,880 --> 00:15:03,520
there will be a further function which does the
same for a String, etc. But the basic primitive is

00:15:03,520 --> 00:15:07,760
to put a Char on the screen. This is a
function, so we have to provide a Char.

00:15:07,760 --> 00:15:12,080
And then what is it doing? It performs some
input-output, namely printing this Char

00:15:12,080 --> 00:15:17,200
to the screen, and it returns nothing because
there is no need to return anything when we

00:15:17,200 --> 00:15:21,520
put something to the screen. There is no
user input that has to be reflected to the

00:15:22,080 --> 00:15:26,800
caller of the function. That's why
it's a function which takes a Char,

00:15:26,800 --> 00:15:32,320
does some IO, and then doesn't need to give back a
result. It could give back an error code, maybe if

00:15:32,960 --> 00:15:37,840
putting a Char to the screen could fail for
some reason. But it is simple. The type is

00:15:38,720 --> 00:15:47,760
to have Char as input and IO nothing as the
output. That is the result of this function. We

00:15:48,320 --> 00:15:53,360
have a more powerful version of this: getting the
whole line, which is an IO action that returns a

00:15:53,360 --> 00:16:00,640
String, putting a String, and also a linefeed.
We give those functions a String, and they

00:16:02,320 --> 00:16:08,640
execute the command, and return nothing of
interest. Again, that's why this empty tuple type.

00:16:10,480 --> 00:16:14,640
This was for calculating Strings and there are
also polymorphic versions of this that work on

00:16:14,640 --> 00:16:21,840
other types, the reading of an Integer.
More abstractly, if Haskell the language

00:16:22,560 --> 00:16:25,920
by itself, or with the help of
libraries that the user has written,

00:16:27,120 --> 00:16:32,480
knows how to convert some type like Integer
or Trees or whatever, from and to Strings,

00:16:32,480 --> 00:16:37,360
then we can also use 'readLn' and the print
functions. They have these interesting

00:16:38,960 --> 00:16:45,760
constraints here. They are polymorphic. So, 'readLn'
says: I am an IO action, and I give you an (a),

00:16:45,760 --> 00:16:53,600
and I can do this for all (a) types with which the
language knows how to read. These are types like

00:16:53,600 --> 00:17:01,120
Integer, Bool, etc., and also user-defined types
if we have instructed the compiler to derive a

00:17:01,120 --> 00:17:06,880
reading method for this. But the main point here
is, for certain types, Haskell knows how to parse

00:17:06,880 --> 00:17:14,000
them from Strings into that type, and then we
can simply use 'readLn' instead of IO String,

00:17:14,000 --> 00:17:20,160
and we directly get, for example, Integer. And
conversely, for printing, if we have a type for

00:17:20,160 --> 00:17:26,960
which the language knows or can work out how it
should be shown, in the sense of transformed to

00:17:26,960 --> 00:17:31,600
a String, then we can directly call the print
function with a value of that type. It will do

00:17:31,600 --> 00:17:40,000
IO and print that value to the console. 'print'
is really a function. We give it an argument of

00:17:40,000 --> 00:17:45,840
some type that is "showable" (for example, type a,
if we have “Show a”) and then it does something.

154 # slide
00:17:48,240 --> 00:17:54,080
We need a way to combine these small IO
computations. We want to build more complex

00:17:54,080 --> 00:17:58,400
action sequences or whole programs based on these
IO primitives. It is not just with the ones from

00:17:58,400 --> 00:18:04,400
the previous slide. There we had printing and
reading from the console, from the keyboard,

00:18:04,400 --> 00:18:08,320
but of course, there are many more
primitives like writing to a file

00:18:08,880 --> 00:18:14,080
and opening a window and drawing something to
the screen. There are many IO primitives. I just

00:18:14,080 --> 00:18:18,480
showed you a very few of them on the previous
slide. And we will also not cover file IO in

00:18:18,480 --> 00:18:23,360
the exercises, but for all the things where
we would interact with the operating system

00:18:24,560 --> 00:18:30,800
with some effects, that would be an IO primitive.
These are the basic building blocks. We want to

00:18:30,800 --> 00:18:35,920
build from them more complex programs, and that's
where the do-notation comes into play. We already

00:18:35,920 --> 00:18:41,840
saw it in this hello-world-style program with just
three lines, but the general form is as follows.

00:18:42,640 --> 00:18:51,920
There is this do-keyword, and then, with
layout-based syntax, we give a sequence of

00:18:51,920 --> 00:18:59,440
commands that should be executed. These commands
are exactly the things that have an IO type like

00:18:59,440 --> 00:19:06,880
IO Int or something like that. Then, if we have
something which has an interesting return value,

00:19:06,880 --> 00:19:12,160
we can bind it to variables. That was
like: n gets its value from 'readLn' in the

00:19:13,200 --> 00:19:20,000
example program. We have our commands. They
have IO types. We can, but don't have to,

00:19:20,000 --> 00:19:25,280
bind the results to variables. And these
variables can be used. This is like reading

00:19:25,280 --> 00:19:33,040
something into a variable x2, then of course, all
later code can use this variable value x2. It is

00:19:33,040 --> 00:19:38,320
not like a let-block, where the things could
be mutually recursive. There is an order here.

00:19:38,320 --> 00:19:44,080
We can't use x2 in the first command because this
first command happens before this line. We have

00:19:44,080 --> 00:19:53,280
a sequential order, just as in line code in an
imperative language. These commands have IO types.

00:19:53,280 --> 00:19:57,600
If we bind something to a variable
(which we don't have to do, but we can),

00:19:58,480 --> 00:20:04,480
then this will be typed in the same way as a
type which was encapsulated in the command i.

00:20:04,480 --> 00:20:13,040
If the command i is IO Int, then the xi will be
Int. If the command i was IO Tree of something,

00:20:13,040 --> 00:20:20,480
then the xi will be Tree of whatever and
will be usable in the rest of the do-block.

155 # slide
00:20:30,400 --> 00:20:34,880
What about the do-block as a whole?
It also has an IO type. Otherwise,

00:20:34,880 --> 00:20:40,960
if we would assign a type like pure Int to it,
then there would be nothing to stop it from

00:20:40,960 --> 00:20:45,360
being used in pure code. Then we wouldn't
have this type-based separation between pure

00:20:46,240 --> 00:20:53,440
stuff and imperative looking stuff. So, the
do-block also has an IO type. And what type

00:20:53,440 --> 00:20:59,840
will it have? The one of the last command. So, if
we have n lines and command n would be something,

00:20:59,840 --> 00:21:03,280
then exactly this IO something would
be the type of the whole do-block.

00:21:04,800 --> 00:21:09,200
Then, if it is used somewhere else, then
of course if we get a value from it,

00:21:09,200 --> 00:21:14,720
then it will be the value that the last command
that the original do-block created. Let's say

00:21:14,720 --> 00:21:20,560
it's in a function and that function is called,
then if we access the encapsulated value, it

00:21:20,560 --> 00:21:28,320
would be of whatever the command n was producing
inside. In the do-block itself, the last command

00:21:28,320 --> 00:21:34,880
n doesn't have a binding variable. So, there is no
point in having “xn is drawn from command n” and

00:21:34,880 --> 00:21:39,040
that's the last line of that do-block because
we couldn't do anything with the xn anymore.

00:21:39,040 --> 00:21:44,160
Remember that the variables are usable in the
rest of the do-block. So, for the last line, it

00:21:44,160 --> 00:21:48,800
doesn't make any sense. The last line will always
simply be a command without a binding variable.

00:21:52,000 --> 00:21:57,520
Often, at the end of the do-block, it's useful
to have a function which doesn't have an actual

00:21:57,520 --> 00:22:04,960
effect. It simply encapsulates a pure
value in an IO type. And for this, the

00:22:05,520 --> 00:22:11,040
function “return” is used. It is a predefined
function that comes with do-blocks, and it's

00:22:11,040 --> 00:22:16,720
polymorphic. We can give it a value of whatever
type, and from this, it makes a command type IO

00:22:17,280 --> 00:22:25,360
that type. And the effect of this IO command will
be no effect at all, but the encapsulated value

00:22:25,360 --> 00:22:30,960
is the one that was handed to the return function.
So, there isn't any actual action IO going on

00:22:31,520 --> 00:22:37,840
if “return something” command is executed. It's
not a return like in C which somehow aborts

00:22:38,480 --> 00:22:43,200
execution of the function. So, if we
have a do-block with several lines,

00:22:43,200 --> 00:22:48,720
and somewhere in the middle in the 3rd or 10th
line, we have a return call, this doesn't mean

00:22:48,720 --> 00:22:55,360
that we abort the computation. It simply means
that some value is produced and encapsulated at

00:22:55,360 --> 00:23:01,200
that point. It might be bound to a variable.
Return is not changing the control flow,

00:23:01,200 --> 00:23:08,720
it's just a way to embed a pure value into this
IO domain, so it can be used inside do-blocks,

00:23:09,520 --> 00:23:13,760
or particularly often, at the end of the
do-block, if we want to return some value

00:23:13,760 --> 00:23:19,680
that we have computed from previously wrapped
inputs, for example, to the caller of the block.

00:23:21,280 --> 00:23:27,360
So, that's how we encapsulate a pure
value into IO. We could ask ourselves,

00:23:27,360 --> 00:23:32,880
what about the converse? Can I also have
a function which doesn't go from a to

00:23:34,560 --> 00:23:39,120
IO a, but maybe the other way around? Then I could
have a do-block which has IO whatever type, and

00:23:39,120 --> 00:23:43,520
I want to have the thing inside. So, maybe I want
to have something like the opposite of this return

00:23:43,520 --> 00:23:51,040
function, which goes from IO something to just the
encapsulated type. But that's not allowed. That's

00:23:51,040 --> 00:23:56,560
the whole point of this type separation. It is to
make sure that pure code is not somehow messing

00:23:56,560 --> 00:24:04,560
with effects or is somehow destroyed by effectful
code. It's not possible to have a function that

00:24:04,560 --> 00:24:13,040
goes from IO a to a. Never ever at all. It is not
allowed. It is prevented. The only way to access

00:24:13,760 --> 00:24:19,840
things encapsulated in IO something values
is this explicit sequentialization and this

00:24:19,840 --> 00:24:26,720
binding via variables within do-blocks. There
is no other way to get the value from inside

00:24:26,720 --> 00:24:32,240
an IO computation. If we could do this, then we
would be in the world of ugly imperative programs

00:24:32,240 --> 00:24:38,720
where inside an expression which looks pure,
suddenly, some effect or behavior is taking place

00:24:38,720 --> 00:24:44,080
and all the guarantees are gone… the guarantees
that we would otherwise rely on in reasoning

00:24:44,080 --> 00:24:50,240
about code. When I say something like never
ever at all, there is probably some exception.

00:24:50,240 --> 00:24:56,240
And there is. There are unsafe features that we
are not able to access because we really have

00:24:56,240 --> 00:25:00,800
to tell the compiler that we want to allow these
unsafe features. And then there is a workaround.

00:25:00,800 --> 00:25:06,160
We can do things like this: accessing something
from inside, but even these functions are

00:25:06,960 --> 00:25:13,280
called unsafe and they are not to be used
by a normal Haskell programmer. Sometimes,

00:25:13,280 --> 00:25:18,480
if we write a specific very low-level library,
we might have to use this because we want to

00:25:18,480 --> 00:25:26,480
manipulate stuff very directly. But for normal
user code, what I say here is the truth.

00:25:27,760 --> 00:25:34,480
That is for system programmers to circumvent these
guarantees, but not for normal Haskell code. The

00:25:34,480 --> 00:25:41,840
compiler can actually prevent use of these unsafe
features. And in our Autotool, we do prevent this.

00:25:46,000 --> 00:25:55,840
More examples like on the previous slide will be…
More examples where you see how these do-blocks

00:25:55,840 --> 00:26:01,760
work in practice will be in the exercise tasks
of course. But also if you look at the collection

00:26:01,760 --> 00:26:07,680
document, the PDF that is in the Moodle course
from previous year's exercises, you will also find

00:26:08,240 --> 00:26:14,960
more complex examples than the main read, print
product function that I have shown here so far.

156 # slide
00:26:20,160 --> 00:26:26,800
Finally, and also to finish up, let me return
to this point about using abstraction concepts.

00:26:26,800 --> 00:26:32,080
in the context of IO computations, like
polymorphism, higher-order-ness, etc.

00:26:32,080 --> 00:26:37,120
Let me discuss this on the question of what
we should do in terms of control structures.

00:26:37,840 --> 00:26:44,720
Control structures like loops, while, for,
do-while, that you know from imperative languages

00:26:45,280 --> 00:26:48,400
because, after all, now that
we have do-blocks, which I

00:26:48,400 --> 00:26:55,280
explained are like a straight line and sequential
code, like a block in a language like C or Python,

00:26:55,840 --> 00:26:59,520
it would be natural to ask: what about
other control structures? or at least,

00:27:01,200 --> 00:27:06,400
control structures at all like the while-loop?
Once we have blocks of this form, we can't write

00:27:06,400 --> 00:27:11,440
a while-loop around such a block? We don't want to
just have sequential code, we want to have loops.

00:27:13,040 --> 00:27:18,080
Now, we should also introduce a loop keyword
into Haskell. There are no loop keywords.

00:27:18,080 --> 00:27:24,160
There is no while. There is a do, but no
while. Why isn't there? Isn't that too few

00:27:24,720 --> 00:27:30,560
features? No, it's not. And why not? Because
something like a while is user-defined in Haskell.

00:27:30,560 --> 00:27:36,880
We don't need to have the compiler support a
while-loop because we can already implement it

00:27:36,880 --> 00:27:44,080
as a higher-order function. That's how this would
look like. Let me talk through this in a minute.

00:27:44,080 --> 00:27:49,440
Let me motivate this first by saying: it's almost
like the divide-and-conquer skeleton that appeared

00:27:49,440 --> 00:27:54,320
in the exercises. We had a higher-order
function which was polymorphic, and the

00:27:54,320 --> 00:28:00,480
idea was that it is abstracted from the concept of
a divide-and-conquer algorithm. And by providing

00:28:00,480 --> 00:28:07,040
different instantiations of the type and
of the function arguments, we then created

00:28:07,760 --> 00:28:12,880
different divide-and-conquer computations. And the
same idea applies here. Why doesn't there need to

00:28:12,880 --> 00:28:17,600
be a keyword which is supported by the compiler?
It can simply be a higher-order polymorphic

00:28:17,600 --> 00:28:22,960
function. It's like a skeleton, but not for divide
and conquer, but for the concept of while-looping.

00:28:23,760 --> 00:28:29,760
What are the conceptual ingredients
of a while-loop? Some start value

00:28:30,720 --> 00:28:38,800
for the loop variable, then some predicate on
that loop variable and we want to repeat the

00:28:38,800 --> 00:28:47,680
loop as long as this predicate is True for the
current value, because it is while. And we have

00:28:47,680 --> 00:28:53,840
to provide the body. That would be the syntactic
block in the imperative code, where we say: while

00:28:55,040 --> 00:29:01,280
condition on the loop variable, and what should
be done while this is True? Some code. And this

00:29:01,280 --> 00:29:08,000
code now will simply be a do-block… a piece of IO
code which of course depends on the current value

00:29:08,000 --> 00:29:13,760
of the loop variable. This is a function from
the current value, initially the original value,

00:29:13,760 --> 00:29:19,280
but then later maybe different values,
because the loop body can change the value

00:29:19,280 --> 00:29:25,520
of the loop variable. And what is the loop body
doing? It is doing some IO code, a do-block, where

00:29:25,520 --> 00:29:30,400
we do prints and reads or whatever, and then,
of course, it returns the new value of the loop

00:29:30,400 --> 00:29:39,040
variable. That's how the change happens. Overall,
we get an IO computation because this will be

00:29:39,040 --> 00:29:44,800
effectful. That is explaining the type.
What about the definition? We have to have

00:29:45,360 --> 00:29:50,800
a few arguments, so, the start value, the
predicate of this type, and the actual body. And

00:29:50,800 --> 00:29:58,560
then how is it defined? It implements the idea
that a while-loop can always be expressed by a

00:29:58,560 --> 00:30:06,640
recursion. This interaction/analogy of recursion
and dropping iteration and recursion is something

00:30:06,640 --> 00:30:11,120
that you should know from some theory lectures,
probably the "Berechenbarkeit und Komplexität".

00:30:11,120 --> 00:30:16,400
It was discussed on an abstract level that
recursive algorithms and iterative algorithms

00:30:16,400 --> 00:30:23,920
are equivalent, if you want a proof. We don't
need iterative concepts like while-looping as a

00:30:23,920 --> 00:30:29,280
language construct in Haskell because it is easily
expressed with recursion. That's what's happening

00:30:29,280 --> 00:30:34,080
here. We define a recursive function which will
have a current value. And of course initially,

00:30:34,080 --> 00:30:40,400
this is called with the start value for the while
variable, then we check the predicate. Here we

00:30:40,400 --> 00:30:44,480
make use of this function argument. Because it is
a higher-order function, we get the function as an

00:30:44,480 --> 00:30:49,680
argument. The p, the predicate, it is applied
to the current value of the loop variable.

00:30:49,680 --> 00:30:54,000
Then, this can be True or not. If it's not True,
then that means we should stop the while-loop.

00:30:54,000 --> 00:30:58,960
In that case, we run into the else-branch
here. What do we do? We simply want to return

00:30:58,960 --> 00:31:04,160
the current value of the loop variable, but we
cannot simply write x here because that then would

00:31:04,160 --> 00:31:09,680
be an (a), and not an (IO a). That's where the
return function gets used. It is used to embed

00:31:09,680 --> 00:31:18,800
the current value, which is a pure (a) value, into
an IO context. Because that's what the outcome of

00:31:18,800 --> 00:31:24,320
the "while" should be, an IO something.
That's if we entered the end of the loop

00:31:25,200 --> 00:31:31,920
once the predicate does not hold anymore. And while
the predicate is still holding, we do the first option

00:31:31,920 --> 00:31:36,880
here… the first variant here. What is it doing?
It's calling the body, which is an arbitrary

00:31:36,880 --> 00:31:41,040
function. So, it will probably be implemented
with a do-block or maybe with another while-loop.

00:31:41,840 --> 00:31:48,880
We execute this body on the current value. That
will probably perform some IO actions depending

00:31:48,880 --> 00:31:52,240
on what the body is. If the body contains
prints and reads, then this will happen now.

00:31:53,520 --> 00:32:01,200
Then this will have an output. This is bound to
the variable x' (x prime) or y or whatever, so,

00:32:01,200 --> 00:32:07,280
some new variable. And then, we call the loop
function again, but with this new value for the

00:32:07,280 --> 00:32:14,640
current loop variable. This will run here again.
It will check the predicate on this x'. This could

00:32:14,640 --> 00:32:20,240
be True or not. If it is not True, then the x' is
returned. Otherwise, the body is executed again,

00:32:20,240 --> 00:32:28,080
but now, with the current x'. This implements
this while-construct without needing to edit

00:32:28,720 --> 00:32:33,520
the language. It is not something the compiler has
to do. The user can do this. This is completely

00:32:33,520 --> 00:32:38,160
user-defined. So, if you have other control
structures in mind… other loop types or a slightly

00:32:38,160 --> 00:32:43,040
different behavior for loops, then you are free
to write your own functions for this. Of course,

00:32:43,040 --> 00:32:48,960
there are already libraries with such functions
such as control structures that people have found

00:32:49,680 --> 00:32:53,360
interesting and useful. So, we don't
always have to do it ourselves. But we are

00:32:53,360 --> 00:33:00,560
completely free because we have control over
abstraction using polymorphism and higher-order.

00:33:02,320 --> 00:33:07,920
How could this be used then? Let's assume this
function is given; we have actually imported it

00:33:07,920 --> 00:33:14,320
from some library of useful looping functions,
then we could write very short code like this

00:33:14,320 --> 00:33:20,720
where we want to say something like: I want to
start a while-loop with the original value zero,

00:33:20,720 --> 00:33:26,320
the predicate is the section “smaller than ten”
(<10). So, we want to do this while the current value

00:33:26,320 --> 00:33:31,280
is still smaller than 10. So, that's like a
while-loop where the loop breaking condition is,

00:33:31,920 --> 00:33:38,160
say we start a variable n; n is equal to zero,
and then while n is smaller than 10, do whatever.

00:33:39,040 --> 00:33:43,760
What we want to do is expressed in the body.
It's a function. We use the lambda abstraction

00:33:43,760 --> 00:33:49,200
because it depends on the current loop variable,
called n here. And what is it then doing? It's doing

00:33:49,200 --> 00:33:56,640
a do-block, and the first thing is to print the
current value, and then to hand over to the next

00:33:56,640 --> 00:34:03,040
loop iteration with an increased value…
incremented by one for the loop variable.

00:34:03,040 --> 00:34:10,720
What would this do? It would print the numbers
from zero to nine because it starts with zero and

00:34:10,720 --> 00:34:16,480
while the current value is smaller than ten, it
prints it and increments it by one. That would be

00:34:16,480 --> 00:34:24,000
like a short while-loop syntactically written in
C, where the body is to print and then increment

00:34:24,000 --> 00:34:34,240
the current value. Now, this is just another
function application. And if we have different

00:34:34,240 --> 00:34:44,160
loop functions, then we can use
them like a control structure.
