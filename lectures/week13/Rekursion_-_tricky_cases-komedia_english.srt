106 # slide
00:00:00,000 --> 00:00:07,590
We have just seen our first recursive
Prolog programs, and for the first time we have explicitly

00:00:07,590 --> 00:00:14,880
in them. In the video
to discuss some aspects here. The headline

00:00:14,880 --> 00:00:20,280
here says, "potential problems with recursion".
Not because recursion is problematic per se, but

00:00:20,280 --> 00:00:24,810
because it can sometimes be a bit tricky to use,
and you also have to think carefully when and

00:00:24,810 --> 00:00:31,560
how to use it. That's what I do here with an
old example exercise first. Maybe you would like to

00:00:31,560 --> 00:00:38,970
pause the video for a moment and read through this at your leisure.
This is an exercise that I used in my English language

00:00:38,970 --> 00:00:44,520
course, where it was also about Prolog.
That's why it's worded in English.

00:00:44,520 --> 00:00:49,770
Ultimately, the point is that we have such a database of
facts about points in the plane. So, not mother, father

00:00:49,770 --> 00:00:59,220
child, Klaus, Anja, Thorsten, but A, B, C etc. were
points, and we have information that there is a

00:00:59,220 --> 00:01:05,640
relationship, lines between them. We should
write predicates to describe triangles and quadrilaterals.

00:01:05,640 --> 00:01:12,540
One more important clue is given,
namely, that a line from A to B is, of course, also

00:01:12,540 --> 00:01:17,190
a line from B to A. But in
the facts, this is not necessarily expressed.

00:01:17,190 --> 00:01:21,810
Here it is written: Line from A to B.
And this is to be treated, therefore, with the description

00:01:21,810 --> 00:01:28,920
of the three triangles and quadrilaterals, that of course one can also go
from B to A with a connection.

00:01:28,920 --> 00:01:33,570
But also without that being explicitly expressed in the facts.
So, the task was a little bit, how to bring that then into your

00:01:33,570 --> 00:01:41,130
description. A possible solution
would be as follows: It is described what a triangle is.

00:01:41,700 --> 00:01:47,760
For three points X, Y, Z we have a triangle if
we have a connection from X to Y, from Y to Z, and

00:01:47,760 --> 00:01:52,650
from Z to X, and also none of these two points can be equal
because it was already assumed here that

00:01:52,650 --> 00:02:00,780
the line predicate does not somehow call the same point twice.
And for quadrilaterals, of course, you need four parameters.

00:02:00,780 --> 00:02:07,440
And then you need a line from X to Y, Y to Z,
Z to U, and U to X. Here it must be additionally required

00:02:07,440 --> 00:02:12,060
that X and Z are different and Y and U are different
because otherwise you could get some degenerate quadrilaterals,

00:02:12,060 --> 00:02:18,570
where several points coincide, and that alone
by the fact that there is no line from A to A

00:02:18,570 --> 00:02:23,820
is not excluded. This would be a sensible program
which one could imagine here.

00:02:23,820 --> 00:02:31,590
It also follows approximately my rule of thumb that
we always place negative information/negative literals

00:02:31,590 --> 00:02:39,690
as far as possible to the end of our rules
if such a thing occurs. This was kept here.

00:02:39,690 --> 00:02:47,400
There we can say: all is well. Well, this is only an attempt.
This is not yet the solution. Why not?

00:02:47,400 --> 00:02:54,960
Because this aspect was ignored, that here, for example,
does not mean that there is a line from B to A.

00:02:54,960 --> 00:02:59,370
And therefore certain triangles and quadrilaterals,
which would be there in the plane itself, if one draws in the

00:02:59,370 --> 00:03:04,050
points and draws the connections,
would not be supplied by these predicates.

00:03:04,050 --> 00:03:10,410
So, we would have to add here still line B to A explicitly to the fact base.

00:03:10,410 --> 00:03:14,700
But we do not want to do that.
We assume that this fact base is given and

00:03:14,700 --> 00:03:19,710
we are supposed to write predicates and queries, and we are
not allowed to change that here. So then we have to do it in the program.

107 # slide
00:03:19,710 --> 00:03:26,460
And not just in these facts, but in any rules.
Now it would be tempting then to just say,

00:03:26,460 --> 00:03:33,750
that whenever there is a line from X to Y,
there is also a line from Y to X.

00:03:33,750 --> 00:03:40,260
This would ensure that to this case line(a,b)

00:03:40,260 --> 00:03:47,520
would be implicitly added: line(b,a).
From a logical point of view, it would be a very clever formulation

00:03:47,520 --> 00:03:56,280
to express this symmetry of this line relation
and then simply work with these rules in the normal way,

00:03:56,280 --> 00:04:03,930
because then these line literals would refer to the
predicate, where this symmetry would also be

00:04:03,930 --> 00:04:14,640
this symmetry is justified or used.
However, if we are going to carry this out, it

00:04:14,640 --> 00:04:20,280
turns out to be dangerous. In a certain sense, this is
too recursive. At first, this may be confusing or

00:04:20,280 --> 00:04:25,500
surprising why there is a problem here
because if we go back to our rules of thumb

00:04:25,500 --> 00:04:32,040
forrecursion (which were these rules), then
all of them are fulfilled in this example.

00:04:32,040 --> 00:04:37,410
So, there must be at least one base case.
If line is now our recursive predicate,

00:04:37,410 --> 00:04:43,770
then it has several base cases, namely, this line(a,b),
line(b,c), all these facts. These are base cases.

00:04:43,770 --> 00:04:48,300
The base cases should be listed first.
So in the program the base cases should come first and then

00:04:48,300 --> 00:04:53,700
any recursive rules. That would be given in this case
if we wrote this line(X,Y), line(Y,X), this rule at the very end

00:04:53,700 --> 00:04:59,940
of the program or at first below these
whole line facts. And also this third rule,

00:04:59,940 --> 00:05:05,280
namely, in the rules for the non-base cases,
which would be now only our one rule line(X,Y), line(Y,X),

00:05:05,280 --> 00:05:12,600
the recursive calls should come as far back as possible.
This was also fulfilled in the example because

00:05:12,600 --> 00:05:19,680
this rule looked like this. So one could assume that
everything is already in order. However, if we run this,

00:05:19,680 --> 00:05:25,740
because of depth-first search, we could also start to plot the derivation tree,
then we would find that this is too recursive in the sense

00:05:25,740 --> 00:05:30,660
that we would never find a
solution. The reason is ultimately

00:05:30,660 --> 00:05:37,590
that from line(X,Y) and line(Y,X) this relationship could be
could constantly jump back and forth. So, if one

00:05:37,590 --> 00:05:42,750
knows line(a,b), then you also know line(b,a), then you also know line(a,b), ...
So, this becomes such a circular argument here,

00:05:42,750 --> 00:05:48,030
where the calculation goes around in circles instead of
that we actually work with these

00:05:48,030 --> 00:05:56,610
predicates. At least there is the danger
that with certain queries problems arise with

00:05:56,610 --> 00:06:04,290
such a rule because simply here
not enough progress is made during the calculation

00:06:04,290 --> 00:06:12,150
because we're always going in circles, so to speak, with this rule.
If we have applied the other rule once, we could apply it directly

00:06:12,150 --> 00:06:18,240
again because there are only variables. Also,
we couldn't do that here. That means that this

00:06:18,240 --> 00:06:23,190
would actually be an example which argues against recursion.
The warning here is that you should not

00:06:23,850 --> 00:06:28,840
should/must not always resort directly to recursion.
Here there is a better solution to achieve this symmetry.

00:06:28,840 --> 00:06:33,730
to achieve. And finally, the idea is already
similar to the one here, that you have to express this symmetry

00:06:33,730 --> 00:06:39,910
but you don't do it by using the line predicate itself.
adding symmetry to the line predicate itself,

00:06:39,910 --> 00:06:44,980
but one introduces a new predicate.
One further assumes: There is this line predicate,

00:06:44,980 --> 00:06:50,740
for which the facts are given, which concrete points are
connected and based on this

00:06:50,740 --> 00:06:56,740
line predicate, one defines a
new predicate for symmetric connections.

00:06:56,740 --> 00:07:01,930
So, where both directions are considered.
And this cannot happen recursively. You don't have to

00:07:01,930 --> 00:07:10,540
connect line to line or derive them from each other, but one says:
If there is a connection from X to Y,

00:07:10,540 --> 00:07:15,010
then there is also a symmetrical connection from X to Y.
This means in particular that there is also

00:07:15,010 --> 00:07:19,570
a symmetric connection in the opposite direction.
So, the line predicate, for "symmetric line",

00:07:19,570 --> 00:07:29,170
would guarantee, so to speak, the complement,
that to each predicate/ each fact,

00:07:29,170 --> 00:07:35,260
which is given for the line predicate, also the
symmetric fact holds. Then one would simply

00:07:35,260 --> 00:07:43,510
the actual interesting queries for triangles,
quadrilaterals pass on this symmetric line predicate.

00:07:43,510 --> 00:07:51,820
That would have been the solution to the exercise problem in that case.
That is, here the solution would have been

00:07:51,820 --> 00:07:56,350
to do without recursion, although it
may seem tempting at first,

00:07:56,350 --> 00:08:07,320
to express the symmetry closure in this simple way.
So, this is in a certain sense

00:08:07,320 --> 00:08:13,500
a negative example of recursion. We have already
seen positive examples. Therefore, as

00:08:13,500 --> 00:08:21,180
further and also from
another course as an exercise,

108 # slide
00:08:21,180 --> 00:08:28,530
let's take this example. We assume that we have
cities as our entities, about which

00:08:28,530 --> 00:08:34,110
we talk about: Frankfurt, San Francisco, whatever.
And we have such a database of facts here.

00:08:34,110 --> 00:08:37,290
And these are direct connections, let's say air connections.
So, there's a direct connection from Frankfurt to San Francisco.

00:08:37,290 --> 00:08:44,370
From Frankfurt to Chicago, etc. Here are only
four examples, but of course, a flight schedule could be covered, so to speak.

00:08:44,370 --> 00:08:49,410
be covered. We would like to know which
connections there are if we also allow stopovers.

00:08:49,410 --> 00:08:55,620
We can say that this is something similar to the parents and the ancestors,
like that with the parents and the ancestors.

00:08:55,620 --> 00:09:01,350
Again, we would like to basically
calculate a transitive envelope.

00:09:01,350 --> 00:09:06,330
We want to say, if there is a direct connection from
X to Y, then there is also an arbitrarily long connection from X

00:09:06,330 --> 00:09:14,010
to Y. There is also a connection from X to Y,
if it is not only direct, but we can get from X

00:09:14,010 --> 00:09:20,100
directly to Z and then from Z in any number of
steps to Y. So this is very similar to the situation

00:09:20,100 --> 00:09:27,240
with the parents. That would correspond to the direct
here, and ultimately to the forward, that is

00:09:27,240 --> 00:09:33,270
which is connected via several steps by a parent relationship
or in this case, being connected via several steps

00:09:33,270 --> 00:09:42,150
by direct connection, one would mean
has a general connection from X to Y.

00:09:42,150 --> 00:09:48,480
We can execute that. Ask for some examples.
Just try it. Can we get from Frankfurt to Maui?

00:09:48,480 --> 00:09:59,010
The answer is yes because that just follows from the facts.
San Francisco → Honolulu → Maui goes. So true comes out here.

00:09:59,010 --> 00:10:04,320
Or we could ask, "Where do we go from San Francisco?"
And then Prolog would have to find all the solutions.

00:10:04,320 --> 00:10:09,330
Namely, not only do we get from San Francisco to Honolulu
because there is a direct connection, but also

00:10:09,330 --> 00:10:14,850
this indirect way/this multistep way.
That should also come as an answer that X can also be Maui,

00:10:14,850 --> 00:10:19,940
because we can get from San Francisco by
this recursive rule and double application

00:10:19,940 --> 00:10:28,550
of direct, we can also get from San Francisco to Maui.
by this recursive rule. We can also ask, for example:

00:10:28,550 --> 00:10:35,120
"Are we going to get anywhere from Maui?" And the answer would be
false, because (regardless of which of the two rules is used)

00:10:35,120 --> 00:10:40,610
we cannot somehow achieve or show
we can get anywhere from Maui.

00:10:40,610 --> 00:10:45,470
Simply because there is no direct connection from Maui to anywhere.
In this specific example. That would be now again

00:10:45,470 --> 00:10:56,180
asymmetric connections coincidentally so
formulated. All good, apparently. Why all good?

00:10:56,180 --> 00:11:01,520
Because we have stuck to the rules of thumb.
There is at least one base case for the

00:11:01,520 --> 00:11:08,210
connection predicate. The base case comes
first, before any recursive cases.

00:11:08,210 --> 00:11:17,270
And in the recursive rule, the recursive call is
made as late as possible. Just to make sure,

109 # slide
00:11:17,270 --> 00:11:21,560
that this is really important, let's just look again at the
example again, if we were to change this order

00:11:21,560 --> 00:11:25,220
would change. Now, I've changed here at the same time both
the order of these two rules,

00:11:25,220 --> 00:11:31,880
the base case as the second, as well as in the recursive
case, the order of the two

00:11:31,880 --> 00:11:39,830
calls. So, I have played around with the order
of and in rules. And that leads immediately

00:11:39,830 --> 00:11:45,920
(in the example at least) to one of these said errors.
In this case, also such a stack overflow error.

00:11:45,920 --> 00:11:52,460
So, Prolog would give up here and not find a solution.
That again to the reminder, why these

00:11:52,460 --> 00:11:58,370
rules/the rules of thumb are really useful
and you should consider them when writing

00:11:58,370 --> 00:12:06,530
Prolog programs, including recursive programs.
This is no different than

00:12:06,530 --> 00:12:14,480
the parent and ancestor example, except that we don't explicitly
provoked such an error once.

00:12:14,480 --> 00:12:20,180
I had mentioned this only at the statement-logical
example, that we can get problems, if we do not pay attention

00:12:20,180 --> 00:12:31,360
we are not careful with recursion. Solved the problem here?
Well, maybe not completely. Namely, we can use this

00:12:31,360 --> 00:12:37,390
example (different from the ancestor example) a little bit more
complicated, if we make sure,

00:12:37,390 --> 00:12:45,280
that the basic facts, the underlying facts,
the database, so to speak, itself contains cycles.

00:12:45,280 --> 00:12:50,530
So, if there are cycles in the data. What do I mean by that?
Let's imagine that among these direct connections there was

110 # slide
00:12:50,530 --> 00:12:56,020
the possibility of flying in circles. So we
take the same program. So, the program that was here,

00:12:56,020 --> 00:13:04,750
where there were no problems, and I'll add
a few other facts. Here I have five direct facts.

00:13:04,750 --> 00:13:10,990
They don't have to be the same as before.
In any case, there are more. And I ask again, what connection

00:13:10,990 --> 00:13:15,580
is there? Or I define based on this
the connections. And now I can start a query here.

00:13:15,580 --> 00:13:19,540
which will be problematic. Namely,
if I now ask myself where I could go from

00:13:19,540 --> 00:13:24,490
San Francisco, then I get told Honolulu,
Maui, San Francisco, Honolulu, Maui, San Francisco,

00:13:24,490 --> 00:13:32,470
Honolulu, Maui, etc. So, this is where an endless search would happen.
Prolog would keep giving the same three answers,

00:13:32,470 --> 00:13:39,880
but also never say, "That's enough."
Why is that? Although I did follow the

00:13:39,880 --> 00:13:47,560
rules for the use of recursion here, the problem here is that
the problem is here,

00:13:47,560 --> 00:13:54,040
that there is now a circularity problem in the data.
It is just the case that if I allow here arbitrary

00:13:54,040 --> 00:14:00,340
direct facts, it can be that there are also possible round
trips possible and they are not

00:14:00,340 --> 00:14:05,710
treated in any special way. This could of course
not occur with the ancestor relation, out of

00:14:05,710 --> 00:14:09,850
the domain knowledge. We know that there are
no circular ancestor relations.

00:14:09,850 --> 00:14:17,560
Nobody is his own parent or is
the parent of the parent of himself or something.

00:14:17,560 --> 00:14:26,290
So, that's where that was, so we could work that way,
because there was nothing in the data that was dangerous ...

00:14:26,290 --> 00:14:34,690
circular relationships in the data.
Here it is like that. This does not mean that recursion is

00:14:34,690 --> 00:14:40,300
bad per se. It just means that we have to
be a little more careful. So, we could

00:14:40,300 --> 00:14:48,550
think about it, or I have described an
approach on the next slide. And I will show you

00:14:48,550 --> 00:14:57,820
how we can avoid this endless search.
The basic idea is simple,

00:14:57,820 --> 00:15:03,610
that we have to make sure that we notice when we are
flying in circles, so to speak. So for example

00:15:03,610 --> 00:15:08,440
notice here when we say: "We are coming from
San Francisco to San Francisco." that this is not particularly

00:15:08,440 --> 00:15:15,040
interesting or that we should at least say,
OK, but then it's good.

00:15:15,040 --> 00:15:19,810
And then we don't try to get on again because
then we would only come back to Honolulu and Maui,

00:15:19,810 --> 00:15:24,670
to which we also came directly from San Francisco.
That means somehow we would have to make sure

00:15:24,670 --> 00:15:30,310
that the search stops when we arrive at a
stopover, which is not an interesting stopover at all because

00:15:30,310 --> 00:15:36,700
we have already been there.
Maybe even started there.

00:15:36,700 --> 00:15:44,170
That is not included here in this simple program
as knowledge. That will be our bridge to the

00:15:44,170 --> 00:15:50,320
use of further data structures.
Namely, lists in Prolog. And namely, we could

00:15:50,320 --> 00:15:54,910
remember where we have already been. And that is not enough
to remember a place where we have already been,

00:15:54,910 --> 00:15:59,350
This could be a very large flight plan, where there are many
possible stopovers. We have to

00:15:59,350 --> 00:16:04,390
actually remember where we have already been everywhere.
So, we must, if we build up such a connection,

00:16:04,390 --> 00:16:09,430
we have to remember all the stopovers we've already visited ...,
to make sure that we don't go to any of them...

111 # slide
00:16:09,430 --> 00:16:16,600
twice. Here's what that might look like:
I'll explain the individual parts in a moment.

00:16:16,600 --> 00:16:21,910
The basic idea: We remember the stopovers we have already
and since there can be several of them, we

00:16:21,910 --> 00:16:29,470
remember them in a list.
List notation (I had already shown it on a slide)

00:16:29,470 --> 00:16:36,490
is in Prolog with such square brackets. So [X] means:
A list with one element X. And then there are

00:16:36,490 --> 00:16:39,670
certain predicates that operate on lists, which I will
discuss in a moment. So, what's the idea here?

00:16:42,600 --> 00:16:48,630
Again, we'll assume we have our facts here. These could be the
five from here. But they could be others or

00:16:48,630 --> 00:16:55,230
many more. The point is:
Any direct connections should be available here

00:16:55,230 --> 00:17:02,280
and nevertheless our connection search should
not fall into such endless searches.

00:17:02,280 --> 00:17:09,390
And a bit like the line and sline example,
the solution here is

00:17:09,390 --> 00:17:14,610
that we introduce another predicate, an auxiliary predicate.
There, we had done that by adding this

00:17:14,610 --> 00:17:20,820
symmetric line predicate based on the
normal line predicate.

00:17:20,820 --> 00:17:26,010
Here the solution is that we generalize our connection predicate,
so to speak, specifying a variant of it,

00:17:26,010 --> 00:17:34,860
which carries such an intermediate list.
I'll call this connection1 now, lacking imagination,

00:17:34,860 --> 00:17:40,950
what else I could call it. So, our goal will be:
We do not define connection recursively,

00:17:40,950 --> 00:17:46,080
but we define connection1 recursively.
Connection simply calls connection1.

00:17:46,080 --> 00:17:50,850
Connection1 is more general than connection, in the sense that
it carries a list of intermediate stations.

00:17:50,850 --> 00:17:57,330
The normal search for a connection from X to Y
would then be: "Search for connections in this

00:17:57,330 --> 00:18:03,480
more general sense from X to Y, but note that in
that you have already been to X because that is where you

00:18:03,480 --> 00:18:10,020
are flying out of. So, you're not interested in visiting X again
as a stopover."

00:18:10,020 --> 00:18:14,850
If we have this intuition about what connection1 should do,
we can specify rules for it.

00:18:14,850 --> 00:18:19,920
This is going to be recursive. So, we should have a base case.
The base case should come first because our rules of thumb say so.

00:18:19,920 --> 00:18:25,740
What would be the base case? For the base case, if there
is a direct connection, we can say:

00:18:27,300 --> 00:18:34,050
Then we don't care about intermediate stations. So we had here
connection applies if direct applies. This is also true for connection1.

00:18:34,050 --> 00:18:40,650
So if there is a direct connection from X to Y, then there is a
connection (in this more general sense) from X to Y.

00:18:40,650 --> 00:18:47,070
And we do not care what the
list of previously visited intermediate stations is,

00:18:47,070 --> 00:18:52,740
because we do not go to any new intermediate stations.
We come from X to Y, and it doesn't matter where we have been before

00:18:52,740 --> 00:18:58,490
and this does not prevent us from taking this
direct connection. So for the

00:18:58,490 --> 00:19:05,450
base case, nothing interesting has changed at all.
Now the interesting case, the recursive case.

00:19:05,450 --> 00:19:12,800
Here we have said there is a connection from X to Y,
if one comes from X to some Z directly and then from Z

00:19:12,800 --> 00:19:18,950
in any number of steps further to Y.
And there could arise such a cycle if the Z

00:19:18,950 --> 00:19:26,090
has already been seen once and is now simply
approached. Now this intermediate list is used.

00:19:26,090 --> 00:19:33,200
That is, we know we want to go from X to Y
and any destinations that are L in this list,

00:19:33,200 --> 00:19:38,780
we want to avoid as an intermediate stop. That's why we started here
and said: We avoid the starting point as a stopover at the beginning.

00:19:38,780 --> 00:19:44,390
the starting point as a stopover. And of course
this list can be even bigger. The further we travel,

00:19:44,390 --> 00:19:51,470
the more stopovers we have to avoid in the future.
avoid. So, we want to travel from Y to Y and avoid stopovers.

00:19:51,470 --> 00:19:57,920
in L. How do we do that? Well, either directly, it says up here,
or we have to fly from X to an intermediate station.

00:19:58,460 --> 00:20:06,080
So, there would have to be a Z, so we can get from X to Z.
Now we want Z not to be an intermediate station,

00:20:06,080 --> 00:20:11,600
which we have already seen. That is, we require, for this Z,
which we would achieve directly here, that it is not

00:20:11,600 --> 00:20:18,320
part of the already seen list of intermediate stations.
It is not part of the list of already seen interstates.

00:20:19,460 --> 00:20:25,070
That is (I will introduce this) there is a predicate member.
This simply checks if a thing is in a list.

00:20:25,070 --> 00:20:30,710
In that case, we would check: Does the Z occur in L?
And only if it doesn't,

00:20:30,710 --> 00:20:38,120
we want to continue. That is, we require that the Z,
which we are directly addressing, is not a member, i.e., an element

00:20:38,120 --> 00:20:46,295
of the list L. Then we would be
allowed to continue a new connection, from Z to Y.

00:20:46,295 --> 00:20:54,440
It would be tempting here to say, "Then connection1 from Z to Y."
However, we also need to say what the

00:20:54,440 --> 00:20:58,880
new list of intermediate destinations. We now need to
expand it here. Because up to now we had

00:20:58,880 --> 00:21:03,590
seen the intermediate targets in L. Now we have decided to go to Z
to go to. That is also okay because Z does not yet occur in L.

00:21:03,590 --> 00:21:08,690
But now please let the next list of intermediate targets,
that we continue to work with, should also contain Z.

00:21:10,430 --> 00:21:14,480
That is, we need to add Z there. One possibility
for this would be to use another predicate,

00:21:14,480 --> 00:21:19,160
which I will also introduce on lists.
We can say: "This new list L1, with which we continue working

00:21:19,160 --> 00:21:25,940
we continue to work with, is formed by a
list with Z and the previous list

00:21:25,940 --> 00:21:31,100
of intermediate targets." So, append stands for
Append. We can append two lists together.

00:21:31,100 --> 00:21:36,530
We take the list that has our new intermediate goal Z in it.
We take the previous list of intermediate goals.

00:21:36,530 --> 00:21:41,720
Form a new list from it. Namely the
concatenation of these two. There is then Z in it

00:21:41,720 --> 00:21:47,750
and all elements from L. Let this new list be,
from now on, the list of forbidden intermediate targets.

00:21:47,750 --> 00:21:55,700
And if we do it this way, we can conclude,
that our problem is solved. If we make this request again

00:21:55,700 --> 00:22:00,860
that is, if we take the same facts as in the
slide before and make the same request,

00:22:00,860 --> 00:22:05,300
we no longer have this endless search.
We state or Prolog states for us:

00:22:05,900 --> 00:22:11,000
We come from San Francisco to Honolulu, to
Maui, to San Francisco, and that's fine. There will be

00:22:11,000 --> 00:22:19,550
endless search and then moving around in circles, so to speak.
They didn't have to come up with that now. I have

00:22:19,550 --> 00:22:26,840
explained it to them from the knowledge
and a lot of experience with recursion. But it

00:22:26,840 --> 00:22:32,990
is worthwhile for you to think about this program

00:22:32,990 --> 00:22:39,140
and to compare it with our rules of thumb.
I have kept to the fact that there must be a

00:22:39,140 --> 00:22:45,530
base case that must exist. I chose that one first.
I have also made sure in the recursive rule

00:22:45,530 --> 00:22:52,100
that the recursive call came at the very end.
However, if you were very attentive, you

00:22:52,100 --> 00:22:57,020
might have noticed that elsewhere in the
lecture I had already said (meanwhile also

00:22:57,020 --> 00:23:02,540
at least twice) that negative
literals should always be placed as far as possible at the

00:23:02,540 --> 00:23:09,770
end of a rule. Here I have
obviously violated. And these are also contradictory goals.

00:23:09,770 --> 00:23:14,660
So on the one hand, negative information
at the end of a rule. On the other hand,

00:23:14,660 --> 00:23:20,940
recursive calls should be at the end of a rule.
So, you can ask yourself why it is now

00:23:20,940 --> 00:23:25,650
here and works like this.
One answer would be it works or you could

00:23:25,650 --> 00:23:30,300
try it out to see if it works. You can try it out.
Sometimes this way, sometimes that way. And then you find out that this

00:23:30,300 --> 00:23:37,170
variant, as it stands here, works better.
But I can also tell them that it is actually important here,

00:23:37,170 --> 00:23:45,690
that it is not a coincidence that this negative test
happens before the recursive call.

00:23:45,690 --> 00:23:51,690
Because it is supposed to avoid that we
visit the destination Z again.

00:23:51,690 --> 00:23:59,190
So, after we have chosen Z, we only want to execute the recursive
call/the further search only if Z

00:23:59,190 --> 00:24:03,480
has really not been visited yet.
That is, if we were to swap this order,

00:24:03,480 --> 00:24:09,360
we would write the not(member(Z,L)) at the end,
we would actually fall into an infinity trap again, so to

00:24:09,870 --> 00:24:15,150
speak. So, here either by trial and error
or by thinking a bit, it is important to

00:24:15,150 --> 00:24:22,800
first exclude that Z has already been seen, before we can
follow it up by a recursive call, so to speak.

00:24:22,800 --> 00:24:30,630
That motivates why the order is so right here.
We could well write the not(member(Z,L))

00:24:30,630 --> 00:24:36,840
in this place as well. So these
two literals could be exchanged. That would be okay.

00:24:36,840 --> 00:24:44,640
What would not be okay would be to write the not(member(Z,L))
at the very beginning of this right rule page.

00:24:44,640 --> 00:24:51,750
Then we really would have executed not(member(Z,L)) too
early. This idea of moving negation to the

00:24:51,750 --> 00:24:57,660
backwards, we should at least keep to it in this example so that we can
test this only

00:24:57,660 --> 00:25:05,910
after Z is chosen here. That's the reason here,
why we shouldn't swap the two. But a little bit,

00:25:05,910 --> 00:25:12,330
especially if you don't have much experience with Prolog,
you can figure things out by trial and error.

00:25:12,330 --> 00:25:21,160
That's also when they would have realized that this is the right presentation or
order. What we used, of course, were lists.

00:25:21,160 --> 00:25:26,350
Which I had not told them that much about yet,
so that should be the subject of the next video.
