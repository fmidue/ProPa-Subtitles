
0:00:00.000,0:00:06.570
Bei der Aufgabe 29 sollen wir uns jetzt mit
I/O, Input/Output beschäftigen. Das heißt,

0:00:06.570,0:00:09.990
wir machen jetzt eine interaktive
Applikation hier und dabei soll

0:00:09.990,0:00:14.610
einfach nur der User nach Zahlen gefragt
werden und die werden dann addiert und

0:00:14.610,0:00:19.500
das Ergebnis ausgegeben in der Kommandozeile.
Wenn der User als erste Zahl die Null eingibt,

0:00:19.500,0:00:23.100
dann soll das Ganze gestoppt werden und wir
bekommen als Ausgabe noch mal, wie oft wir

0:00:23.100,0:00:28.020
jetzt tatsächlich Zahlen addiert haben.
Dafür benutzen wir jetzt den I/O-Typen,

0:00:28.020,0:00:33.900
den unsere 'main'-Methode in dem Programm ja auch
schon hatte und das verwenden wir jetzt einfach

0:00:33.900,0:00:37.710
nur und der I/O-Typ ist extra dafür da, um so
interaktive, sequenzielle Sachen zu realisieren.

0:00:37.710,0:00:45.150
Und da gibt es eine spezielle Notation extra
für diese do-Notation. Das heißt, wenn wir

0:00:45.150,0:00:51.030
jetzt irgendwas mit I/O haben, dann machen wir
ein 'do', dann können wir danach sequenziell so

0:00:51.030,0:00:54.180
Befehle auflisten. Es gibt drei Möglichkeiten,
was wir dorthin schreiben können und das

0:00:54.180,0:00:58.770
wird dann einfach in der Reihenfolge, in der das
dasteht, abgearbeitet in diesem Block. Das heißt,

0:00:58.770,0:01:01.710
wir haben einmal die Möglichkeit, ein Kommando
direkt zu schreiben, was vom Typen I/O ist.

0:01:01.710,0:01:11.010
Wir können diesen Begriff hier hinschreiben.
Wir haben irgendeine x, das bekommen wir aus

0:01:11.010,0:01:18.420
einem Kommando und dieses Kommando hat dann gerade
den Typen von x, aber I/O davor stehen. Also das

0:01:18.420,0:01:22.800
hier ist zum Beispiel Integer und das Kommando
wäre dann 'IO (Integer)' vom Typen. Das heißt,

0:01:22.800,0:01:26.910
wir extrahieren sozusagen aus dem 'IO (Integer)'
einen Integer-Typen raus. Das bedeutet das hier,

0:01:26.910,0:01:32.190
so ungefähr. Während dieses Kommando hier
einfach nur Integer ohne extra Typ dahinter ist,

0:01:32.190,0:01:35.100
wie zum Beispiel der hier, das hier ist
ja auch I/O, aber dahinter steht kein

0:01:35.100,0:01:40.260
Typ. Das wäre dann so ein Kommando hier. Das ist
eigentlich nur eine Kurzfassung, weil eigentlich

0:01:40.260,0:01:44.460
würde hier dann auch so etwas stehen. Also wir
haben einfach nichts, in Anführungszeichen.

0:01:44.460,0:01:53.850
Das wird auch von einem Kommando gewonnen.
Also das ist einfach nur kurz gefasst,

0:01:53.850,0:01:56.760
schreibt man dann einfach nur das Kommando hin,
weil das irgendwie sinnlos ist, immer die leeren

0:01:56.760,0:02:04.170
Klammern dahin zu schreiben. Dann ist das hier
also äquivalent dazu. Und die dritte Möglichkeit,

0:02:04.170,0:02:08.990
die wir noch haben, ist einfach ein 'let'
Statement zu schreiben. Also wir sagen

0:02:08.990,0:02:15.800
irgendwie 'let a = 1+2'. Wir schreiben da alles
Mögliche rein. Das wird nacheinander abgearbeitet

0:02:15.800,0:02:24.170
und der tatsächliche Typ dieses ganzen Blocks
hier ist dann immer die letzten Anweisungen,

0:02:24.170,0:02:27.650
die wir geschrieben haben. Der Typ
von dieser Anweisung ist dann der Typ

0:02:27.650,0:02:31.610
des ganzen Blocks. Wenn wir jetzt hier ganz
unten noch hinschreiben würden, zum Beispiel.

0:02:31.610,0:02:37.280
'putStrLn' oder so etwas,

0:02:37.280,0:02:48.530
das ist ja auch eine I/O-Funktion, die einfach nur
diesen String hier in die Konsole printed. Dann

0:02:48.530,0:02:55.130
wäre jetzt der ganze Typ davon, ich schreibe
das mal hier drüber, wäre dann jetzt hier

0:02:55.130,0:03:00.860
auch I/O mit leeren Klammern dahinter. Weil das
hier macht ja was mit Input/Output, hat aber jetzt

0:03:00.860,0:03:07.100
keinen anderen Typ dahinter stehen, weil wir
kriegen ja keinen eingekapselten Wert oder so etwas,

0:03:07.100,0:03:11.600
sondern wir printen irgendwas auf die Konsole, das
hat keinen großartigen Typ in unserem Kontext

0:03:11.600,0:03:19.730
hier jetzt. Und was jetzt noch wichtig ist,
ist einfach nur, dass man darauf achtet, dass

0:03:19.730,0:03:23.180
das ja alles gleich eingerückt ist, was hinter
dem 'do' steht. Man muss das nicht unbedingt so

0:03:23.180,0:03:27.740
davor schreiben, man kann das auch so machen.
So kann man das auch formatieren, aber es muss

0:03:27.740,0:03:31.370
halt immer alles gleich eingerückt sein, in diesem
Block hier, ansonsten kriegt ihr Fehler und ihr

0:03:31.370,0:03:35.750
müsst auch aufpassen, dass da keine Tab-Charaktere
drin stehen. Die kann das Programm nämlich auch

0:03:35.750,0:03:41.630
nicht richtig lesen, da gibt es auch noch Fehler,
wenn man versucht, das zu starten. Wenn wir das

0:03:41.630,0:03:44.570
jetzt hier testen wollen, müssen wir erst mal hier
oben alles auskommentieren, was mit AutoTool zu

0:03:44.570,0:03:52.010
tun hat, weil das sonst lokal nicht funktioniert.
Also kommt das hier alles weg und man muss halt

0:03:52.010,0:03:56.450
noch so ein 'Import System.IO' hinzufügen, je
nachdem, welches Betriebssystem man hat. Das habe

0:03:56.450,0:04:00.800
ich hier schon vorher reingeschrieben, das stand
dort noch nicht drin. Damit wir die typischen I/O

0:04:00.800,0:04:05.390
Funktionen benutzen können. Wenn wir das jetzt
anwenden wollen, dann müssen wir jetzt mal kurz

0:04:05.390,0:04:09.260
gucken, wir sollen jetzt immer wieder genau das
Gleiche machen, nämlich zwei Zahlen addieren und

0:04:09.260,0:04:14.180
das Ergebnis ausgeben. Das schreit ja schon fast
nach einer Art Loop, wie wir das sonst auch in

0:04:14.180,0:04:20.120
imperativen Programmiersprachen haben. Also zum
Beispiel eine for-Schleife oder so etwas. Und hier

0:04:20.120,0:04:24.410
wird es jetzt einfach sozusagen eine Schleife,
die immer weiter läuft, 'while True' zum Beispiel,

0:04:24.410,0:04:28.070
und die dann irgendwann einfach abbricht,
mit der Null, wenn wir die bekommen als erste.



0:04:28.070,0:04:32.180
Zahl. Das heißt, es lohnt sich eigentlich
schon, eine Funktion 'loop' zu schreiben,

0:04:32.180,0:04:37.250
die wir dann in der 'main' benutzen. Wir haben
eine 'loop'-Funktion, da soll hinterher der

0:04:37.250,0:04:44.540
Typ I/O rauskommen, über der 'main' auch, sonst
können wir das nicht richtig benutzen und was man

0:04:44.540,0:04:47.090
sich jetzt noch merken muss, ist einfach
nur, wie oft wir diesen Loop gemacht haben.

0:04:47.090,0:04:51.245
Denn wir sollen hinterher ausgeben, wie viele
Additionen wir hatten. Das heißt, wir müssen jedes

0:04:51.245,0:04:56.150
Mal, wenn wir den Additionsloop machen, rechnen
wir eins obendrauf bis zum Abbruch. Das heißt,

0:04:56.150,0:05:01.700
wir können hier einfach so einen Integer-Parameter
mitschleppen und das zählt einfach, wie oft wir

0:05:01.700,0:05:08.960
den Loop insgesamt durchgemacht haben.
Also, wir haben 'loop', Parameter ist n,

0:05:08.960,0:05:17.000
das ist die Anzahl der Durchläufe und das machen
wir immer wieder. Also, wir haben einen do-Block

0:05:17.000,0:05:27.230
und der beginnt damit, dass wir dem User sagen,
was er machen soll. Wir machen 'putStrLn'. Das

0:05:27.230,0:05:30.800
setzt einfach einen String in die Kommandozeile
ab und macht dann einen Line-Break darunter,

0:05:30.800,0:05:36.740
sodass wir eine neue Zeile anfangen danach und
da setzen wir jetzt rein: Geben Sie die erste

0:05:36.740,0:05:49.580
Zahl ein, zum Beispiel. Dann lesen wir die Zahlen.
Dafür benutzen wir diese extrahier-Methode,

0:05:49.580,0:05:54.710
die ich eben gezeigt hatte. Also, wir machen
jetzt irgendwie 'zahl1', bekommen wir aus

0:05:54.710,0:06:01.220
'readLn'. Und 'readLn' ist eine Funktion, die
den ersten Input des Users aus der Kommandozeile

0:06:01.220,0:06:12.770
rausliest, die wir machen. Danach, so gucken
wir, ist das jetzt eine Null oder nicht, die

0:06:12.770,0:06:16.580
Zahl. Das heißt, wir müssen hier ein if-Statement
machen, das können wir hier natürlich auch machen.

0:06:16.580,0:06:22.580
Der ganz normale Haskell-Syntax geht immer noch,
man kann auch Cases benutzen, zum Beispiel. Und

0:06:22.580,0:06:31.010
dann testen wir einfach, ist die Zahl jetzt gleich
null. Wenn ja, dann müssen wir jetzt abbrechen.

0:06:31.010,0:06:36.710
Das heißt, wir setzen erst mal noch
eine Erklärung ab, für den User,

0:06:36.710,0:06:55.790
brechen das Programm ab und sagen, die Anzahl
der Additionen ist und dann zeigen wir unser n,

0:06:55.790,0:07:00.830
also das ist ja die Anzahl der Loops, die wir
gemacht haben, also die Anzahl der Additionen.

0:07:00.830,0:07:04.760
Da müssen wir jetzt noch 'show n' machen
anstatt nur n, denn n ist ja kein String,

0:07:04.760,0:07:09.560
sondern eine Integerzahl. Das heißt, wir müssen
'show' benutzen, was dann einfach nur das Argument

0:07:09.560,0:07:14.750
in einen String umwandelt. So und noch einen
Punkt dahinter. Hier müssen noch Klammern drum.

0:07:14.750,0:07:36.200
Und was jetzt eine Besonderheit ist, man muss
jetzt hier, wenn man solche 'if then else'

0:07:36.200,0:07:40.400
oder wenn man Cases benutzt, muss man für jeden
Case oder sowohl für das 'then' als auch das 'else',

0:07:40.400,0:07:46.010
muss man jeweils einen neuen do-Block schreiben.
Also das muss man auf jeden Fall bedenken, dass

0:07:46.010,0:07:51.410
man da immer einen neuen do-Block für jeden Fall
machen muss. Dann wird einfach entschieden, welcher

0:07:51.410,0:07:57.680
do-Block abgearbeitet wird. Falls wir jetzt keine
Null haben, wollen wir die zweite Zahl lesen.

0:07:57.680,0:08:04.340
Also, geben Sie die zweite Zahl ein.

0:08:04.340,0:08:22.520
Dann lesen wir die Zahl. 'zahl2'
wird gelesen, wieder mit 'readLn'.

0:08:28.420,0:08:31.600
Entweder ich zeige jetzt einfach mal,
dass man hier auch 'lets' benutzen kann,

0:08:31.600,0:08:33.970
einfach nur der Vollständigkeit halber. Das
ist jetzt nicht notwendig, das Kommando,

0:08:33.970,0:08:40.360
ich mache es jetzt einfach. Sagen wir mal,
Ergebnis ist dann 'zahl1' plus 'zahl2',

0:08:40.360,0:08:48.455
dann printen wir das,

0:08:48.455,0:08:48.470
'show ergebnis'.

0:08:48.470,0:09:25.840
Und dann Punkt. Das können wir eigentlich mal
eben testen, bevor wir jetzt das zu Ende machen,

0:09:25.840,0:09:33.085
und zwar geben wir in der 'main' einfach
'loop' und fangen da mit 0 Durchläufen an.

0:09:33.085,0:09:47.060
Gucken wir mal, was hier passiert. Also, wir geben
eine Zahl ein: vier minus neun und das Ergebnis

0:09:47.060,0:09:52.340
ist minus fünf, stimmt! Das hat er aber nur einmal
gemacht, ich möchte jetzt natürlich noch die

0:09:52.340,0:09:57.950
Schleife irgendwie hereinkriegen. Das heißt, wir
müssen hier, müssen wir jetzt noch die Schleife

0:09:57.950,0:10:00.860
einfach neu aufrufen. Das machen wir einfach, indem
wir hier die Funktion selbst wieder aufrufen,

0:10:00.860,0:10:08.120
'loop' und 'n + 1'. n war ja die Anzahl, die wir
am Anfang hatten und dann rechnen wir einfach eins

0:10:08.120,0:10:12.050
drauf, führen das Ganze neu aus und das
ist auch noch in Ordnung vom Typen her,

0:10:12.050,0:10:17.600
weil das ist ja dann auch wieder vom Typen I/O,
leere Klammern, wie wir das hier auch hatten,

0:10:17.600,0:10:25.400
passt also auch zusammen und dann können wir
das in die 'main' packen. Jetzt können wir das

0:10:25.400,0:10:36.620
komplett testen und jetzt sollte eigentlich
alles gehen. 3 und 2 sind 5, 8 und -9,

0:10:40.690,0:10:49.300
8 und 0 und dann machen wir die Null und die
Anzahl der Additionen bei 3, und das stimmt.

0:10:49.300,0:10:55.630
Passt alles. Die einzige Sache, die jetzt hier
vollständigerhalber vielleicht fehlen würde, aber

0:10:55.630,0:11:00.400
eine Aufgabe gar nicht erwähnt war, dass man halt
auch irgendwelchen Quatsch eingeben kann. Zeige

0:11:00.400,0:11:04.750
ich mal. Ich kann jetzt hier natürlich einfach
keine Zahl angeben. Daran hindert mich ja keiner.

0:11:04.750,0:11:10.690
Ich könnte jetzt ein j eingeben oder so und dann
würde das Programm einfach abstürzen mit einer


00:11:10.690 --> 00:11:16.300
user error, weil das ja nicht zusammenpasst. Wenn
er da 'readLn' macht und dann ist das gar keine

00:11:16.300 --> 00:11:21.040
Zahl, aber ich checke hier, ob die Zahl gleich Null
ist, dann passt das nicht zusammen. Dann erwartet

00:11:21.040 --> 00:11:26.050
er anhand dieses Kommandos hier schon, dass das
eine Zahl ist. Dann ist also automatisch dadurch,

00:11:26.980 --> 00:11:32.350
dass er jetzt hier sehen kann, dass 'zahl1' eine
Zahl ist (ein Integer), nimmt er auch an, dass

00:11:32.350 --> 00:11:36.730
das hier den Typ 'IO (Integer)' hat, tut
es aber dann nicht, wenn ich dort j eingebe.

00:11:36.730 --> 00:11:40.240
Und dann crasht das Programm einfach. Also das
haben wir jetzt gar nicht behandelt, war aber auch

00:11:40.240 --> 00:11:43.510
nicht Sinn der Aufgabe. Es war nur, um zu zeigen, dass
das nicht unbedingt full proof ist, das, was man

00:11:43.510 --> 00:11:49.450
hier macht. Da müsste man dann vielleicht mit
'Maybe' oder 'Either' arbeiten, um das zu filtern,

00:11:49.450 --> 00:11:52.855
dass man einfach irgendeine Nachricht sendet,
wenn du dann einen String eingibst, wenn

00:11:52.855 --> 00:11:59.380
man dann 'Either String' oder Zahl oder so etwas,
String oder Integer. Aber das nur schon mal,

00:11:59.380 --> 00:12:02.830
um vorauszuschauen, was man da noch alles machen
kann. Das ist jetzt noch nicht perfekt, das Ganze.
